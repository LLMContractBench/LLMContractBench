[
  {
    "id": 1,
    "addr4sss": "0x0000000000075efbee23fe2de1bd0b7690883cc9",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      }
    ],
    "SMART_CONTRACT_CODE": "/**\n\n *Submitted for verification at Etherscan.io on 2018-12-18\n\n*/\n\n\n\npragma solidity ^0.4.23;\n\n\n\n// This is the proxy contract for the TrustToken Registry\n\n\n\n// File: contracts/Proxy/Proxy.sol\n\n\n\n/**\n\n * @title Proxy\n\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n\n */\n\ncontract Proxy {\n\n    \n\n    /**\n\n    * @dev Tells the address of the implementation where every call will be delegated.\n\n    * @return address of the implementation to which it will be delegated\n\n    */\n\n    function implementation() public view returns (address);\n\n\n\n    /**\n\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n\n    * This function will return whatever the implementation call returns\n\n    */\n\n    function() external payable {\n\n        address _impl = implementation();\n\n        require(_impl != address(0), \"implementation contract not set\");\n\n        \n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            let size := returndatasize\n\n            returndatacopy(ptr, 0, size)\n\n\n\n            switch result\n\n            case 0 { revert(ptr, size) }\n\n            default { return(ptr, size) }\n\n        }\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/UpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title UpgradeabilityProxy\n\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n\n */\n\ncontract UpgradeabilityProxy is Proxy {\n\n    /**\n\n    * @dev This event will be emitted every time the implementation gets upgraded\n\n    * @param implementation representing the address of the upgraded implementation\n\n    */\n\n    event Upgraded(address indexed implementation);\n\n\n\n    // Storage position of the address of the current implementation\n\n    bytes32 private constant implementationPosition = keccak256(\"trueUSD.proxy.implementation\");\n\n\n\n    /**\n\n    * @dev Tells the address of the current implementation\n\n    * @return address of the current implementation\n\n    */\n\n    function implementation() public view returns (address impl) {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          impl := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the current implementation\n\n    * @param newImplementation address representing the new implementation to be set\n\n    */\n\n    function _setImplementation(address newImplementation) internal {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          sstore(position, newImplementation)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Upgrades the implementation address\n\n    * @param newImplementation representing the address of the new implementation to be set\n\n    */\n\n    function _upgradeTo(address newImplementation) internal {\n\n        address currentImplementation = implementation();\n\n        require(currentImplementation != newImplementation);\n\n        _setImplementation(newImplementation);\n\n        emit Upgraded(newImplementation);\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title OwnedUpgradeabilityProxy\n\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n\n */\n\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n\n    /**\n\n    * @dev Event to show ownership has been transferred\n\n    * @param previousOwner representing the address of the previous owner\n\n    * @param newOwner representing the address of the new owner\n\n    */\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev Event to show ownership transfer is pending\n\n    * @param currentOwner representing the address of the current owner\n\n    * @param pendingOwner representing the address of the pending owner\n\n    */\n\n    event NewPendingOwner(address currentOwner, address pendingOwner);\n\n    \n\n    // Storage position of the owner and pendingOwner of the contract\n\n    bytes32 private constant proxyOwnerPosition = keccak256(\"trueUSD.proxy.owner\");\n\n    bytes32 private constant pendingProxyOwnerPosition = keccak256(\"trueUSD.pending.proxy.owner\");\n\n\n\n    /**\n\n    * @dev the constructor sets the original owner of the contract to the sender account.\n\n    */\n\n    constructor() public {\n\n        _setUpgradeabilityOwner(msg.sender);\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyProxyOwner() {\n\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the pending owner.\n\n    */\n\n    modifier onlyPendingProxyOwner() {\n\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function proxyOwner() public view returns (address owner) {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            owner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function pendingProxyOwner() public view returns (address pendingOwner) {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            pendingOwner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newPendingProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    *changes the pending owner to newOwner. But doesn't actually transfer\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        _setPendingUpgradeabilityOwner(newOwner);\n\n        emit NewPendingOwner(proxyOwner(), newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the pendingOwner to claim ownership of the proxy\n\n    */\n\n    function claimProxyOwnership() external onlyPendingProxyOwner {\n\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n\n        _setUpgradeabilityOwner(pendingProxyOwner());\n\n        _setPendingUpgradeabilityOwner(address(0));\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n\n    * @param implementation representing the address of the new implementation to be set.\n\n    */\n\n    function upgradeTo(address implementation) external onlyProxyOwner {\n\n        _upgradeTo(implementation);\n\n    }\n\n}"
  },
  {
    "id": 2,
    "addr4sss": "0x00000000000da14c27c155bb7c1ac9bd7519eb3b",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n// File: contracts/utilities/DepositAddressRegistrar.sol\n\n\n\ninterface Registry {\n\n    function setAttributeValue(address who, bytes32 what, uint val) external;\n\n    function hasAttribute(address _who, bytes32 _attribute) external view returns(bool);\n\n}\n\n\n\ncontract DepositAddressRegistrar {\n\n    Registry public registry;\n\n    \n\n    bytes32 public constant IS_DEPOSIT_ADDRESS = \"isDepositAddress\"; \n\n    event DepositAddressRegistered(address registeredAddress);\n\n\n\n    constructor(address _registry) public {\n\n        registry = Registry(_registry);\n\n    }\n\n    \n\n    function registerDepositAddress() public {\n\n        address shiftedAddress = address(uint(msg.sender) >> 20);\n\n        require(!registry.hasAttribute(shiftedAddress, IS_DEPOSIT_ADDRESS), \"deposit address already registered\");\n\n        registry.setAttributeValue(shiftedAddress, IS_DEPOSIT_ADDRESS, uint(msg.sender));\n\n        emit DepositAddressRegistered(msg.sender);\n\n    }\n\n    \n\n    function() external payable {\n\n        registerDepositAddress();\n\n        msg.sender.transfer(msg.value);\n\n    }\n\n}"
  },
  {
    "id": 3,
    "addr4sss": "0x0000000000b3f879cb30fe243b4dfee438691c04",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.10;\n\n\n\ncontract GasToken2 {\n\n    //////////////////////////////////////////////////////////////////////////\n\n    // RLP.sol\n\n    // Due to some unexplained bug, we get a slightly different bytecode if \n\n    // we use an import, and are then unable to verify the code in Etherscan\n\n    //////////////////////////////////////////////////////////////////////////\n\n    \n\n    uint256 constant ADDRESS_BYTES = 20;\n\n    uint256 constant MAX_SINGLE_BYTE = 128;\n\n    uint256 constant MAX_NONCE = 256**9 - 1;\n\n\n\n    // count number of bytes required to represent an unsigned integer\n\n    function count_bytes(uint256 n) constant internal returns (uint256 c) {\n\n        uint i = 0;\n\n        uint mask = 1;\n\n        while (n >= mask) {\n\n            i += 1;\n\n            mask *= 256;\n\n        }\n\n\n\n        return i;\n\n    }\n\n\n\n    function mk_contract_address(address a, uint256 n) constant internal returns (address rlp) {\n\n        /*\n\n         * make sure the RLP encoding fits in one word:\n\n         * total_length      1 byte\n\n         * address_length    1 byte\n\n         * address          20 bytes\n\n         * nonce_length      1 byte (or 0)\n\n         * nonce           1-9 bytes\n\n         *                ==========\n\n         *                24-32 bytes\n\n         */\n\n        require(n <= MAX_NONCE);\n\n\n\n        // number of bytes required to write down the nonce\n\n        uint256 nonce_bytes;\n\n        // length in bytes of the RLP encoding of the nonce\n\n        uint256 nonce_rlp_len;\n\n\n\n        if (0 < n && n < MAX_SINGLE_BYTE) {\n\n            // nonce fits in a single byte\n\n            // RLP(nonce) = nonce\n\n            nonce_bytes = 1;\n\n            nonce_rlp_len = 1;\n\n        } else {\n\n            // RLP(nonce) = [num_bytes_in_nonce nonce]\n\n            nonce_bytes = count_bytes(n);\n\n            nonce_rlp_len = nonce_bytes + 1;\n\n        }\n\n\n\n        // [address_length(1) address(20) nonce_length(0 or 1) nonce(1-9)]\n\n        uint256 tot_bytes = 1 + ADDRESS_BYTES + nonce_rlp_len;\n\n\n\n        // concatenate all parts of the RLP encoding in the leading bytes of\n\n        // one 32-byte word\n\n        uint256 word = ((192 + tot_bytes) * 256**31) +\n\n                       ((128 + ADDRESS_BYTES) * 256**30) +\n\n                       (uint256(a) * 256**10);\n\n\n\n        if (0 < n && n < MAX_SINGLE_BYTE) {\n\n            word += n * 256**9;\n\n        } else {\n\n            word += (128 + nonce_bytes) * 256**9;\n\n            word += n * 256**(9 - nonce_bytes);\n\n        }\n\n\n\n        uint256 hash;\n\n\n\n        assembly {\n\n            let mem_start := mload(0x40)        // get a pointer to free memory\n\n            mstore(0x40, add(mem_start, 0x20))  // update the pointer\n\n\n\n            mstore(mem_start, word)             // store the rlp encoding\n\n            hash := sha3(mem_start,\n\n                         add(tot_bytes, 1))     // hash the rlp encoding\n\n        }\n\n\n\n        // interpret hash as address (20 least significant bytes)\n\n        return address(hash);\n\n    }\n\n    \n\n    //////////////////////////////////////////////////////////////////////////\n\n    // Generic ERC20\n\n    //////////////////////////////////////////////////////////////////////////\n\n\n\n    // owner -> amount\n\n    mapping(address => uint256) s_balances;\n\n    // owner -> spender -> max amount\n\n    mapping(address => mapping(address => uint256)) s_allowances;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\n    // Spec: Get the account balance of another account with address `owner`\n\n    function balanceOf(address owner) public constant returns (uint256 balance) {\n\n        return s_balances[owner];\n\n    }\n\n\n\n    function internalTransfer(address from, address to, uint256 value) internal returns (bool success) {\n\n        if (value <= s_balances[from]) {\n\n            s_balances[from] -= value;\n\n            s_balances[to] += value;\n\n            Transfer(from, to, value);\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    // Spec: Send `value` amount of tokens to address `to`\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n\n        address from = msg.sender;\n\n        return internalTransfer(from, to, value);\n\n    }\n\n\n\n    // Spec: Send `value` amount of tokens from address `from` to address `to`\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n\n        address spender = msg.sender;\n\n        if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) {\n\n            s_allowances[from][spender] -= value;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    // Spec: Allow `spender` to withdraw from your account, multiple times, up\n\n    // to the `value` amount. If this function is called again it overwrites the\n\n    // current allowance with `value`.\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n\n        address owner = msg.sender;\n\n        if (value != 0 && s_allowances[owner][spender] != 0) {\n\n            return false;\n\n        }\n\n        s_allowances[owner][spender] = value;\n\n        Approval(owner, spender, value);\n\n        return true;\n\n    }\n\n\n\n    // Spec: Returns the `amount` which `spender` is still allowed to withdraw\n\n    // from `owner`.\n\n    // What if the allowance is higher than the balance of the `owner`?\n\n    // Callers should be careful to use min(allowance, balanceOf) to make sure\n\n    // that the allowance is actually present in the account!\n\n    function allowance(address owner, address spender) public constant returns (uint256 remaining) {\n\n        return s_allowances[owner][spender];\n\n    }\n\n\n\n    //////////////////////////////////////////////////////////////////////////\n\n    // GasToken specifics\n\n    //////////////////////////////////////////////////////////////////////////\n\n\n\n    uint8 constant public decimals = 2;\n\n    string constant public name = \"Gastoken.io\";\n\n    string constant public symbol = \"GST2\";\n\n\n\n    // We build a queue of nonces at which child contracts are stored. s_head is\n\n    // the nonce at the head of the queue, s_tail is the nonce behind the tail\n\n    // of the queue. The queue grows at the head and shrinks from the tail.\n\n    // Note that when and only when a contract CREATEs another contract, the\n\n    // creating contract's nonce is incremented.\n\n    // The first child contract is created with nonce == 1, the second child\n\n    // contract is created with nonce == 2, and so on...\n\n    // For example, if there are child contracts at nonces [2,3,4],\n\n    // then s_head == 4 and s_tail == 1. If there are no child contracts,\n\n    // s_head == s_tail.\n\n    uint256 s_head;\n\n    uint256 s_tail;\n\n\n\n    // totalSupply gives  the number of tokens currently in existence\n\n    // Each token corresponds to one child contract that can be SELFDESTRUCTed\n\n    // for a gas refund.\n\n    function totalSupply() public constant returns (uint256 supply) {\n\n        return s_head - s_tail;\n\n    }\n\n\n\n    // Creates a child contract that can only be destroyed by this contract.\n\n    function makeChild() internal returns (address addr) {\n\n        assembly {\n\n            // EVM assembler of runtime portion of child contract:\n\n            //     ;; Pseudocode: if (msg.sender != 0x0000000000b3f879cb30fe243b4dfee438691c04) { throw; }\n\n            //     ;;             suicide(msg.sender)\n\n            //     PUSH15 0xb3f879cb30fe243b4dfee438691c04 ;; hardcoded address of this contract\n\n            //     CALLER\n\n            //     XOR\n\n            //     PC\n\n            //     JUMPI\n\n            //     CALLER\n\n            //     SELFDESTRUCT\n\n            // Or in binary: 6eb3f879cb30fe243b4dfee438691c043318585733ff\n\n            // Since the binary is so short (22 bytes), we can get away\n\n            // with a very simple initcode:\n\n            //     PUSH22 0x6eb3f879cb30fe243b4dfee438691c043318585733ff\n\n            //     PUSH1 0\n\n            //     MSTORE ;; at this point, memory locations mem[10] through\n\n            //            ;; mem[31] contain the runtime portion of the child\n\n            //            ;; contract. all that's left to do is to RETURN this\n\n            //            ;; chunk of memory.\n\n            //     PUSH1 22 ;; length\n\n            //     PUSH1 10 ;; offset\n\n            //     RETURN\n\n            // Or in binary: 756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3\n\n            // Almost done! All we have to do is put this short (31 bytes) blob into\n\n            // memory and call CREATE with the appropriate offsets.\n\n            let solidity_free_mem_ptr := mload(0x40)\n\n            mstore(solidity_free_mem_ptr, 0x00756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3)\n\n            addr := create(0, add(solidity_free_mem_ptr, 1), 31)\n\n        }\n\n    }\n\n\n\n    // Mints `value` new sub-tokens (e.g. cents, pennies, ...) by creating `value`\n\n    // new child contracts. The minted tokens are owned by the caller of this\n\n    // function.\n\n    function mint(uint256 value) public {\n\n        for (uint256 i = 0; i < value; i++) {\n\n            makeChild();\n\n        }\n\n        s_head += value;\n\n        s_balances[msg.sender] += value;\n\n    }\n\n\n\n    // Destroys `value` child contracts and updates s_tail.\n\n    //\n\n    // This function is affected by an issue in solc: https://github.com/ethereum/solidity/issues/2999\n\n    // The `mk_contract_address(this, i).call();` doesn't forward all available gas, but only GAS - 25710.\n\n    // As a result, when this line is executed with e.g. 30000 gas, the callee will have less than 5000 gas\n\n    // available and its SELFDESTRUCT operation will fail leading to no gas refund occurring.\n\n    // The remaining ~29000 gas left after the call is enough to update s_tail and the caller's balance.\n\n    // Hence tokens will have been destroyed without a commensurate gas refund.\n\n    // Fortunately, there is a simple workaround:\n\n    // Whenever you call free, freeUpTo, freeFrom, or freeUpToFrom, ensure that you pass at least\n\n    // 25710 + `value` * (1148 + 5722 + 150) gas. (It won't all be used)\n\n    function destroyChildren(uint256 value) internal {\n\n        uint256 tail = s_tail;\n\n        // tail points to slot behind the last contract in the queue\n\n        for (uint256 i = tail + 1; i <= tail + value; i++) {\n\n            mk_contract_address(this, i).call();\n\n        }\n\n\n\n        s_tail = tail + value;\n\n    }\n\n\n\n    // Frees `value` sub-tokens (e.g. cents, pennies, ...) belonging to the\n\n    // caller of this function by destroying `value` child contracts, which\n\n    // will trigger a partial gas refund.\n\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\n\n    // when calling this function. For details, see the comment above `destroyChilden`.\n\n    function free(uint256 value) public returns (bool success) {\n\n        uint256 from_balance = s_balances[msg.sender];\n\n        if (value > from_balance) {\n\n            return false;\n\n        }\n\n\n\n        destroyChildren(value);\n\n\n\n        s_balances[msg.sender] = from_balance - value;\n\n\n\n        return true;\n\n    }\n\n\n\n    // Frees up to `value` sub-tokens. Returns how many tokens were freed.\n\n    // Otherwise, identical to free.\n\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\n\n    // when calling this function. For details, see the comment above `destroyChilden`.\n\n    function freeUpTo(uint256 value) public returns (uint256 freed) {\n\n        uint256 from_balance = s_balances[msg.sender];\n\n        if (value > from_balance) {\n\n            value = from_balance;\n\n        }\n\n\n\n        destroyChildren(value);\n\n\n\n        s_balances[msg.sender] = from_balance - value;\n\n\n\n        return value;\n\n    }\n\n\n\n    // Frees `value` sub-tokens owned by address `from`. Requires that `msg.sender`\n\n    // has been approved by `from`.\n\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\n\n    // when calling this function. For details, see the comment above `destroyChilden`.\n\n    function freeFrom(address from, uint256 value) public returns (bool success) {\n\n        address spender = msg.sender;\n\n        uint256 from_balance = s_balances[from];\n\n        if (value > from_balance) {\n\n            return false;\n\n        }\n\n\n\n        mapping(address => uint256) from_allowances = s_allowances[from];\n\n        uint256 spender_allowance = from_allowances[spender];\n\n        if (value > spender_allowance) {\n\n            return false;\n\n        }\n\n\n\n        destroyChildren(value);\n\n\n\n        s_balances[from] = from_balance - value;\n\n        from_allowances[spender] = spender_allowance - value;\n\n\n\n        return true;\n\n    }\n\n\n\n    // Frees up to `value` sub-tokens owned by address `from`. Returns how many tokens were freed.\n\n    // Otherwise, identical to `freeFrom`.\n\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\n\n    // when calling this function. For details, see the comment above `destroyChilden`.\n\n    function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {\n\n        address spender = msg.sender;\n\n        uint256 from_balance = s_balances[from];\n\n        if (value > from_balance) {\n\n            value = from_balance;\n\n        }\n\n\n\n        mapping(address => uint256) from_allowances = s_allowances[from];\n\n        uint256 spender_allowance = from_allowances[spender];\n\n        if (value > spender_allowance) {\n\n            value = spender_allowance;\n\n        }\n\n\n\n        destroyChildren(value);\n\n\n\n        s_balances[from] = from_balance - value;\n\n        from_allowances[spender] = spender_allowance - value;\n\n\n\n        return value;\n\n    }\n\n}"
  },
  {
    "id": 4,
    "addr4sss": "0x000000002bb43c83ece652d161ad0fa862129a2c",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 1,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.20;// blaze it\n\n\n\ninterface ERC20 {\n\n    function totalSupply() external constant returns (uint supply);\n\n    function balanceOf(address _owner) external constant returns (uint balance);\n\n    function transfer(address _to, uint _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n\n    function approve(address _spender, uint _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external constant returns (uint remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\ncontract TokenRescue {\n\n    // use this method to rescue your tokens if you sent them by mistake but be quick or someone else will get them\n\n    function rescueToken(ERC20 _token)\n\n    external\n\n    {\n\n        _token.transfer(msg.sender, _token.balanceOf(this));\n\n    }\n\n    // require data for transactions\n\n    function() external payable {\n\n        revert();\n\n    }\n\n}\n\ninterface AccountRegistryInterface {\n\n    function canVoteOnProposal(address _voter, address _proposal) external view returns (bool);\n\n}\n\ncontract Vote is ERC20, TokenRescue {\n\n    uint256 supply = 0;\n\n    AccountRegistryInterface public accountRegistry = AccountRegistryInterface(0x000000002bb43c83eCe652d161ad0fa862129A2C);\n\n    address public owner = 0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1;\n\n\n\n    uint8 public constant decimals = 1;\n\n    string public symbol = \"FV\";\n\n    string public name = \"FinneyVote\";\n\n\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) approved;\n\n\n\n    function totalSupply() external constant returns (uint256) {\n\n        return supply;\n\n    }\n\n    function balanceOf(address _owner) external constant returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n    function approve(address _spender, uint256 _value) external returns (bool) {\n\n        approved[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n    function allowance(address _owner, address _spender) external constant returns (uint256) {\n\n        return approved[_owner][_spender];\n\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool) {\n\n        if (balances[msg.sender] < _value) {\n\n            return false;\n\n        }\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\n\n        if (balances[_from] < _value\n\n         || approved[_from][msg.sender] < _value\n\n         || _value == 0) {\n\n            return false;\n\n        }\n\n        approved[_from][msg.sender] -= _value;\n\n        balances[_from] -= _value;\n\n        balances[_to] += _value;\n\n        Transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n    function grant(address _to, uint256 _grant) external {\n\n        require(msg.sender == address(accountRegistry));\n\n        balances[_to] += _grant;\n\n        supply += _grant;\n\n        Transfer(address(0), _to, _grant);\n\n    }\n\n    // vote5 and vote1 are available for future use\n\n    function vote5(address _voter, address _votee) external {\n\n        require(balances[_voter] >= 10);\n\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\n\n        balances[_voter] -= 10;\n\n        balances[owner] += 5;\n\n        balances[_votee] += 5;\n\n        Transfer(_voter, owner, 5);\n\n        Transfer(_voter, _votee, 5);\n\n    }\n\n    function vote1(address _voter, address _votee) external {\n\n        require(balances[_voter] >= 10);\n\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\n\n        balances[_voter] -= 10;\n\n        balances[owner] += 9;\n\n        balances[_votee] += 1;\n\n        Transfer(_voter, owner, 9);\n\n        Transfer(_voter, _votee, 1);\n\n    }\n\n    function vote9(address _voter, address _votee) external {\n\n        require(balances[_voter] >= 10);\n\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\n\n        balances[_voter] -= 10;\n\n        balances[owner] += 1;\n\n        balances[_votee] += 9;\n\n        Transfer(_voter, owner, 1);\n\n        Transfer(_voter, _votee, 9);\n\n    }\n\n    modifier onlyOwner () {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n    event Owner(address indexed owner);\n\n    event Registry(address indexed registry);\n\n    function transferOwnership(address _newOwner)\n\n    external onlyOwner {\n\n        uint256 balance = balances[owner];\n\n        balances[_newOwner] += balance;\n\n        balances[owner] = 0;\n\n        Transfer(owner, _newOwner, balance);\n\n        owner = _newOwner;\n\n        Owner(_newOwner);\n\n    }\n\n    function migrateAccountRegistry(AccountRegistryInterface _newAccountRegistry)\n\n    external onlyOwner {\n\n        accountRegistry = _newAccountRegistry;\n\n        Registry(_newAccountRegistry);\n\n    }\n\n}\n\ninterface ProposalInterface {\n\n    /* uint8:\n\n        enum Position {\n\n            SKIP, // default\n\n            APPROVE,\n\n            REJECT,\n\n            AMEND, // == (APPROVE | REJECT)\n\n            LOL\n\n            // more to be determined by community\n\n        }\n\n    */\n\n    function getPosition(address _user) external view returns (uint8);\n\n    function argumentCount() external view returns (uint256);\n\n    function vote(uint256 _argumentId) external;\n\n    // bytes could be:\n\n    // utf8 string\n\n    // swarm hash\n\n    // ipfs hash\n\n    // and others tbd\n\n    event Case(bytes content);\n\n}\n\ncontract ProperProposal is ProposalInterface, TokenRescue {\n\n    struct Argument {\n\n        address source;\n\n        uint8 position;\n\n        uint256 count;\n\n    }\n\n    Argument[] public arguments;\n\n    mapping (address => uint256) public votes;\n\n    Vote public constant voteToken = Vote(0x000000002647e16d9BaB9e46604D75591D289277);\n\n\n\n    function getPosition(address _user)\n\n    external view\n\n    returns (uint8) {\n\n        return arguments[votes[_user]].position;\n\n    }\n\n\n\n    function argumentCount() external view returns (uint256) {\n\n        return arguments.length;\n\n    }\n\n    function argumentSource(uint256 _index)\n\n    external view\n\n    returns (address) {\n\n        return arguments[_index].source;\n\n    }\n\n\n\n    function argumentPosition(uint256 _index)\n\n    external view\n\n    returns (uint8) {\n\n        return arguments[_index].position;\n\n    }\n\n\n\n    function argumentVoteCount(uint256 _index)\n\n    external view\n\n    returns (uint256) {\n\n        return arguments[_index].count;\n\n    }\n\n\n\n    function source()\n\n    external view\n\n    returns (address) {\n\n        return arguments[0].source;\n\n    }\n\n\n\n    function voteCount()\n\n    external view\n\n    returns (uint256) {\n\n        return -arguments[0].count;\n\n    }\n\n\n\n    function vote(uint256 _argumentId)\n\n    external {\n\n        address destination = arguments[_argumentId].source;\n\n        voteToken.vote9(msg.sender, destination);\n\n        arguments[votes[msg.sender]].count--;\n\n        arguments[\n\n            votes[msg.sender] = _argumentId\n\n        ].count++;\n\n    }\n\n\n\n    event Case(bytes content);\n\n\n\n    function argue(uint8 _position, bytes _text)\n\n    external\n\n    returns (uint256) {\n\n        address destination = arguments[0].source;\n\n        voteToken.vote9(msg.sender, destination);\n\n        uint256 argumentId = arguments.length;\n\n        arguments.push(Argument(msg.sender, _position, 1));\n\n        Case(_text);\n\n        arguments[votes[msg.sender]].count--;\n\n        votes[msg.sender] = argumentId;\n\n        return argumentId;\n\n    }\n\n\n\n    function init(address _source, bytes _resolution)\n\n    external {\n\n        assert(msg.sender == 0x000000002bb43c83eCe652d161ad0fa862129A2C);\n\n        arguments.push(Argument(_source, 0/*SKIP*/, 0));\n\n        Case(_resolution);\n\n    }\n\n}\n\ninterface CabalInterface {\n\n    // TBD\n\n    function canonCount() external view returns (uint256);\n\n}\n\ncontract AccountRegistry is AccountRegistryInterface, TokenRescue {\n\n    \n\n    uint256 constant public registrationDeposit = 1 finney;\n\n    uint256 constant public proposalCensorshipFee = 50 finney;\n\n\n\n    // this is the first deterministic contract address for 0x24AE90765668938351075fB450892800d9A52E39\n\n    address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1;\n\n\n\n    Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277);\n\n\n\n    /* uint8 membership bitmap:\n\n     * 0 - proposer\n\n     * 1 - registered to vote\n\n     * 2 - pending proposal\n\n     * 3 - proposal\n\n     * 4 - board member\n\n     * 5 - pending cabal\n\n     * 6 - cabal\n\n     * 7 - board\n\n     */\n\n    uint8 constant UNCONTACTED = 0;\n\n    uint8 constant PROPOSER = 1;\n\n    uint8 constant VOTER = 2;\n\n    uint8 constant PENDING_PROPOSAL = 4;\n\n    uint8 constant PROPOSAL = 8;\n\n    uint8 constant PENDING_CABAL = 16;\n\n    uint8 constant CABAL = 32;\n\n    uint8 constant BOARD = 64;\n\n    struct Account {\n\n        uint256 lastAccess;\n\n        uint8 membership;\n\n        address appointer;//nominated this account for BOARD\n\n        address denouncer;//denounced this BOARD account\n\n        address voucher;//nominated this account for PROPOSER\n\n        address devoucher;//denounced this account for PROPOSER\n\n    }\n\n    mapping (address => Account) accounts;\n\n\n\n    function AccountRegistry()\n\n    public\n\n    {\n\n        accounts[0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1].membership = BOARD;\n\n        Board(0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1);\n\n        accounts[0x90Fa310397149A7a9058Ae2d56e66e707B12D3A7].membership = BOARD;\n\n        Board(0x90Fa310397149A7a9058Ae2d56e66e707B12D3A7);\n\n        accounts[0x424a6e871E8cea93791253B47291193637D6966a].membership = BOARD;\n\n        Board(0x424a6e871E8cea93791253B47291193637D6966a);\n\n        accounts[0xA4caDe6ecbed8f75F6fD50B8be92feb144400CC4].membership = BOARD;\n\n        Board(0xA4caDe6ecbed8f75F6fD50B8be92feb144400CC4);\n\n    }\n\n\n\n    event Voter(address indexed voter);\n\n    event Deregistered(address indexed voter);\n\n    event Nominated(address indexed board, string endorsement);\n\n    event Board(address indexed board);\n\n    event Denounced(address indexed board, string reason);\n\n    event Revoked(address indexed board);\n\n    event Proposal(ProposalInterface indexed proposal);\n\n    event Cabal(CabalInterface indexed cabal);\n\n    event BannedProposal(ProposalInterface indexed proposal, string reason);\n\n    event Vouch(address indexed proposer, string vouch);\n\n    event Proposer(address indexed proposer);\n\n    event Devouch(address indexed proposer, string vouch);\n\n    event Shutdown(address indexed proposer);\n\n\n\n    // To register a Cabal, you must\n\n    // - implement CabalInterface\n\n    // - open-source your Cabal on Etherscan or equivalent\n\n    function registerCabal(CabalInterface _cabal)\n\n    external {\n\n        Account storage account = accounts[_cabal];\n\n        require(account.membership & (PENDING_CABAL | CABAL) == 0);\n\n        account.membership |= PENDING_CABAL;\n\n    }\n\n\n\n    function confirmCabal(CabalInterface _cabal)\n\n    external {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage account = accounts[_cabal];\n\n        require(account.membership & PENDING_CABAL != 0);\n\n        account.membership ^= (CABAL | PENDING_CABAL);\n\n        Cabal(_cabal);\n\n    }\n\n\n\n    function register()\n\n    external payable\n\n    {\n\n        require(msg.value == registrationDeposit);\n\n        Account storage account = accounts[msg.sender];\n\n        require(account.membership & VOTER == 0);\n\n        account.lastAccess = now;\n\n        account.membership |= VOTER;\n\n        token.grant(msg.sender, 40);\n\n        Voter(msg.sender);\n\n    }\n\n\n\n    // smart contracts must implement the fallback function in order to deregister\n\n    function deregister()\n\n    external\n\n    {\n\n        Account storage account = accounts[msg.sender];\n\n        require(account.membership & VOTER != 0);\n\n        require(account.lastAccess + 7 days <= now);\n\n        account.membership ^= VOTER;\n\n        account.lastAccess = 0;\n\n        // the MANDATORY transfer keeps population() meaningful\n\n        msg.sender.transfer(registrationDeposit);\n\n        Deregistered(msg.sender);\n\n    }\n\n\n\n    function population()\n\n    external view\n\n    returns (uint256)\n\n    {\n\n        return this.balance / 1 finney;\n\n    }\n\n\n\n    function deregistrationDate()\n\n    external view\n\n    returns (uint256)\n\n    {\n\n        return accounts[msg.sender].lastAccess + 7 days;\n\n    }\n\n\n\n    // always true for deregistered accounts\n\n    function canDeregister(address _voter)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_voter].lastAccess + 7 days <= now;\n\n    }\n\n\n\n    function canVoteOnProposal(address _voter, address _proposal)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_voter].membership & VOTER != 0\n\n            && accounts[_proposal].membership & PROPOSAL != 0;\n\n    }\n\n\n\n    function canVote(address _voter)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_voter].membership & VOTER != 0;\n\n    }\n\n\n\n    function isProposal(address _proposal)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_proposal].membership & PROPOSAL != 0;\n\n    }\n\n\n\n    function isPendingProposal(address _proposal)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_proposal].membership & PENDING_PROPOSAL != 0;\n\n    }\n\n\n\n    function isPendingCabal(address _account)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_account].membership & PENDING_CABAL != 0;\n\n    }\n\n\n\n    function isCabal(address _account)\n\n    external view\n\n    returns (bool)\n\n    {\n\n        return accounts[_account].membership & CABAL != 0;\n\n    }\n\n\n\n    // under no condition should you let anyone control two BOARD accounts\n\n    function appoint(address _board, string _vouch)\n\n    external {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage candidate = accounts[_board];\n\n        if (candidate.membership & BOARD != 0) {\n\n            return;\n\n        }\n\n        address appt = candidate.appointer;\n\n        if (accounts[appt].membership & BOARD == 0) {\n\n            candidate.appointer = msg.sender;\n\n            Nominated(_board, _vouch);\n\n            return;\n\n        }\n\n        if (appt == msg.sender) {\n\n            return;\n\n        }\n\n        Nominated(_board, _vouch);\n\n        candidate.membership |= BOARD;\n\n        Board(_board);\n\n    }\n\n\n\n    function denounce(address _board, string _reason)\n\n    external {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage board = accounts[_board];\n\n        if (board.membership & BOARD == 0) {\n\n            return;\n\n        }\n\n        address dncr = board.denouncer;\n\n        if (accounts[dncr].membership & BOARD == 0) {\n\n            board.denouncer = msg.sender;\n\n            Denounced(_board, _reason);\n\n            return;\n\n        }\n\n        if (dncr == msg.sender) {\n\n            return;\n\n        }\n\n        Denounced(_board, _reason);\n\n        board.membership ^= BOARD;\n\n        Revoked(_board);\n\n    }\n\n\n\n    function vouchProposer(address _proposer, string _vouch)\n\n    external {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage candidate = accounts[_proposer];\n\n        if (candidate.membership & PROPOSER != 0) {\n\n            return;\n\n        }\n\n        address appt = candidate.voucher;\n\n        if (accounts[appt].membership & BOARD == 0) {\n\n            candidate.voucher = msg.sender;\n\n            Vouch(_proposer, _vouch);\n\n            return;\n\n        }\n\n        if (appt == msg.sender) {\n\n            return;\n\n        }\n\n        Vouch(_proposer, _vouch);\n\n        candidate.membership |= PROPOSER;\n\n        Proposer(_proposer);\n\n    }\n\n\n\n    function devouchProposer(address _proposer, string _devouch)\n\n    external {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage candidate = accounts[_proposer];\n\n        if (candidate.membership & PROPOSER == 0) {\n\n            return;\n\n        }\n\n        address appt = candidate.devoucher;\n\n        if (accounts[appt].membership & BOARD == 0) {\n\n            candidate.devoucher = msg.sender;\n\n            Devouch(_proposer, _devouch);\n\n            return;\n\n        }\n\n        if (appt == msg.sender) {\n\n            return;\n\n        }\n\n        Devouch(_proposer, _devouch);\n\n        candidate.membership &= ~PROPOSER;\n\n        Shutdown(_proposer);\n\n    }\n\n\n\n    function proposeProper(bytes _resolution)\n\n    external\n\n    returns (ProposalInterface)\n\n    {\n\n        ProperProposal proposal = new ProperProposal();\n\n        proposal.init(msg.sender, _resolution);\n\n        accounts[proposal].membership |= PROPOSAL;\n\n        Proposal(proposal);\n\n        return proposal;\n\n    }\n\n\n\n    function proposeProxy(bytes _resolution)\n\n    external\n\n    returns (ProposalInterface)\n\n    {\n\n        ProperProposal proposal;\n\n        bytes memory clone = hex\"600034603b57602f80600f833981f3600036818037808036816f5fbe2cc9b1b684ec445caf176042348e5af415602c573d81803e3d81f35b80fd\";\n\n        assembly {\n\n            let data := add(clone, 0x20)\n\n            proposal := create(0, data, 58)\n\n        }\n\n        proposal.init(msg.sender, _resolution);\n\n        accounts[proposal].membership |= PROPOSAL;\n\n        Proposal(proposal);\n\n        return proposal;\n\n    }\n\n\n\n    function sudoPropose(ProposalInterface _proposal)\n\n    external {\n\n        require(accounts[msg.sender].membership & PROPOSER != 0);\n\n        uint8 membership = accounts[_proposal].membership;\n\n        require(membership == 0);\n\n        accounts[_proposal].membership = PROPOSAL;\n\n        Proposal(_proposal);\n\n    }\n\n\n\n    // To submit an outside proposal contract, you must:\n\n    // - ensure it conforms to ProposalInterface\n\n    // - ensure it properly transfers the VOTE token, calling Vote.voteX\n\n    // - open-source it using Etherscan or equivalent\n\n    function proposeExternal(ProposalInterface _proposal)\n\n    external\n\n    {\n\n        Account storage account = accounts[_proposal];\n\n        require(account.membership & (PENDING_PROPOSAL | PROPOSAL) == 0);\n\n        account.membership |= PENDING_PROPOSAL;\n\n    }\n\n\n\n    function confirmProposal(ProposalInterface _proposal)\n\n    external\n\n    {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage account = accounts[_proposal];\n\n        require(account.membership & PENDING_PROPOSAL != 0);\n\n        account.membership ^= (PROPOSAL | PENDING_PROPOSAL);\n\n        Proposal(_proposal);\n\n    }\n\n\n\n    // bans prevent accounts from voting through this proposal\n\n    // this should only be used to stop a proposal that is abusing the VOTE token\n\n    // the burn is to penalize bans, so that they cannot suppress ideas\n\n    function banProposal(ProposalInterface _proposal, string _reason)\n\n    external payable\n\n    {\n\n        require(msg.value == proposalCensorshipFee);\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage account = accounts[_proposal];\n\n        require(account.membership & PROPOSAL != 0);\n\n        account.membership &= ~PROPOSAL;\n\n        burn.transfer(proposalCensorshipFee);\n\n        BannedProposal(_proposal, _reason);\n\n    }\n\n\n\n    // board members reserve the right to reject outside proposals for any reason\n\n    function rejectProposal(ProposalInterface _proposal)\n\n    external\n\n    {\n\n        require(accounts[msg.sender].membership & BOARD != 0);\n\n        Account storage account = accounts[_proposal];\n\n        require(account.membership & PENDING_PROPOSAL != 0);\n\n        account.membership &= PENDING_PROPOSAL;\n\n    }\n\n\n\n    // this code lives here instead of in the token so that it can be upgraded with account registry migration\n\n    function faucet()\n\n    external {\n\n        Account storage account = accounts[msg.sender];\n\n        require(account.membership & VOTER != 0);\n\n        uint256 lastAccess = account.lastAccess;\n\n        uint256 grant = (now - lastAccess) / 72 minutes;\n\n        if (grant > 40) {\n\n            grant = 40;\n\n            account.lastAccess = now;\n\n        } else {\n\n            account.lastAccess = lastAccess + grant * 72 minutes;\n\n        }\n\n        token.grant(msg.sender, grant);\n\n    }\n\n\n\n    function availableFaucet(address _account)\n\n    external view\n\n    returns (uint256) {\n\n        uint256 grant = (now - accounts[_account].lastAccess) / 72 minutes;\n\n        if (grant > 40) {\n\n            grant = 40;\n\n        }\n\n        return grant;\n\n    }\n\n}"
  },
  {
    "id": 5,
    "addr4sss": "0x00000000441378008ea67f4284a57932b1c000a5",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n// File: contracts/Proxy/Proxy.sol\n\n\n\n/**\n\n * @title Proxy\n\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n\n */\n\ncontract Proxy {\n\n    \n\n    /**\n\n    * @dev Tells the address of the implementation where every call will be delegated.\n\n    * @return address of the implementation to which it will be delegated\n\n    */\n\n    function implementation() public view returns (address);\n\n\n\n    /**\n\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n\n    * This function will return whatever the implementation call returns\n\n    */\n\n    function() external payable {\n\n        address _impl = implementation();\n\n        \n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            let size := returndatasize\n\n            returndatacopy(ptr, 0, size)\n\n\n\n            switch result\n\n            case 0 { revert(ptr, size) }\n\n            default { return(ptr, size) }\n\n        }\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/UpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title UpgradeabilityProxy\n\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n\n */\n\ncontract UpgradeabilityProxy is Proxy {\n\n    /**\n\n    * @dev This event will be emitted every time the implementation gets upgraded\n\n    * @param implementation representing the address of the upgraded implementation\n\n    */\n\n    event Upgraded(address indexed implementation);\n\n\n\n    // Storage position of the address of the current implementation\n\n    bytes32 private constant implementationPosition = keccak256(\"trueGBP.proxy.implementation\");\n\n\n\n    /**\n\n    * @dev Tells the address of the current implementation\n\n    * @return address of the current implementation\n\n    */\n\n    function implementation() public view returns (address impl) {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          impl := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the current implementation\n\n    * @param newImplementation address representing the new implementation to be set\n\n    */\n\n    function _setImplementation(address newImplementation) internal {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          sstore(position, newImplementation)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Upgrades the implementation address\n\n    * @param newImplementation representing the address of the new implementation to be set\n\n    */\n\n    function _upgradeTo(address newImplementation) internal {\n\n        address currentImplementation = implementation();\n\n        require(currentImplementation != newImplementation);\n\n        _setImplementation(newImplementation);\n\n        emit Upgraded(newImplementation);\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title OwnedUpgradeabilityProxy\n\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n\n */\n\ncontract TrueGBP is UpgradeabilityProxy {\n\n    /**\n\n    * @dev Event to show ownership has been transferred\n\n    * @param previousOwner representing the address of the previous owner\n\n    * @param newOwner representing the address of the new owner\n\n    */\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev Event to show ownership transfer is pending\n\n    * @param currentOwner representing the address of the current owner\n\n    * @param pendingOwner representing the address of the pending owner\n\n    */\n\n    event NewPendingOwner(address currentOwner, address pendingOwner);\n\n    \n\n    // Storage position of the owner and pendingOwner of the contract\n\n    bytes32 private constant proxyOwnerPosition = keccak256(\"trueGBP.proxy.owner\");\n\n    bytes32 private constant pendingProxyOwnerPosition = keccak256(\"trueGBP.pending.proxy.owner\");\n\n\n\n    /**\n\n    * @dev the constructor sets the original owner of the contract to the sender account.\n\n    */\n\n    constructor() public {\n\n        _setUpgradeabilityOwner(msg.sender);\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyProxyOwner() {\n\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the pending owner.\n\n    */\n\n    modifier onlyPendingProxyOwner() {\n\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function proxyOwner() public view returns (address owner) {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            owner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function pendingProxyOwner() public view returns (address pendingOwner) {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            pendingOwner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newPendingProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    *changes the pending owner to newOwner. But doesn't actually transfer\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        _setPendingUpgradeabilityOwner(newOwner);\n\n        emit NewPendingOwner(proxyOwner(), newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the pendingOwner to claim ownership of the proxy\n\n    */\n\n    function claimProxyOwnership() external onlyPendingProxyOwner {\n\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n\n        _setUpgradeabilityOwner(pendingProxyOwner());\n\n        _setPendingUpgradeabilityOwner(address(0));\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n\n    * @param implementation representing the address of the new implementation to be set.\n\n    */\n\n    function upgradeTo(address implementation) external onlyProxyOwner {\n\n        _upgradeTo(implementation);\n\n    }\n\n}"
  },
  {
    "id": 6,
    "addr4sss": "0x00000000bbcf7700a1b403c9eb666f350707b900",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n// File: contracts/Proxy/Proxy.sol\n\n\n\n/**\n\n * @title Proxy\n\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n\n */\n\ncontract Proxy {\n\n    \n\n    /**\n\n    * @dev Tells the address of the implementation where every call will be delegated.\n\n    * @return address of the implementation to which it will be delegated\n\n    */\n\n    function implementation() public view returns (address);\n\n\n\n    /**\n\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n\n    * This function will return whatever the implementation call returns\n\n    */\n\n    function() external payable {\n\n        address _impl = implementation();\n\n        \n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            let size := returndatasize\n\n            returndatacopy(ptr, 0, size)\n\n\n\n            switch result\n\n            case 0 { revert(ptr, size) }\n\n            default { return(ptr, size) }\n\n        }\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/UpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title UpgradeabilityProxy\n\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n\n */\n\ncontract UpgradeabilityProxy is Proxy {\n\n    /**\n\n    * @dev This event will be emitted every time the implementation gets upgraded\n\n    * @param implementation representing the address of the upgraded implementation\n\n    */\n\n    event Upgraded(address indexed implementation);\n\n\n\n    // Storage position of the address of the current implementation\n\n    bytes32 private constant implementationPosition = 0xdc8e328a3c0acffa7969856957539d0f8c2deaa0d39abaf20397a9fa3b45bf17; //keccak256(\"trueGBP.proxy.implementation\");\n\n\n\n    /**\n\n    * @dev Tells the address of the current implementation\n\n    * @return address of the current implementation\n\n    */\n\n    function implementation() public view returns (address impl) {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          impl := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the current implementation\n\n    * @param newImplementation address representing the new implementation to be set\n\n    */\n\n    function _setImplementation(address newImplementation) internal {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n          sstore(position, newImplementation)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Upgrades the implementation address\n\n    * @param newImplementation representing the address of the new implementation to be set\n\n    */\n\n    function _upgradeTo(address newImplementation) internal {\n\n        address currentImplementation = implementation();\n\n        require(currentImplementation != newImplementation);\n\n        _setImplementation(newImplementation);\n\n        emit Upgraded(newImplementation);\n\n    }\n\n}\n\n\n\n// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title OwnedUpgradeabilityProxy\n\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n\n */\n\ncontract TGBPController is UpgradeabilityProxy {\n\n    /**\n\n    * @dev Event to show ownership has been transferred\n\n    * @param previousOwner representing the address of the previous owner\n\n    * @param newOwner representing the address of the new owner\n\n    */\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev Event to show ownership transfer is pending\n\n    * @param currentOwner representing the address of the current owner\n\n    * @param pendingOwner representing the address of the pending owner\n\n    */\n\n    event NewPendingOwner(address currentOwner, address pendingOwner);\n\n    \n\n    // Storage position of the owner and pendingOwner of the contract\n\n    bytes32 private constant proxyOwnerPosition = 0x58709042d6c9a2b64c8e7802bfedabdcd2eaecc68e15ef2e896a5970c608cd16;//keccak256(\"trueGBP.proxy.owner\");\n\n    bytes32 private constant pendingProxyOwnerPosition = 0xa6933dbb41d1bc3d681619c11234027db3b75954220aa88dfdc74750053ed30c;//keccak256(\"trueGBP.pending.proxy.owner\");\n\n\n\n    /**\n\n    * @dev the constructor sets the original owner of the contract to the sender account.\n\n    */\n\n    constructor() public {\n\n        _setUpgradeabilityOwner(msg.sender);\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyProxyOwner() {\n\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the pending owner.\n\n    */\n\n    modifier onlyPendingProxyOwner() {\n\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function proxyOwner() public view returns (address owner) {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            owner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function pendingProxyOwner() public view returns (address pendingOwner) {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            pendingOwner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newPendingProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    *changes the pending owner to newOwner. But doesn't actually transfer\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        _setPendingUpgradeabilityOwner(newOwner);\n\n        emit NewPendingOwner(proxyOwner(), newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the pendingOwner to claim ownership of the proxy\n\n    */\n\n    function claimProxyOwnership() external onlyPendingProxyOwner {\n\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n\n        _setUpgradeabilityOwner(pendingProxyOwner());\n\n        _setPendingUpgradeabilityOwner(address(0));\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n\n    * @param implementation representing the address of the new implementation to be set.\n\n    */\n\n    function upgradeTo(address implementation) external onlyProxyOwner {\n\n        _upgradeTo(implementation);\n\n    }\n\n}"
  },
  {
    "id": 7,
    "addr4sss": "0x00000000e86b5156e8fd624255bf7a6d722a8f1f",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\ninterface TokenReceiver {\n\n  function tokenFallback(address from, uint256 qty, bytes data) external;\n\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\n\n}\n\n\n\nlibrary SafeMath {\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    require(b <= a);\n\n    return a - b;\n\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    require(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract ARIYAX {\n\n  using SafeMath for uint256;\n\n  mapping (address => uint256) public balanceOf;\n\n  mapping (address => mapping (address => uint256)) public allowance;\n\n  uint256 public decimals = 18;\n\n  string public name = \"ARIYAX\";\n\n  string public symbol = \"ARYX\";\n\n  uint256 public totalSupply = 1000000000e18;\n\n  event Transfer(address indexed from, address indexed to, uint256 qty);\n\n  event Approval(address indexed from, address indexed spender, uint256 qty);\n\n  constructor() public {\n\n    balanceOf[msg.sender] = totalSupply;\n\n  }\n\n  function isContract(address target) internal view returns (bool) {\n\n    uint256 codeLength;\n\n    assembly {\n\n      codeLength := extcodesize(target)\n\n    }\n\n    return codeLength > 0;\n\n  }\n\n  function transfer(address target, uint256 qty, bytes data) public returns (bool) {\n\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(qty);\n\n    balanceOf[target] = balanceOf[target].add(qty);\n\n    if (isContract(target)) {\n\n      TokenReceiver(target).tokenFallback(target, qty, data);\n\n    }\n\n    emit Transfer(msg.sender, target, qty);\n\n    return true;\n\n  }\n\n  function transfer(address target, uint256 qty) external returns (bool) {\n\n    return transfer(target, qty, \"\");\n\n  }\n\n  function transferFrom(address from, address to, uint256 qty) external returns (bool) {\n\n    allowance[from][msg.sender] = allowance[from][msg.sender].sub(qty);\n\n    balanceOf[from] = balanceOf[from].sub(qty);\n\n    balanceOf[to] = balanceOf[to].add(qty);\n\n    emit Transfer(from, to, qty);\n\n    return true;\n\n  }\n\n  function approve(address spender, uint256 qty) public returns (bool) {\n\n    allowance[msg.sender][spender] = qty;\n\n    emit Approval(msg.sender, spender, qty);\n\n    return true;\n\n  }\n\n  function approveAndCall(address spender, uint256 qty, bytes data) external returns (bool) {\n\n    require(approve(spender, qty));\n\n    TokenReceiver(spender).receiveApproval(msg.sender, qty, this, data);\n\n    return true;\n\n  }\n\n}"
  },
  {
    "id": 8,
    "addr4sss": "0x0000009a317684a5f840484357fa587aca76454c",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\ncontract DelegateERC20 {\n\n  function delegateTotalSupply() public view returns (uint256);\n\n  function delegateBalanceOf(address who) public view returns (uint256);\n\n  function delegateTransfer(address to, uint256 value, address origSender) public returns (bool);\n\n  function delegateAllowance(address owner, address spender) public view returns (uint256);\n\n  function delegateTransferFrom(address from, address to, uint256 value, address origSender) public returns (bool);\n\n  function delegateApprove(address spender, uint256 value, address origSender) public returns (bool);\n\n  function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public returns (bool);\n\n  function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public returns (bool);\n\n}\n\n\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    Unpause();\n\n  }\n\n}\n\n\n\ncontract CanReclaimToken is Ownable {\n\n  using SafeERC20 for ERC20Basic;\n\n\n\n  /**\n\n   * @dev Reclaim all ERC20Basic compatible tokens\n\n   * @param token ERC20Basic The address of the token contract\n\n   */\n\n  function reclaimToken(ERC20Basic token) external onlyOwner {\n\n    uint256 balance = token.balanceOf(this);\n\n    token.safeTransfer(owner, balance);\n\n  }\n\n\n\n}\n\n\n\ncontract Claimable is Ownable {\n\n  address public pendingOwner;\n\n\n\n  /**\n\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n\n   */\n\n  modifier onlyPendingOwner() {\n\n    require(msg.sender == pendingOwner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to set the pendingOwner address.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner public {\n\n    pendingOwner = newOwner;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the pendingOwner address to finalize the transfer.\n\n   */\n\n  function claimOwnership() onlyPendingOwner public {\n\n    OwnershipTransferred(owner, pendingOwner);\n\n    owner = pendingOwner;\n\n    pendingOwner = address(0);\n\n  }\n\n}\n\n\n\ncontract AddressList is Claimable {\n\n    string public name;\n\n    mapping (address => bool) public onList;\n\n\n\n    function AddressList(string _name, bool nullValue) public {\n\n        name = _name;\n\n        onList[0x0] = nullValue;\n\n    }\n\n    event ChangeWhiteList(address indexed to, bool onList);\n\n\n\n    // Set whether _to is on the list or not. Whether 0x0 is on the list\n\n    // or not cannot be set here - it is set once and for all by the constructor.\n\n    function changeList(address _to, bool _onList) onlyOwner public {\n\n        require(_to != 0x0);\n\n        if (onList[_to] != _onList) {\n\n            onList[_to] = _onList;\n\n            ChangeWhiteList(_to, _onList);\n\n        }\n\n    }\n\n}\n\n\n\ncontract NamableAddressList is AddressList {\n\n    function NamableAddressList(string _name, bool nullValue)\n\n        AddressList(_name, nullValue) public {}\n\n\n\n    function changeName(string _name) onlyOwner public {\n\n        name = _name;\n\n    }\n\n}\n\n\n\ncontract HasNoContracts is Ownable {\n\n\n\n  /**\n\n   * @dev Reclaim ownership of Ownable contracts\n\n   * @param contractAddr The address of the Ownable to be reclaimed.\n\n   */\n\n  function reclaimContract(address contractAddr) external onlyOwner {\n\n    Ownable contractInst = Ownable(contractAddr);\n\n    contractInst.transferOwnership(owner);\n\n  }\n\n}\n\n\n\ncontract HasNoEther is Ownable {\n\n\n\n  /**\n\n  * @dev Constructor that rejects incoming Ether\n\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n\n  * we could use assembly to access msg.value.\n\n  */\n\n  function HasNoEther() public payable {\n\n    require(msg.value == 0);\n\n  }\n\n\n\n  /**\n\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\n\n   */\n\n  function() external {\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer all Ether held by the contract to the owner.\n\n   */\n\n  function reclaimEther() external onlyOwner {\n\n    assert(owner.send(this.balance));\n\n  }\n\n}\n\n\n\ncontract HasNoTokens is CanReclaimToken {\n\n\n\n /**\n\n  * @dev Reject all ERC223 compatible tokens\n\n  * @param from_ address The address that is transferring the tokens\n\n  * @param value_ uint256 the amount of the specified token\n\n  * @param data_ Bytes The data passed from the caller.\n\n  */\n\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n\n    from_;\n\n    value_;\n\n    data_;\n\n    revert();\n\n  }\n\n\n\n}\n\n\n\ncontract TimeLockedController is HasNoEther, HasNoTokens, Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    // 12 hours, assuming a 15 second blocktime.\n\n    // As long as this isn't too far off from reality it doesn't really matter.\n\n    uint public constant blocksDelay = 12*60*60/15;\n\n\n\n    struct MintOperation {\n\n        address to;\n\n        uint256 amount;\n\n        address admin;\n\n        uint deferBlock;\n\n    }\n\n\n\n    address public admin;\n\n    TrueUSD public trueUSD;\n\n    MintOperation[] public mintOperations;\n\n\n\n    modifier onlyAdminOrOwner() {\n\n        require(msg.sender == admin || msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    event MintOperationEvent(address indexed _to, uint256 amount, uint deferBlock, uint opIndex);\n\n    event TransferChildEvent(address indexed _child, address indexed _newOwner);\n\n    event ReclaimEvent(address indexed other);\n\n    event ChangeBurnBoundsEvent(uint newMin, uint newMax);\n\n    event ChangeStakingFeesEvent(uint80 _transferFeeNumerator,\n\n                                            uint80 _transferFeeDenominator,\n\n                                            uint80 _mintFeeNumerator,\n\n                                            uint80 _mintFeeDenominator,\n\n                                            uint256 _mintFeeFlat,\n\n                                            uint80 _burnFeeNumerator,\n\n                                            uint80 _burnFeeDenominator,\n\n                                            uint256 _burnFeeFlat);\n\n    event ChangeStakerEvent(address newStaker);\n\n    event DelegateEvent(DelegateERC20 delegate);\n\n    event SetDelegatedFromEvent(address source);\n\n    event ChangeTrueUSDEvent(TrueUSD newContract);\n\n    event ChangeNameEvent(string name, string symbol);\n\n    event AdminshipTransferred(address indexed previousAdmin, address indexed newAdmin);\n\n\n\n    // admin initiates a request to mint _amount TrueUSD for account _to\n\n    function requestMint(address _to, uint256 _amount) public onlyAdminOrOwner {\n\n        uint deferBlock = block.number;\n\n        if (msg.sender != owner) {\n\n            deferBlock = deferBlock.add(blocksDelay);\n\n        }\n\n        MintOperation memory op = MintOperation(_to, _amount, admin, deferBlock);\n\n        MintOperationEvent(_to, _amount, deferBlock, mintOperations.length);\n\n        mintOperations.push(op);\n\n    }\n\n\n\n    // after a day, admin finalizes mint request by providing the\n\n    // index of the request (visible in the MintOperationEvent accompanying the original request)\n\n    function finalizeMint(uint index) public onlyAdminOrOwner {\n\n        MintOperation memory op = mintOperations[index];\n\n        require(op.admin == admin); //checks that the requester's adminship has not been revoked\n\n        require(op.deferBlock <= block.number); //checks that enough time has elapsed\n\n        address to = op.to;\n\n        uint256 amount = op.amount;\n\n        delete mintOperations[index];\n\n        trueUSD.mint(to, amount);\n\n    }\n\n\n\n    // Transfer ownership of _child to _newOwner\n\n    // Can be used e.g. to upgrade this TimeLockedController contract.\n\n    function transferChild(Ownable _child, address _newOwner) public onlyOwner {\n\n        TransferChildEvent(_child, _newOwner);\n\n        _child.transferOwnership(_newOwner);\n\n    }\n\n\n\n    // Transfer ownership of a contract from trueUSD\n\n    // to this TimeLockedController. Can be used e.g. to reclaim balance sheet\n\n    // in order to transfer it to an upgraded TrueUSD contract.\n\n    function requestReclaim(Ownable other) public onlyOwner {\n\n        ReclaimEvent(other);\n\n        trueUSD.reclaimContract(other);\n\n    }\n\n\n\n    // Change the minimum and maximum amounts that TrueUSD users can\n\n    // burn to newMin and newMax\n\n    function changeBurnBounds(uint newMin, uint newMax) public onlyOwner {\n\n        ChangeBurnBoundsEvent(newMin, newMax);\n\n        trueUSD.changeBurnBounds(newMin, newMax);\n\n    }\n\n\n\n    // Change the transaction fees charged on transfer/mint/burn\n\n    function changeStakingFees(uint80 _transferFeeNumerator,\n\n                               uint80 _transferFeeDenominator,\n\n                               uint80 _mintFeeNumerator,\n\n                               uint80 _mintFeeDenominator,\n\n                               uint256 _mintFeeFlat,\n\n                               uint80 _burnFeeNumerator,\n\n                               uint80 _burnFeeDenominator,\n\n                               uint256 _burnFeeFlat) public onlyOwner {\n\n        ChangeStakingFeesEvent(_transferFeeNumerator,\n\n                                          _transferFeeDenominator,\n\n                                          _mintFeeNumerator,\n\n                                          _mintFeeDenominator,\n\n                                          _mintFeeFlat,\n\n                                          _burnFeeNumerator,\n\n                                          _burnFeeDenominator,\n\n                                          _burnFeeFlat);\n\n        trueUSD.changeStakingFees(_transferFeeNumerator,\n\n                                  _transferFeeDenominator,\n\n                                  _mintFeeNumerator,\n\n                                  _mintFeeDenominator,\n\n                                  _mintFeeFlat,\n\n                                  _burnFeeNumerator,\n\n                                  _burnFeeDenominator,\n\n                                  _burnFeeFlat);\n\n    }\n\n\n\n    // Change the recipient of staking fees to newStaker\n\n    function changeStaker(address newStaker) public onlyOwner {\n\n        ChangeStakerEvent(newStaker);\n\n        trueUSD.changeStaker(newStaker);\n\n    }\n\n\n\n    // Future ERC20 calls to trueUSD be delegated to _delegate\n\n    function delegateToNewContract(DelegateERC20 delegate) public onlyOwner {\n\n        DelegateEvent(delegate);\n\n        trueUSD.delegateToNewContract(delegate);\n\n    }\n\n\n\n    // Incoming delegate* calls from _source will be accepted by trueUSD\n\n    function setDelegatedFrom(address _source) public onlyOwner {\n\n        SetDelegatedFromEvent(_source);\n\n        trueUSD.setDelegatedFrom(_source);\n\n    }\n\n\n\n    // Update this contract's trueUSD pointer to newContract (e.g. if the\n\n    // contract is upgraded)\n\n    function setTrueUSD(TrueUSD newContract) public onlyOwner {\n\n        ChangeTrueUSDEvent(newContract);\n\n        trueUSD = newContract;\n\n    }\n\n\n\n    // change trueUSD's name and symbol\n\n    function changeName(string name, string symbol) public onlyOwner {\n\n        ChangeNameEvent(name, symbol);\n\n        trueUSD.changeName(name, symbol);\n\n    }\n\n\n\n    // Replace the current admin with newAdmin\n\n    function transferAdminship(address newAdmin) public onlyOwner {\n\n        AdminshipTransferred(admin, newAdmin);\n\n        admin = newAdmin;\n\n    }\n\n\n\n    // Swap out TrueUSD's address lists\n\n    function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) onlyOwner public {\n\n        trueUSD.setLists(_canReceiveMintWhiteList, _canBurnWhiteList, _blackList, _noFeesList);\n\n    }\n\n\n\n    // Update a whitelist/blacklist\n\n    function updateList(address list, address entry, bool flag) public onlyAdminOrOwner {\n\n        AddressList(list).changeList(entry, flag);\n\n    }\n\n\n\n    // Rename a whitelist/blacklist\n\n    function renameList(address list, string name) public onlyAdminOrOwner {\n\n        NamableAddressList(list).changeName(name);\n\n    }\n\n\n\n    // Claim ownership of an arbitrary Claimable contract\n\n    function issueClaimOwnership(address _other) public onlyAdminOrOwner {\n\n        Claimable other = Claimable(_other);\n\n        other.claimOwnership();\n\n    }\n\n}\n\n\n\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\n\n}\n\n\n\ncontract AllowanceSheet is Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => mapping (address => uint256)) public allowanceOf;\n\n\n\n    function addAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = allowanceOf[tokenHolder][spender].add(value);\n\n    }\n\n\n\n    function subAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = allowanceOf[tokenHolder][spender].sub(value);\n\n    }\n\n\n\n    function setAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = value;\n\n    }\n\n}\n\n\n\ncontract BalanceSheet is Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) public balanceOf;\n\n\n\n    function addBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = balanceOf[addr].add(value);\n\n    }\n\n\n\n    function subBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = balanceOf[addr].sub(value);\n\n    }\n\n\n\n    function setBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = value;\n\n    }\n\n}\n\n\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract BasicToken is ERC20Basic, Claimable {\n\n  using SafeMath for uint256;\n\n\n\n  BalanceSheet public balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  function setBalanceSheet(address sheet) external onlyOwner {\n\n    balances = BalanceSheet(sheet);\n\n    balances.claimOwnership();\n\n  }\n\n\n\n  /**\n\n  * @dev total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    transferAllArgsNoAllowance(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal {\n\n    require(_to != address(0));\n\n    require(_from != address(0));\n\n    require(_value <= balances.balanceOf(_from));\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances.subBalance(_from, _value);\n\n    balances.addBalance(_to, _value);\n\n    Transfer(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances.balanceOf(_owner);\n\n  }\n\n}\n\n\n\ncontract BurnableToken is BasicToken {\n\n\n\n  event Burn(address indexed burner, uint256 value);\n\n\n\n  /**\n\n   * @dev Burns a specific amount of tokens.\n\n   * @param _value The amount of token to be burned.\n\n   */\n\n  function burn(uint256 _value) public {\n\n    require(_value <= balances.balanceOf(msg.sender));\n\n    // no need to require value <= totalSupply, since that would imply the\n\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n    address burner = msg.sender;\n\n    balances.subBalance(burner, _value);\n\n    totalSupply_ = totalSupply_.sub(_value);\n\n    Burn(burner, _value);\n\n    Transfer(burner, address(0), _value);\n\n  }\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\nlibrary SafeERC20 {\n\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n\n    assert(token.transfer(to, value));\n\n  }\n\n\n\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n\n    assert(token.transferFrom(from, to, value));\n\n  }\n\n\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n\n    assert(token.approve(spender, value));\n\n  }\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  AllowanceSheet public allowances;\n\n\n\n  function setAllowanceSheet(address sheet) external onlyOwner {\n\n    allowances = AllowanceSheet(sheet);\n\n    allowances.claimOwnership();\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    transferAllArgsYesAllowance(_from, _to, _value, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function transferAllArgsYesAllowance(address _from, address _to, uint256 _value, address spender) internal {\n\n    require(_value <= allowances.allowanceOf(_from, spender));\n\n\n\n    allowances.subAllowance(_from, spender, _value);\n\n    transferAllArgsNoAllowance(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    approveAllArgs(_spender, _value, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal {\n\n    allowances.setAllowance(_tokenHolder, _spender, _value);\n\n    Approval(_tokenHolder, _spender, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n\n    return allowances.allowanceOf(_owner, _spender);\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n    increaseApprovalAllArgs(_spender, _addedValue, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function increaseApprovalAllArgs(address _spender, uint _addedValue, address tokenHolder) internal {\n\n    allowances.addAllowance(tokenHolder, _spender, _addedValue);\n\n    Approval(tokenHolder, _spender, allowances.allowanceOf(tokenHolder, _spender));\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n    decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function decreaseApprovalAllArgs(address _spender, uint _subtractedValue, address tokenHolder) internal {\n\n    uint oldValue = allowances.allowanceOf(tokenHolder, _spender);\n\n    if (_subtractedValue > oldValue) {\n\n      allowances.setAllowance(tokenHolder, _spender, 0);\n\n    } else {\n\n      allowances.subAllowance(tokenHolder, _spender, _subtractedValue);\n\n    }\n\n    Approval(tokenHolder, _spender, allowances.allowanceOf(tokenHolder, _spender));\n\n  }\n\n\n\n}\n\n\n\ncontract CanDelegate is StandardToken {\n\n    // If this contract needs to be upgraded, the new contract will be stored\n\n    // in 'delegate' and any ERC20 calls to this contract will be delegated to that one.\n\n    DelegateERC20 public delegate;\n\n\n\n    event DelegatedTo(address indexed newContract);\n\n\n\n    // Can undelegate by passing in newContract = address(0)\n\n    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner {\n\n        delegate = newContract;\n\n        DelegatedTo(delegate);\n\n    }\n\n\n\n    // If a delegate has been designated, all ERC20 calls are forwarded to it\n\n    function transfer(address to, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.transfer(to, value);\n\n        } else {\n\n            return delegate.delegateTransfer(to, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.transferFrom(from, to, value);\n\n        } else {\n\n            return delegate.delegateTransferFrom(from, to, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function balanceOf(address who) public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.balanceOf(who);\n\n        } else {\n\n            return delegate.delegateBalanceOf(who);\n\n        }\n\n    }\n\n\n\n    function approve(address spender, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.approve(spender, value);\n\n        } else {\n\n            return delegate.delegateApprove(spender, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function allowance(address _owner, address spender) public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.allowance(_owner, spender);\n\n        } else {\n\n            return delegate.delegateAllowance(_owner, spender);\n\n        }\n\n    }\n\n\n\n    function totalSupply() public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.totalSupply();\n\n        } else {\n\n            return delegate.delegateTotalSupply();\n\n        }\n\n    }\n\n\n\n    function increaseApproval(address spender, uint addedValue) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.increaseApproval(spender, addedValue);\n\n        } else {\n\n            return delegate.delegateIncreaseApproval(spender, addedValue, msg.sender);\n\n        }\n\n    }\n\n\n\n    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.decreaseApproval(spender, subtractedValue);\n\n        } else {\n\n            return delegate.delegateDecreaseApproval(spender, subtractedValue, msg.sender);\n\n        }\n\n    }\n\n}\n\n\n\ncontract StandardDelegate is StandardToken, DelegateERC20 {\n\n    address public delegatedFrom;\n\n\n\n    modifier onlySender(address source) {\n\n        require(msg.sender == source);\n\n        _;\n\n    }\n\n\n\n    function setDelegatedFrom(address addr) onlyOwner public {\n\n        delegatedFrom = addr;\n\n    }\n\n\n\n    // All delegate ERC20 functions are forwarded to corresponding normal functions\n\n    function delegateTotalSupply() public view returns (uint256) {\n\n        return totalSupply();\n\n    }\n\n\n\n    function delegateBalanceOf(address who) public view returns (uint256) {\n\n        return balanceOf(who);\n\n    }\n\n\n\n    function delegateTransfer(address to, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        transferAllArgsNoAllowance(origSender, to, value);\n\n        return true;\n\n    }\n\n\n\n    function delegateAllowance(address owner, address spender) public view returns (uint256) {\n\n        return allowance(owner, spender);\n\n    }\n\n\n\n    function delegateTransferFrom(address from, address to, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        transferAllArgsYesAllowance(from, to, value, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateApprove(address spender, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        approveAllArgs(spender, value, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateIncreaseApproval(address spender, uint addedValue, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        increaseApprovalAllArgs(spender, addedValue, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        decreaseApprovalAllArgs(spender, subtractedValue, origSender);\n\n        return true;\n\n    }\n\n}\n\n\n\ncontract PausableToken is StandardToken, Pausable {\n\n\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.transfer(_to, _value);\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.transferFrom(_from, _to, _value);\n\n  }\n\n\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.approve(_spender, _value);\n\n  }\n\n\n\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n\n    return super.increaseApproval(_spender, _addedValue);\n\n  }\n\n\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n\n    return super.decreaseApproval(_spender, _subtractedValue);\n\n  }\n\n}\n\n\n\ncontract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate {\n\n    string public name = \"TrueUSD\";\n\n    string public symbol = \"TUSD\";\n\n    uint8 public constant decimals = 18;\n\n\n\n    AddressList public canReceiveMintWhiteList;\n\n    AddressList public canBurnWhiteList;\n\n    AddressList public blackList;\n\n    AddressList public noFeesList;\n\n    uint256 public burnMin = 10000 * 10**uint256(decimals);\n\n    uint256 public burnMax = 20000000 * 10**uint256(decimals);\n\n\n\n    uint80 public transferFeeNumerator = 7;\n\n    uint80 public transferFeeDenominator = 10000;\n\n    uint80 public mintFeeNumerator = 0;\n\n    uint80 public mintFeeDenominator = 10000;\n\n    uint256 public mintFeeFlat = 0;\n\n    uint80 public burnFeeNumerator = 0;\n\n    uint80 public burnFeeDenominator = 10000;\n\n    uint256 public burnFeeFlat = 0;\n\n    address public staker;\n\n\n\n    event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax);\n\n    event Mint(address indexed to, uint256 amount);\n\n    event WipedAccount(address indexed account, uint256 balance);\n\n\n\n    function TrueUSD() public {\n\n        totalSupply_ = 0;\n\n        staker = msg.sender;\n\n    }\n\n\n\n    function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) onlyOwner public {\n\n        canReceiveMintWhiteList = _canReceiveMintWhiteList;\n\n        canBurnWhiteList = _canBurnWhiteList;\n\n        blackList = _blackList;\n\n        noFeesList = _noFeesList;\n\n    }\n\n\n\n    function changeName(string _name, string _symbol) onlyOwner public {\n\n        name = _name;\n\n        symbol = _symbol;\n\n    }\n\n\n\n    //Burning functions as withdrawing money from the system. The platform will keep track of who burns coins,\n\n    //and will send them back the equivalent amount of money (rounded down to the nearest cent).\n\n    function burn(uint256 _value) public {\n\n        require(canBurnWhiteList.onList(msg.sender));\n\n        require(_value >= burnMin);\n\n        require(_value <= burnMax);\n\n        uint256 fee = payStakingFee(msg.sender, _value, burnFeeNumerator, burnFeeDenominator, burnFeeFlat, 0x0);\n\n        uint256 remaining = _value.sub(fee);\n\n        super.burn(remaining);\n\n    }\n\n\n\n    //Create _amount new tokens and transfer them to _to.\n\n    //Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/MintableToken.sol\n\n    function mint(address _to, uint256 _amount) onlyOwner public {\n\n        require(canReceiveMintWhiteList.onList(_to));\n\n        totalSupply_ = totalSupply_.add(_amount);\n\n        balances.addBalance(_to, _amount);\n\n        Mint(_to, _amount);\n\n        Transfer(address(0), _to, _amount);\n\n        payStakingFee(_to, _amount, mintFeeNumerator, mintFeeDenominator, mintFeeFlat, 0x0);\n\n    }\n\n\n\n    //Change the minimum and maximum amount that can be burned at once. Burning\n\n    //may be disabled by setting both to 0 (this will not be done under normal\n\n    //operation, but we can't add checks to disallow it without losing a lot of\n\n    //flexibility since burning could also be as good as disabled\n\n    //by setting the minimum extremely high, and we don't want to lock\n\n    //in any particular cap for the minimum)\n\n    function changeBurnBounds(uint newMin, uint newMax) onlyOwner public {\n\n        require(newMin <= newMax);\n\n        burnMin = newMin;\n\n        burnMax = newMax;\n\n        ChangeBurnBoundsEvent(newMin, newMax);\n\n    }\n\n\n\n    // transfer and transferFrom are both dispatched to this function, so we\n\n    // check blacklist and pay staking fee here.\n\n    function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal {\n\n        require(!blackList.onList(_from));\n\n        require(!blackList.onList(_to));\n\n        super.transferAllArgsNoAllowance(_from, _to, _value);\n\n        payStakingFee(_to, _value, transferFeeNumerator, transferFeeDenominator, 0, _from);\n\n    }\n\n\n\n    function wipeBlacklistedAccount(address account) public onlyOwner {\n\n        require(blackList.onList(account));\n\n        uint256 oldValue = balanceOf(account);\n\n        balances.setBalance(account, 0);\n\n        totalSupply_ = totalSupply_.sub(oldValue);\n\n        WipedAccount(account, oldValue);\n\n    }\n\n\n\n    function payStakingFee(address payer, uint256 value, uint80 numerator, uint80 denominator, uint256 flatRate, address otherParticipant) private returns (uint256) {\n\n        if (noFeesList.onList(payer) || noFeesList.onList(otherParticipant)) {\n\n            return 0;\n\n        }\n\n        uint256 stakingFee = value.mul(numerator).div(denominator).add(flatRate);\n\n        if (stakingFee > 0) {\n\n            super.transferAllArgsNoAllowance(payer, staker, stakingFee);\n\n        }\n\n        return stakingFee;\n\n    }\n\n\n\n    function changeStakingFees(uint80 _transferFeeNumerator,\n\n                                 uint80 _transferFeeDenominator,\n\n                                 uint80 _mintFeeNumerator,\n\n                                 uint80 _mintFeeDenominator,\n\n                                 uint256 _mintFeeFlat,\n\n                                 uint80 _burnFeeNumerator,\n\n                                 uint80 _burnFeeDenominator,\n\n                                 uint256 _burnFeeFlat) public onlyOwner {\n\n        require(_transferFeeDenominator != 0);\n\n        require(_mintFeeDenominator != 0);\n\n        require(_burnFeeDenominator != 0);\n\n        transferFeeNumerator = _transferFeeNumerator;\n\n        transferFeeDenominator = _transferFeeDenominator;\n\n        mintFeeNumerator = _mintFeeNumerator;\n\n        mintFeeDenominator = _mintFeeDenominator;\n\n        mintFeeFlat = _mintFeeFlat;\n\n        burnFeeNumerator = _burnFeeNumerator;\n\n        burnFeeDenominator = _burnFeeDenominator;\n\n        burnFeeFlat = _burnFeeFlat;\n\n    }\n\n\n\n    function changeStaker(address newStaker) public onlyOwner {\n\n        require(newStaker != address(0));\n\n        staker = newStaker;\n\n    }\n\n}"
  },
  {
    "id": 9,
    "addr4sss": "0x000000c96e715a5b8cd3beaea66bdb749225fa2f",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\ncontract DelegateERC20 {\n\n  function delegateTotalSupply() public view returns (uint256);\n\n  function delegateBalanceOf(address who) public view returns (uint256);\n\n  function delegateTransfer(address to, uint256 value, address origSender) public returns (bool);\n\n  function delegateAllowance(address owner, address spender) public view returns (uint256);\n\n  function delegateTransferFrom(address from, address to, uint256 value, address origSender) public returns (bool);\n\n  function delegateApprove(address spender, uint256 value, address origSender) public returns (bool);\n\n  function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public returns (bool);\n\n  function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public returns (bool);\n\n}\n\n\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    Unpause();\n\n  }\n\n}\n\n\n\ncontract CanReclaimToken is Ownable {\n\n  using SafeERC20 for ERC20Basic;\n\n\n\n  /**\n\n   * @dev Reclaim all ERC20Basic compatible tokens\n\n   * @param token ERC20Basic The address of the token contract\n\n   */\n\n  function reclaimToken(ERC20Basic token) external onlyOwner {\n\n    uint256 balance = token.balanceOf(this);\n\n    token.safeTransfer(owner, balance);\n\n  }\n\n\n\n}\n\n\n\ncontract Claimable is Ownable {\n\n  address public pendingOwner;\n\n\n\n  /**\n\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n\n   */\n\n  modifier onlyPendingOwner() {\n\n    require(msg.sender == pendingOwner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to set the pendingOwner address.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner public {\n\n    pendingOwner = newOwner;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the pendingOwner address to finalize the transfer.\n\n   */\n\n  function claimOwnership() onlyPendingOwner public {\n\n    OwnershipTransferred(owner, pendingOwner);\n\n    owner = pendingOwner;\n\n    pendingOwner = address(0);\n\n  }\n\n}\n\n\n\ncontract AddressList is Claimable {\n\n    string public name;\n\n    mapping (address => bool) public onList;\n\n\n\n    function AddressList(string _name, bool nullValue) public {\n\n        name = _name;\n\n        onList[0x0] = nullValue;\n\n    }\n\n    event ChangeWhiteList(address indexed to, bool onList);\n\n\n\n    // Set whether _to is on the list or not. Whether 0x0 is on the list\n\n    // or not cannot be set here - it is set once and for all by the constructor.\n\n    function changeList(address _to, bool _onList) onlyOwner public {\n\n        require(_to != 0x0);\n\n        if (onList[_to] != _onList) {\n\n            onList[_to] = _onList;\n\n            ChangeWhiteList(_to, _onList);\n\n        }\n\n    }\n\n}\n\n\n\ncontract NamableAddressList is AddressList {\n\n    function NamableAddressList(string _name, bool nullValue)\n\n        AddressList(_name, nullValue) public {}\n\n\n\n    function changeName(string _name) onlyOwner public {\n\n        name = _name;\n\n    }\n\n}\n\n\n\ncontract HasNoContracts is Ownable {\n\n\n\n  /**\n\n   * @dev Reclaim ownership of Ownable contracts\n\n   * @param contractAddr The address of the Ownable to be reclaimed.\n\n   */\n\n  function reclaimContract(address contractAddr) external onlyOwner {\n\n    Ownable contractInst = Ownable(contractAddr);\n\n    contractInst.transferOwnership(owner);\n\n  }\n\n}\n\n\n\ncontract HasNoEther is Ownable {\n\n\n\n  /**\n\n  * @dev Constructor that rejects incoming Ether\n\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n\n  * we could use assembly to access msg.value.\n\n  */\n\n  function HasNoEther() public payable {\n\n    require(msg.value == 0);\n\n  }\n\n\n\n  /**\n\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\n\n   */\n\n  function() external {\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer all Ether held by the contract to the owner.\n\n   */\n\n  function reclaimEther() external onlyOwner {\n\n    assert(owner.send(this.balance));\n\n  }\n\n}\n\n\n\ncontract HasNoTokens is CanReclaimToken {\n\n\n\n /**\n\n  * @dev Reject all ERC223 compatible tokens\n\n  * @param from_ address The address that is transferring the tokens\n\n  * @param value_ uint256 the amount of the specified token\n\n  * @param data_ Bytes The data passed from the caller.\n\n  */\n\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n\n    from_;\n\n    value_;\n\n    data_;\n\n    revert();\n\n  }\n\n\n\n}\n\n\n\ncontract TimeLockedController is HasNoEther, HasNoTokens, Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    // 6 hours, assuming a 15 second blocktime.\n\n    // As long as this isn't too far off from reality it doesn't really matter.\n\n    uint public constant blocksDelay = 6*60*60/15;\n\n\n\n    struct MintOperation {\n\n        address to;\n\n        uint256 amount;\n\n        address admin;\n\n        uint deferBlock;\n\n    }\n\n\n\n    address public admin;\n\n    TrueUSD public trueUSD;\n\n    MintOperation[] public mintOperations;\n\n\n\n    modifier onlyAdminOrOwner() {\n\n        require(msg.sender == admin || msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    event MintOperationEvent(address indexed _to, uint256 amount, uint deferBlock, uint opIndex);\n\n    event TransferChildEvent(address indexed _child, address indexed _newOwner);\n\n    event ReclaimEvent(address indexed other);\n\n    event ChangeBurnBoundsEvent(uint newMin, uint newMax);\n\n    event ChangeStakingFeesEvent(uint80 _transferFeeNumerator,\n\n                                            uint80 _transferFeeDenominator,\n\n                                            uint80 _mintFeeNumerator,\n\n                                            uint80 _mintFeeDenominator,\n\n                                            uint256 _mintFeeFlat,\n\n                                            uint80 _burnFeeNumerator,\n\n                                            uint80 _burnFeeDenominator,\n\n                                            uint256 _burnFeeFlat);\n\n    event ChangeStakerEvent(address newStaker);\n\n    event DelegateEvent(DelegateERC20 delegate);\n\n    event SetDelegatedFromEvent(address source);\n\n    event ChangeTrueUSDEvent(TrueUSD newContract);\n\n    event ChangeNameEvent(string name, string symbol);\n\n    event AdminshipTransferred(address indexed previousAdmin, address indexed newAdmin);\n\n\n\n    // admin initiates a request to mint _amount TrueUSD for account _to\n\n    function requestMint(address _to, uint256 _amount) public onlyAdminOrOwner {\n\n        uint deferBlock = block.number;\n\n        if (msg.sender != owner) {\n\n            deferBlock = deferBlock.add(blocksDelay);\n\n        }\n\n        MintOperation memory op = MintOperation(_to, _amount, admin, deferBlock);\n\n        MintOperationEvent(_to, _amount, deferBlock, mintOperations.length);\n\n        mintOperations.push(op);\n\n    }\n\n\n\n    // after a day, admin finalizes mint request by providing the\n\n    // index of the request (visible in the MintOperationEvent accompanying the original request)\n\n    function finalizeMint(uint index) public onlyAdminOrOwner {\n\n        MintOperation memory op = mintOperations[index];\n\n        require(op.admin == admin); //checks that the requester's adminship has not been revoked\n\n        require(op.deferBlock <= block.number); //checks that enough time has elapsed\n\n        address to = op.to;\n\n        uint256 amount = op.amount;\n\n        delete mintOperations[index];\n\n        trueUSD.mint(to, amount);\n\n    }\n\n\n\n    // Transfer ownership of _child to _newOwner\n\n    // Can be used e.g. to upgrade this TimeLockedController contract.\n\n    function transferChild(Ownable _child, address _newOwner) public onlyOwner {\n\n        TransferChildEvent(_child, _newOwner);\n\n        _child.transferOwnership(_newOwner);\n\n    }\n\n\n\n    // Transfer ownership of a contract from trueUSD\n\n    // to this TimeLockedController. Can be used e.g. to reclaim balance sheet\n\n    // in order to transfer it to an upgraded TrueUSD contract.\n\n    function requestReclaim(Ownable other) public onlyOwner {\n\n        ReclaimEvent(other);\n\n        trueUSD.reclaimContract(other);\n\n    }\n\n\n\n    // Change the minimum and maximum amounts that TrueUSD users can\n\n    // burn to newMin and newMax\n\n    function changeBurnBounds(uint newMin, uint newMax) public onlyOwner {\n\n        ChangeBurnBoundsEvent(newMin, newMax);\n\n        trueUSD.changeBurnBounds(newMin, newMax);\n\n    }\n\n\n\n    // Change the transaction fees charged on transfer/mint/burn\n\n    function changeStakingFees(uint80 _transferFeeNumerator,\n\n                               uint80 _transferFeeDenominator,\n\n                               uint80 _mintFeeNumerator,\n\n                               uint80 _mintFeeDenominator,\n\n                               uint256 _mintFeeFlat,\n\n                               uint80 _burnFeeNumerator,\n\n                               uint80 _burnFeeDenominator,\n\n                               uint256 _burnFeeFlat) public onlyOwner {\n\n        ChangeStakingFeesEvent(_transferFeeNumerator,\n\n                                          _transferFeeDenominator,\n\n                                          _mintFeeNumerator,\n\n                                          _mintFeeDenominator,\n\n                                          _mintFeeFlat,\n\n                                          _burnFeeNumerator,\n\n                                          _burnFeeDenominator,\n\n                                          _burnFeeFlat);\n\n        trueUSD.changeStakingFees(_transferFeeNumerator,\n\n                                  _transferFeeDenominator,\n\n                                  _mintFeeNumerator,\n\n                                  _mintFeeDenominator,\n\n                                  _mintFeeFlat,\n\n                                  _burnFeeNumerator,\n\n                                  _burnFeeDenominator,\n\n                                  _burnFeeFlat);\n\n    }\n\n\n\n    // Change the recipient of staking fees to newStaker\n\n    function changeStaker(address newStaker) public onlyOwner {\n\n        ChangeStakerEvent(newStaker);\n\n        trueUSD.changeStaker(newStaker);\n\n    }\n\n\n\n    // Future ERC20 calls to trueUSD be delegated to _delegate\n\n    function delegateToNewContract(DelegateERC20 delegate) public onlyOwner {\n\n        DelegateEvent(delegate);\n\n        trueUSD.delegateToNewContract(delegate);\n\n    }\n\n\n\n    // Incoming delegate* calls from _source will be accepted by trueUSD\n\n    function setDelegatedFrom(address _source) public onlyOwner {\n\n        SetDelegatedFromEvent(_source);\n\n        trueUSD.setDelegatedFrom(_source);\n\n    }\n\n\n\n    // Update this contract's trueUSD pointer to newContract (e.g. if the\n\n    // contract is upgraded)\n\n    function setTrueUSD(TrueUSD newContract) public onlyOwner {\n\n        ChangeTrueUSDEvent(newContract);\n\n        trueUSD = newContract;\n\n    }\n\n\n\n    // change trueUSD's name and symbol\n\n    function changeName(string name, string symbol) public onlyOwner {\n\n        ChangeNameEvent(name, symbol);\n\n        trueUSD.changeName(name, symbol);\n\n    }\n\n\n\n    // Replace the current admin with newAdmin\n\n    function transferAdminship(address newAdmin) public onlyOwner {\n\n        AdminshipTransferred(admin, newAdmin);\n\n        admin = newAdmin;\n\n    }\n\n\n\n    // Swap out TrueUSD's address lists\n\n    function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) onlyOwner public {\n\n        trueUSD.setLists(_canReceiveMintWhiteList, _canBurnWhiteList, _blackList, _noFeesList);\n\n    }\n\n\n\n    // Update a whitelist/blacklist\n\n    function updateList(address list, address entry, bool flag) public onlyAdminOrOwner {\n\n        AddressList(list).changeList(entry, flag);\n\n    }\n\n\n\n    // Rename a whitelist/blacklist\n\n    function renameList(address list, string name) public onlyAdminOrOwner {\n\n        NamableAddressList(list).changeName(name);\n\n    }\n\n\n\n    // Claim ownership of an arbitrary Claimable contract\n\n    function issueClaimOwnership(address _other) public onlyAdminOrOwner {\n\n        Claimable other = Claimable(_other);\n\n        other.claimOwnership();\n\n    }\n\n}\n\n\n\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\n\n}\n\n\n\ncontract AllowanceSheet is Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => mapping (address => uint256)) public allowanceOf;\n\n\n\n    function addAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = allowanceOf[tokenHolder][spender].add(value);\n\n    }\n\n\n\n    function subAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = allowanceOf[tokenHolder][spender].sub(value);\n\n    }\n\n\n\n    function setAllowance(address tokenHolder, address spender, uint256 value) public onlyOwner {\n\n        allowanceOf[tokenHolder][spender] = value;\n\n    }\n\n}\n\n\n\ncontract BalanceSheet is Claimable {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) public balanceOf;\n\n\n\n    function addBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = balanceOf[addr].add(value);\n\n    }\n\n\n\n    function subBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = balanceOf[addr].sub(value);\n\n    }\n\n\n\n    function setBalance(address addr, uint256 value) public onlyOwner {\n\n        balanceOf[addr] = value;\n\n    }\n\n}\n\n\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract BasicToken is ERC20Basic, Claimable {\n\n  using SafeMath for uint256;\n\n\n\n  BalanceSheet public balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  function setBalanceSheet(address sheet) external onlyOwner {\n\n    balances = BalanceSheet(sheet);\n\n    balances.claimOwnership();\n\n  }\n\n\n\n  /**\n\n  * @dev total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    transferAllArgsNoAllowance(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal {\n\n    require(_to != address(0));\n\n    require(_from != address(0));\n\n    require(_value <= balances.balanceOf(_from));\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances.subBalance(_from, _value);\n\n    balances.addBalance(_to, _value);\n\n    Transfer(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances.balanceOf(_owner);\n\n  }\n\n}\n\n\n\ncontract BurnableToken is BasicToken {\n\n\n\n  event Burn(address indexed burner, uint256 value);\n\n\n\n  /**\n\n   * @dev Burns a specific amount of tokens.\n\n   * @param _value The amount of token to be burned.\n\n   */\n\n  function burn(uint256 _value) public {\n\n    require(_value <= balances.balanceOf(msg.sender));\n\n    // no need to require value <= totalSupply, since that would imply the\n\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n    address burner = msg.sender;\n\n    balances.subBalance(burner, _value);\n\n    totalSupply_ = totalSupply_.sub(_value);\n\n    Burn(burner, _value);\n\n    Transfer(burner, address(0), _value);\n\n  }\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\nlibrary SafeERC20 {\n\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n\n    assert(token.transfer(to, value));\n\n  }\n\n\n\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n\n    assert(token.transferFrom(from, to, value));\n\n  }\n\n\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n\n    assert(token.approve(spender, value));\n\n  }\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  AllowanceSheet public allowances;\n\n\n\n  function setAllowanceSheet(address sheet) external onlyOwner {\n\n    allowances = AllowanceSheet(sheet);\n\n    allowances.claimOwnership();\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    transferAllArgsYesAllowance(_from, _to, _value, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function transferAllArgsYesAllowance(address _from, address _to, uint256 _value, address spender) internal {\n\n    require(_value <= allowances.allowanceOf(_from, spender));\n\n\n\n    allowances.subAllowance(_from, spender, _value);\n\n    transferAllArgsNoAllowance(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    approveAllArgs(_spender, _value, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal {\n\n    allowances.setAllowance(_tokenHolder, _spender, _value);\n\n    Approval(_tokenHolder, _spender, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n\n    return allowances.allowanceOf(_owner, _spender);\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n    increaseApprovalAllArgs(_spender, _addedValue, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function increaseApprovalAllArgs(address _spender, uint _addedValue, address tokenHolder) internal {\n\n    allowances.addAllowance(tokenHolder, _spender, _addedValue);\n\n    Approval(tokenHolder, _spender, allowances.allowanceOf(tokenHolder, _spender));\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n    decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);\n\n    return true;\n\n  }\n\n\n\n  function decreaseApprovalAllArgs(address _spender, uint _subtractedValue, address tokenHolder) internal {\n\n    uint oldValue = allowances.allowanceOf(tokenHolder, _spender);\n\n    if (_subtractedValue > oldValue) {\n\n      allowances.setAllowance(tokenHolder, _spender, 0);\n\n    } else {\n\n      allowances.subAllowance(tokenHolder, _spender, _subtractedValue);\n\n    }\n\n    Approval(tokenHolder, _spender, allowances.allowanceOf(tokenHolder, _spender));\n\n  }\n\n\n\n}\n\n\n\ncontract CanDelegate is StandardToken {\n\n    // If this contract needs to be upgraded, the new contract will be stored\n\n    // in 'delegate' and any ERC20 calls to this contract will be delegated to that one.\n\n    DelegateERC20 public delegate;\n\n\n\n    event DelegatedTo(address indexed newContract);\n\n\n\n    // Can undelegate by passing in newContract = address(0)\n\n    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner {\n\n        delegate = newContract;\n\n        DelegatedTo(delegate);\n\n    }\n\n\n\n    // If a delegate has been designated, all ERC20 calls are forwarded to it\n\n    function transfer(address to, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.transfer(to, value);\n\n        } else {\n\n            return delegate.delegateTransfer(to, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.transferFrom(from, to, value);\n\n        } else {\n\n            return delegate.delegateTransferFrom(from, to, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function balanceOf(address who) public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.balanceOf(who);\n\n        } else {\n\n            return delegate.delegateBalanceOf(who);\n\n        }\n\n    }\n\n\n\n    function approve(address spender, uint256 value) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.approve(spender, value);\n\n        } else {\n\n            return delegate.delegateApprove(spender, value, msg.sender);\n\n        }\n\n    }\n\n\n\n    function allowance(address _owner, address spender) public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.allowance(_owner, spender);\n\n        } else {\n\n            return delegate.delegateAllowance(_owner, spender);\n\n        }\n\n    }\n\n\n\n    function totalSupply() public view returns (uint256) {\n\n        if (delegate == address(0)) {\n\n            return super.totalSupply();\n\n        } else {\n\n            return delegate.delegateTotalSupply();\n\n        }\n\n    }\n\n\n\n    function increaseApproval(address spender, uint addedValue) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.increaseApproval(spender, addedValue);\n\n        } else {\n\n            return delegate.delegateIncreaseApproval(spender, addedValue, msg.sender);\n\n        }\n\n    }\n\n\n\n    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {\n\n        if (delegate == address(0)) {\n\n            return super.decreaseApproval(spender, subtractedValue);\n\n        } else {\n\n            return delegate.delegateDecreaseApproval(spender, subtractedValue, msg.sender);\n\n        }\n\n    }\n\n}\n\n\n\ncontract StandardDelegate is StandardToken, DelegateERC20 {\n\n    address public delegatedFrom;\n\n\n\n    modifier onlySender(address source) {\n\n        require(msg.sender == source);\n\n        _;\n\n    }\n\n\n\n    function setDelegatedFrom(address addr) onlyOwner public {\n\n        delegatedFrom = addr;\n\n    }\n\n\n\n    // All delegate ERC20 functions are forwarded to corresponding normal functions\n\n    function delegateTotalSupply() public view returns (uint256) {\n\n        return totalSupply();\n\n    }\n\n\n\n    function delegateBalanceOf(address who) public view returns (uint256) {\n\n        return balanceOf(who);\n\n    }\n\n\n\n    function delegateTransfer(address to, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        transferAllArgsNoAllowance(origSender, to, value);\n\n        return true;\n\n    }\n\n\n\n    function delegateAllowance(address owner, address spender) public view returns (uint256) {\n\n        return allowance(owner, spender);\n\n    }\n\n\n\n    function delegateTransferFrom(address from, address to, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        transferAllArgsYesAllowance(from, to, value, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateApprove(address spender, uint256 value, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        approveAllArgs(spender, value, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateIncreaseApproval(address spender, uint addedValue, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        increaseApprovalAllArgs(spender, addedValue, origSender);\n\n        return true;\n\n    }\n\n\n\n    function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) onlySender(delegatedFrom) public returns (bool) {\n\n        decreaseApprovalAllArgs(spender, subtractedValue, origSender);\n\n        return true;\n\n    }\n\n}\n\n\n\ncontract PausableToken is StandardToken, Pausable {\n\n\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.transfer(_to, _value);\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.transferFrom(_from, _to, _value);\n\n  }\n\n\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.approve(_spender, _value);\n\n  }\n\n\n\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n\n    return super.increaseApproval(_spender, _addedValue);\n\n  }\n\n\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n\n    return super.decreaseApproval(_spender, _subtractedValue);\n\n  }\n\n}\n\n\n\ncontract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate {\n\n    string public name = \"TrueUSD\";\n\n    string public symbol = \"TUSD\";\n\n    uint8 public constant decimals = 18;\n\n\n\n    AddressList public canReceiveMintWhiteList;\n\n    AddressList public canBurnWhiteList;\n\n    AddressList public blackList;\n\n    AddressList public noFeesList;\n\n    uint256 public burnMin = 10000 * 10**uint256(decimals);\n\n    uint256 public burnMax = 20000000 * 10**uint256(decimals);\n\n\n\n    uint80 public transferFeeNumerator = 7;\n\n    uint80 public transferFeeDenominator = 10000;\n\n    uint80 public mintFeeNumerator = 0;\n\n    uint80 public mintFeeDenominator = 10000;\n\n    uint256 public mintFeeFlat = 0;\n\n    uint80 public burnFeeNumerator = 0;\n\n    uint80 public burnFeeDenominator = 10000;\n\n    uint256 public burnFeeFlat = 0;\n\n    address public staker;\n\n\n\n    event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax);\n\n    event Mint(address indexed to, uint256 amount);\n\n    event WipedAccount(address indexed account, uint256 balance);\n\n\n\n    function TrueUSD() public {\n\n        totalSupply_ = 0;\n\n        staker = msg.sender;\n\n    }\n\n\n\n    function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) onlyOwner public {\n\n        canReceiveMintWhiteList = _canReceiveMintWhiteList;\n\n        canBurnWhiteList = _canBurnWhiteList;\n\n        blackList = _blackList;\n\n        noFeesList = _noFeesList;\n\n    }\n\n\n\n    function changeName(string _name, string _symbol) onlyOwner public {\n\n        name = _name;\n\n        symbol = _symbol;\n\n    }\n\n\n\n    //Burning functions as withdrawing money from the system. The platform will keep track of who burns coins,\n\n    //and will send them back the equivalent amount of money (rounded down to the nearest cent).\n\n    function burn(uint256 _value) public {\n\n        require(canBurnWhiteList.onList(msg.sender));\n\n        require(_value >= burnMin);\n\n        require(_value <= burnMax);\n\n        uint256 fee = payStakingFee(msg.sender, _value, burnFeeNumerator, burnFeeDenominator, burnFeeFlat, 0x0);\n\n        uint256 remaining = _value.sub(fee);\n\n        super.burn(remaining);\n\n    }\n\n\n\n    //Create _amount new tokens and transfer them to _to.\n\n    //Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/MintableToken.sol\n\n    function mint(address _to, uint256 _amount) onlyOwner public {\n\n        require(canReceiveMintWhiteList.onList(_to));\n\n        totalSupply_ = totalSupply_.add(_amount);\n\n        balances.addBalance(_to, _amount);\n\n        Mint(_to, _amount);\n\n        Transfer(address(0), _to, _amount);\n\n        payStakingFee(_to, _amount, mintFeeNumerator, mintFeeDenominator, mintFeeFlat, 0x0);\n\n    }\n\n\n\n    //Change the minimum and maximum amount that can be burned at once. Burning\n\n    //may be disabled by setting both to 0 (this will not be done under normal\n\n    //operation, but we can't add checks to disallow it without losing a lot of\n\n    //flexibility since burning could also be as good as disabled\n\n    //by setting the minimum extremely high, and we don't want to lock\n\n    //in any particular cap for the minimum)\n\n    function changeBurnBounds(uint newMin, uint newMax) onlyOwner public {\n\n        require(newMin <= newMax);\n\n        burnMin = newMin;\n\n        burnMax = newMax;\n\n        ChangeBurnBoundsEvent(newMin, newMax);\n\n    }\n\n\n\n    // transfer and transferFrom are both dispatched to this function, so we\n\n    // check blacklist and pay staking fee here.\n\n    function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal {\n\n        require(!blackList.onList(_from));\n\n        require(!blackList.onList(_to));\n\n        super.transferAllArgsNoAllowance(_from, _to, _value);\n\n        payStakingFee(_to, _value, transferFeeNumerator, transferFeeDenominator, 0, _from);\n\n    }\n\n\n\n    function wipeBlacklistedAccount(address account) public onlyOwner {\n\n        require(blackList.onList(account));\n\n        uint256 oldValue = balanceOf(account);\n\n        balances.setBalance(account, 0);\n\n        totalSupply_ = totalSupply_.sub(oldValue);\n\n        WipedAccount(account, oldValue);\n\n    }\n\n\n\n    function payStakingFee(address payer, uint256 value, uint80 numerator, uint80 denominator, uint256 flatRate, address otherParticipant) private returns (uint256) {\n\n        if (noFeesList.onList(payer) || noFeesList.onList(otherParticipant)) {\n\n            return 0;\n\n        }\n\n        uint256 stakingFee = value.mul(numerator).div(denominator).add(flatRate);\n\n        if (stakingFee > 0) {\n\n            super.transferAllArgsNoAllowance(payer, staker, stakingFee);\n\n        }\n\n        return stakingFee;\n\n    }\n\n\n\n    function changeStakingFees(uint80 _transferFeeNumerator,\n\n                                 uint80 _transferFeeDenominator,\n\n                                 uint80 _mintFeeNumerator,\n\n                                 uint80 _mintFeeDenominator,\n\n                                 uint256 _mintFeeFlat,\n\n                                 uint80 _burnFeeNumerator,\n\n                                 uint80 _burnFeeDenominator,\n\n                                 uint256 _burnFeeFlat) public onlyOwner {\n\n        require(_transferFeeDenominator != 0);\n\n        require(_mintFeeDenominator != 0);\n\n        require(_burnFeeDenominator != 0);\n\n        transferFeeNumerator = _transferFeeNumerator;\n\n        transferFeeDenominator = _transferFeeDenominator;\n\n        mintFeeNumerator = _mintFeeNumerator;\n\n        mintFeeDenominator = _mintFeeDenominator;\n\n        mintFeeFlat = _mintFeeFlat;\n\n        burnFeeNumerator = _burnFeeNumerator;\n\n        burnFeeDenominator = _burnFeeDenominator;\n\n        burnFeeFlat = _burnFeeFlat;\n\n    }\n\n\n\n    function changeStaker(address newStaker) public onlyOwner {\n\n        require(newStaker != address(0));\n\n        staker = newStaker;\n\n    }\n\n}"
  },
  {
    "id": 10,
    "addr4sss": "0x00000100f2a2bd000715001920eb70d229700085",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title OwnedUpgradeabilityProxy\n\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n\n */\n\ncontract TrueCAD {\n\n    /**\n\n    * @dev Event to show ownership has been transferred\n\n    * @param previousOwner representing the address of the previous owner\n\n    * @param newOwner representing the address of the new owner\n\n    */\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev Event to show ownership transfer is pending\n\n    * @param currentOwner representing the address of the current owner\n\n    * @param pendingOwner representing the address of the pending owner\n\n    */\n\n    event NewPendingOwner(address currentOwner, address pendingOwner);\n\n    \n\n    // Storage position of the owner and pendingOwner of the contract\n\n    bytes32 private constant proxyOwnerPosition = 0x136d55780fb1583e87bb6fa1fda0bbe2746553b012c9291a830fad1e95c269cc;//keccak256(\"trueCAD.proxy.owner\");\n\n    bytes32 private constant pendingProxyOwnerPosition = 0xca6c24188764c50fa5c7b728d85fdd98bea1991968b9f4bd4000ae3ace49faac;//keccak256(\"trueCAD.pending.proxy.owner\");\n\n\n\n    /**\n\n    * @dev the constructor sets the original owner of the contract to the sender account.\n\n    */\n\n    constructor() public {\n\n        _setUpgradeabilityOwner(msg.sender);\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyProxyOwner() {\n\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the pending owner.\n\n    */\n\n    modifier onlyPendingProxyOwner() {\n\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function proxyOwner() public view returns (address owner) {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            owner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function pendingProxyOwner() public view returns (address pendingOwner) {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            pendingOwner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newPendingProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    *changes the pending owner to newOwner. But doesn't actually transfer\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        _setPendingUpgradeabilityOwner(newOwner);\n\n        emit NewPendingOwner(proxyOwner(), newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the pendingOwner to claim ownership of the proxy\n\n    */\n\n    function claimProxyOwnership() external onlyPendingProxyOwner {\n\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n\n        _setUpgradeabilityOwner(pendingProxyOwner());\n\n        _setPendingUpgradeabilityOwner(address(0));\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n\n    * @param implementation representing the address of the new implementation to be set.\n\n    */\n\n    function upgradeTo(address implementation) external onlyProxyOwner {\n\n        address currentImplementation;\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n            currentImplementation := sload(position)\n\n        }\n\n        require(currentImplementation != implementation);\n\n        assembly {\n\n          sstore(position, implementation)\n\n        }\n\n        emit Upgraded(implementation);\n\n    }\n\n    /**\n\n    * @dev This event will be emitted every time the implementation gets upgraded\n\n    * @param implementation representing the address of the upgraded implementation\n\n    */\n\n    event Upgraded(address indexed implementation);\n\n\n\n    // Storage position of the address of the current implementation\n\n    bytes32 private constant implementationPosition = 0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982; //keccak256(\"trueCAD.proxy.implementation\");\n\n\n\n    function implementation() public view returns (address impl) {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n            impl := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n\n    * This function will return whatever the implementation call returns\n\n    */\n\n    function() external payable {\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, returndatasize, calldatasize)\n\n            let result := delegatecall(gas, sload(0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982), ptr, calldatasize, returndatasize, returndatasize)\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 11,
    "addr4sss": "0x00006100f7090010005f1bd7ae6122c3c2cf0090",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 1,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol\n\n\n\n/**\n\n * @title OwnedUpgradeabilityProxy\n\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n\n */\n\ncontract TrueAUD {\n\n    /**\n\n    * @dev Event to show ownership has been transferred\n\n    * @param previousOwner representing the address of the previous owner\n\n    * @param newOwner representing the address of the new owner\n\n    */\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev Event to show ownership transfer is pending\n\n    * @param currentOwner representing the address of the current owner\n\n    * @param pendingOwner representing the address of the pending owner\n\n    */\n\n    event NewPendingOwner(address currentOwner, address pendingOwner);\n\n    \n\n    // Storage position of the owner and pendingOwner of the contract\n\n    bytes32 private constant proxyOwnerPosition = 0x9afdba48695f976525206667656e0eb4a6d66671c0d3ec078f1f48d2307ed49c;//keccak256(\"trueAUD.proxy.owner\");\n\n    bytes32 private constant pendingProxyOwnerPosition = 0x7b9044cf1491ee5d1e688907e48d0439248c6543a740f2f5f828fecf8367c4d1;//keccak256(\"trueAUD.pending.proxy.owner\");\n\n\n\n    /**\n\n    * @dev the constructor sets the original owner of the contract to the sender account.\n\n    */\n\n    constructor() public {\n\n        _setUpgradeabilityOwner(msg.sender);\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyProxyOwner() {\n\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the pending owner.\n\n    */\n\n    modifier onlyPendingProxyOwner() {\n\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function proxyOwner() public view returns (address owner) {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            owner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Tells the address of the owner\n\n    * @return the address of the owner\n\n    */\n\n    function pendingProxyOwner() public view returns (address pendingOwner) {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            pendingOwner := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n\n        bytes32 position = proxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Sets the address of the owner\n\n    */\n\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n\n        bytes32 position = pendingProxyOwnerPosition;\n\n        assembly {\n\n            sstore(position, newPendingProxyOwner)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    *changes the pending owner to newOwner. But doesn't actually transfer\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        _setPendingUpgradeabilityOwner(newOwner);\n\n        emit NewPendingOwner(proxyOwner(), newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the pendingOwner to claim ownership of the proxy\n\n    */\n\n    function claimProxyOwnership() external onlyPendingProxyOwner {\n\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n\n        _setUpgradeabilityOwner(pendingProxyOwner());\n\n        _setPendingUpgradeabilityOwner(address(0));\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n\n    * @param implementation representing the address of the new implementation to be set.\n\n    */\n\n    function upgradeTo(address implementation) external onlyProxyOwner {\n\n        address currentImplementation;\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n            currentImplementation := sload(position)\n\n        }\n\n        require(currentImplementation != implementation);\n\n        assembly {\n\n          sstore(position, implementation)\n\n        }\n\n        emit Upgraded(implementation);\n\n    }\n\n    /**\n\n    * @dev This event will be emitted every time the implementation gets upgraded\n\n    * @param implementation representing the address of the upgraded implementation\n\n    */\n\n    event Upgraded(address indexed implementation);\n\n\n\n    // Storage position of the address of the current implementation\n\n    bytes32 private constant implementationPosition = 0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb; //keccak256(\"trueAUD.proxy.implementation\");\n\n\n\n    function implementation() public view returns (address impl) {\n\n        bytes32 position = implementationPosition;\n\n        assembly {\n\n            impl := sload(position)\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n\n    * This function will return whatever the implementation call returns\n\n    */\n\n    function() external payable {\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, returndatasize, calldatasize)\n\n            let result := delegatecall(gas, sload(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), ptr, calldatasize, returndatasize, returndatasize)\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 12,
    "addr4sss": "0x0002325fcaaac6ebf1254a626589147bde1a2394",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n// File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    // uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return a / b;\n\n  }\n\n\n\n  /**\n\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n// File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n\n  event OwnershipTransferred(\n\n    address indexed previousOwner,\n\n    address indexed newOwner\n\n  );\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  constructor() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    emit OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to relinquish control of the contract.\n\n   */\n\n  function renounceOwnership() public onlyOwner {\n\n    emit OwnershipRenounced(owner);\n\n    owner = address(0);\n\n  }\n\n}\n\n\n\n// File: ..\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol\n\n\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    emit Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    emit Unpause();\n\n  }\n\n}\n\n\n\n// File: contracts\\HorseyExchange.sol\n\n\n\n/**\n\n * @title ERC721 Non-Fungible Token Standard basic interface\n\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n\n */\n\ncontract ERC721Basic {\n\n    function balanceOf(address _owner) public view returns (uint256 _balance);\n\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n\n    function exists(uint256 _tokenId) public view returns (bool _exists);\n\n\n\n    function approve(address _to, uint256 _tokenId) public;\n\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\n\n\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n\n}\n\n\n\n/**\n\n    @dev HorseyExchange contract - handles horsey market exchange which\n\n    includes the following set of functions:\n\n    1. Deposit to Exchange\n\n    2. Cancel sale\n\n    3. Purchase token\n\n**/\n\ncontract HorseyExchange is Pausable { //also Ownable\n\n\n\n    using SafeMath for uint256;\n\n\n\n    event HorseyDeposit(uint256 tokenId, uint256 price);\n\n    event SaleCanceled(uint256 tokenId);\n\n    event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay);\n\n\n\n    /// @dev Fee applied to market maker - measured as percentage\n\n    uint256 public marketMakerFee = 3;\n\n\n\n    /// @dev Amount collected in fees\n\n    uint256 collectedFees = 0;\n\n\n\n    /// @dev  RoyalStables TOKEN\n\n    ERC721Basic public token;\n\n\n\n    /**\n\n        @dev used to store the price and the owner address of a token on sale\n\n    */\n\n    struct SaleData {\n\n        uint256 price;\n\n        address owner;\n\n    }\n\n\n\n    /// @dev Market spec to lookup price and original owner based on token id\n\n    mapping (uint256 => SaleData) market;\n\n\n\n    /// @dev mapping of current tokens on market by owner\n\n    mapping (address => uint256[]) userBarn;\n\n\n\n    /// @dev initialize\n\n    constructor() Pausable() public {\n\n    }\n\n\n\n    /**\n\n        @dev Since the exchange requires the horsey contract and horsey contract\n\n            requires exchange address, we cant initialize both of them in constructors\n\n        @param _token Address of the stables contract\n\n    */\n\n    function setStables(address _token) external\n\n    onlyOwner()\n\n    {\n\n        require(address(_token) != 0,\"Address of token is zero\");\n\n        token = ERC721Basic(_token);\n\n    }\n\n\n\n    /**\n\n        @dev Allows the owner to change market fees\n\n        @param fees The new fees to apply (can be zero)\n\n    */\n\n    function setMarketFees(uint256 fees) external\n\n    onlyOwner()\n\n    {\n\n        marketMakerFee = fees;\n\n    }\n\n\n\n    /// @return the tokens on sale based on the user address\n\n    function getTokensOnSale(address user) external view returns(uint256[]) {\n\n        return userBarn[user];\n\n    }\n\n\n\n    /// @return the token price with the fees\n\n    function getTokenPrice(uint256 tokenId) public view\n\n    isOnMarket(tokenId) returns (uint256) {\n\n        return market[tokenId].price + (market[tokenId].price.div(100).mul(marketMakerFee));\n\n    }\n\n\n\n    /**\n\n        @dev User sends token to sell to exchange - at this point the exchange contract takes\n\n            ownership, but will map token ownership back to owner for auotmated withdraw on\n\n            cancel - requires that user is the rightful owner and is not\n\n            asking for a null price\n\n    */\n\n    function depositToExchange(uint256 tokenId, uint256 price) external\n\n    whenNotPaused()\n\n    isTokenOwner(tokenId)\n\n    nonZeroPrice(price)\n\n    tokenAvailable() {\n\n        require(token.getApproved(tokenId) == address(this),\"Exchange is not allowed to transfer\");\n\n        //Transfers token from depositee to exchange (contract address)\n\n        token.transferFrom(msg.sender, address(this), tokenId);\n\n        \n\n        //add the token to the market\n\n        market[tokenId] = SaleData(price,msg.sender);\n\n\n\n        //Add token to exchange map - tracking by owner of all tokens\n\n        userBarn[msg.sender].push(tokenId);\n\n\n\n        emit HorseyDeposit(tokenId, price);\n\n    }\n\n\n\n    /**\n\n        @dev Allows true owner of token to cancel sale at anytime\n\n        @param tokenId ID of the token to remove from the market\n\n        @return true if user still has tokens for sale\n\n    */\n\n    function cancelSale(uint256 tokenId) external \n\n    whenNotPaused()\n\n    originalOwnerOf(tokenId) \n\n    tokenAvailable() returns (bool) {\n\n        //throws on fail - transfers token from exchange back to original owner\n\n        token.transferFrom(address(this),msg.sender,tokenId);\n\n        \n\n        //Reset token on market - remove\n\n        delete market[tokenId];\n\n\n\n        //Reset barn tracker for user\n\n        _removeTokenFromBarn(tokenId, msg.sender);\n\n\n\n        emit SaleCanceled(tokenId);\n\n\n\n        //Return true if this user is still 'active' within the exchange\n\n        //This will help with client side actions\n\n        return userBarn[msg.sender].length > 0;\n\n    }\n\n\n\n    /**\n\n        @dev Performs the purchase of a token that is present on the market - this includes checking that the\n\n            proper amount is sent + appliced fee, updating seller's balance, updated collected fees and\n\n            transfering token to buyer\n\n            Only market tokens can be purchased\n\n        @param tokenId ID of the token we wish to purchase\n\n    */\n\n    function purchaseToken(uint256 tokenId) external payable \n\n    whenNotPaused()\n\n    isOnMarket(tokenId) \n\n    tokenAvailable()\n\n    notOriginalOwnerOf(tokenId)\n\n    {\n\n        //Did the sender accidently pay over? - if so track the amount over\n\n        uint256 totalToPay = getTokenPrice(tokenId);\n\n        require(msg.value >= totalToPay, \"Not paying enough\");\n\n\n\n        //fetch this tokens sale data\n\n        SaleData memory sale = market[tokenId];\n\n\n\n        //Add to collected fee amount payable to DEVS\n\n        collectedFees += totalToPay - sale.price;\n\n\n\n        //pay the seller\n\n        sale.owner.transfer(sale.price);\n\n\n\n        //Reset barn tracker for user\n\n        _removeTokenFromBarn(tokenId,  sale.owner);\n\n\n\n        //Reset token on market - remove\n\n        delete market[tokenId];\n\n\n\n        //Transfer the ERC721 to the buyer - we leave the sale amount\n\n        //to be withdrawn by the user (transferred from exchange)\n\n        token.transferFrom(address(this), msg.sender, tokenId);\n\n\n\n        //Return over paid amount to sender if necessary\n\n        if(msg.value > totalToPay) //overpaid\n\n        {\n\n            msg.sender.transfer(msg.value.sub(totalToPay));\n\n        }\n\n\n\n        emit HorseyPurchased(tokenId, msg.sender, totalToPay);\n\n    }\n\n\n\n    /// @dev Transfers the collected fees to the owner\n\n    function withdraw() external\n\n    onlyOwner()\n\n    {\n\n        assert(collectedFees <= address(this).balance);\n\n        owner.transfer(collectedFees);\n\n        collectedFees = 0;\n\n    }\n\n\n\n    /**\n\n        @dev Internal function to remove a token from the users barn array\n\n        @param tokenId ID of the token to remove\n\n        @param barnAddress Address of the user selling tokens\n\n    */\n\n    function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal {\n\n        uint256[] storage barnArray = userBarn[barnAddress];\n\n        require(barnArray.length > 0,\"No tokens to remove\");\n\n        int index = _indexOf(tokenId, barnArray);\n\n        require(index >= 0, \"Token not found in barn\");\n\n\n\n        // Shift entire array :(\n\n        for (uint256 i = uint256(index); i<barnArray.length-1; i++){\n\n            barnArray[i] = barnArray[i+1];\n\n        }\n\n\n\n        // Remove element, update length, return array\n\n        // this should be enough since https://ethereum.stackexchange.com/questions/1527/how-to-delete-an-element-at-a-certain-index-in-an-array\n\n        barnArray.length--;\n\n    }\n\n\n\n    /**\n\n        @dev Helper function which stores in memory an array which is passed in, and\n\n        @param item element we are looking for\n\n        @param array the array to look into\n\n        @return the index of the item of interest\n\n    */\n\n    function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){\n\n\n\n        //Iterate over array to find indexOf(token)\n\n        for(uint256 i = 0; i < array.length; i++){\n\n            if(array[i] == item){\n\n                return int256(i);\n\n            }\n\n        }\n\n\n\n        //Item not found\n\n        return -1;\n\n    }\n\n\n\n    /// @dev requires token to be on the market = current owner is exchange\n\n    modifier isOnMarket(uint256 tokenId) {\n\n        require(token.ownerOf(tokenId) == address(this),\"Token not on market\");\n\n        _;\n\n    }\n\n    \n\n    /// @dev Is the user the owner of this token?\n\n    modifier isTokenOwner(uint256 tokenId) {\n\n        require(token.ownerOf(tokenId) == msg.sender,\"Not tokens owner\");\n\n        _;\n\n    }\n\n\n\n    /// @dev Is this the original owner of the token - at exchange level\n\n    modifier originalOwnerOf(uint256 tokenId) {\n\n        require(market[tokenId].owner == msg.sender,\"Not the original owner of\");\n\n        _;\n\n    }\n\n\n\n    /// @dev Is this the original owner of the token - at exchange level\n\n    modifier notOriginalOwnerOf(uint256 tokenId) {\n\n        require(market[tokenId].owner != msg.sender,\"Is the original owner\");\n\n        _;\n\n    }\n\n\n\n    /// @dev Is a nonzero price being sent?\n\n    modifier nonZeroPrice(uint256 price){\n\n        require(price > 0,\"Price is zero\");\n\n        _;\n\n    }\n\n\n\n    /// @dev Do we have a token address\n\n    modifier tokenAvailable(){\n\n        require(address(token) != 0,\"Token address not set\");\n\n        _;\n\n    }\n\n}\n\n\n\n// File: contracts\\EthorseHelpers.sol\n\n\n\ncontract BettingControllerInterface {\n\n    address public owner;\n\n}\n\n/**\n\n    @title Race contract - used for linking ethorse Race struct \n\n    @dev This interface is losely based on ethorse race contract\n\n*/\n\ncontract EthorseRace {\n\n\n\n    //Encapsulation of racing information \n\n    struct chronus_info {\n\n        bool  betting_open; // boolean: check if betting is open\n\n        bool  race_start; //boolean: check if race has started\n\n        bool  race_end; //boolean: check if race has ended\n\n        bool  voided_bet; //boolean: check if race has been voided\n\n        uint32  starting_time; // timestamp of when the race starts\n\n        uint32  betting_duration;\n\n        uint32  race_duration; // duration of the race\n\n        uint32 voided_timestamp;\n\n    }\n\n\n\n    address public owner;\n\n    \n\n    //Point to racing information\n\n    chronus_info public chronus;\n\n\n\n    //Coin index mapping to flag - true if index is winner\n\n    mapping (bytes32 => bool) public winner_horse;\n\n    /*\n\n            // exposing the coin pool details for DApp\n\n    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\n\n        return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\n\n    }\n\n    */\n\n    // exposing the coin pool details for DApp\n\n    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint);\n\n}\n\n\n\n/**\n\n    @title API contract - used to connect with Race contract and \n\n        encapsulate race information for token inidices and winner\n\n        checking.\n\n*/\n\ncontract EthorseHelpers {\n\n\n\n    /// @dev Convert all symbols to bytes array\n\n    bytes32[] public all_horses = [bytes32(\"BTC\"),bytes32(\"ETH\"),bytes32(\"LTC\")];\n\n    mapping(address => bool) private _legitOwners;\n\n\n\n    /// @dev Used to add new symbol to the bytes array \n\n    function _addHorse(bytes32 newHorse) internal {\n\n        all_horses.push(newHorse);\n\n    }\n\n\n\n    function _addLegitOwner(address newOwner) internal\n\n    {\n\n        _legitOwners[newOwner] = true;\n\n    }\n\n\n\n    function getall_horsesCount() public view returns(uint) {\n\n        return all_horses.length;\n\n    }\n\n\n\n    /**\n\n        @param raceAddress - address of this race\n\n        @param eth_address - user's ethereum wallet address\n\n        @return true if user is winner + name of the winning horse (LTC,BTC,ETH,...)\n\n    */\n\n    function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32)\n\n    {\n\n        //acquire race, fails if doesnt exist\n\n        EthorseRace race = EthorseRace(raceAddress);\n\n        //acquire races betting controller\n\n        BettingControllerInterface bc = BettingControllerInterface(race.owner());\n\n        //make sure the betting controllers owner is in the legit list given by devs\n\n        require(_legitOwners[bc.owner()]);\n\n        //acquire chronus\n\n        bool  voided_bet; //boolean: check if race has been voided\n\n        bool  race_end; //boolean: check if race has ended\n\n        (,,race_end,voided_bet,,,,) = race.chronus();\n\n\n\n        //cant be winner if race was refunded or didnt end yet\n\n        if(voided_bet || !race_end)\n\n            return (false,bytes32(0));\n\n\n\n        //aquire winner race index\n\n        bytes32 horse;\n\n        bool found = false;\n\n        uint256 arrayLength = all_horses.length;\n\n\n\n        //Iterate over coin symbols to find winner - tie could be possible?\n\n        for(uint256 i = 0; i < arrayLength; i++)\n\n        {\n\n            if(race.winner_horse(all_horses[i])) {\n\n                horse = all_horses[i];\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        //no winner horse? shouldnt happen unless this horse isnt registered\n\n        if(!found)\n\n            return (false,bytes32(0));\n\n\n\n        //check the bet amount of the eth_address on the winner horse\n\n        uint256 bet_amount = 0;\n\n        if(eth_address != address(0)) {\n\n            (,,,, bet_amount) = race.getCoinIndex(horse, eth_address);\n\n        }\n\n        \n\n        //winner if the eth_address had a bet > 0 on the winner horse\n\n        return (bet_amount > 0, horse);\n\n    }\n\n}\n\n\n\n// File: contracts\\HorseyToken.sol\n\n\n\ncontract RoyalStablesInterface {\n\n    \n\n    struct Horsey {\n\n        address race;\n\n        bytes32 dna;\n\n        uint8 feedingCounter;\n\n        uint8 tier;\n\n    }\n\n\n\n    mapping(uint256 => Horsey) public horseys;\n\n    mapping(address => uint32) public carrot_credits;\n\n    mapping(uint256 => string) public names;\n\n    address public master;\n\n\n\n    function getOwnedTokens(address eth_address) public view returns (uint256[]);\n\n    function storeName(uint256 tokenId, string newName) public;\n\n    function storeCarrotsCredit(address client, uint32 amount) public;\n\n    function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\n\n    function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\n\n    function modifyHorseyDna(uint256 tokenId, bytes32 dna) public;\n\n    function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public;\n\n    function modifyHorseyTier(uint256 tokenId, uint8 tier) public;\n\n    function unstoreHorsey(uint256 tokenId) public;\n\n    function ownerOf(uint256 tokenId) public returns (address);\n\n}\n\n\n\n/**\n\n    @title HorseyToken ERC721 Token\n\n    @dev Horse contract - horse derives fro AccessManager built on top of ERC721 token and uses \n\n    @dev EthorseHelpers and AccessManager\n\n*/\n\ncontract HorseyToken is EthorseHelpers,Pausable {\n\n    using SafeMath for uint256;\n\n\n\n    /// @dev called when someone claims a token\n\n    event Claimed(address raceAddress, address eth_address, uint256 tokenId);\n\n    \n\n    /// @dev called when someone starts a feeding process\n\n    event Feeding(uint256 tokenId);\n\n\n\n    /// @dev called when someone ends a feeding process\n\n    event ReceivedCarrot(uint256 tokenId, bytes32 newDna);\n\n\n\n    /// @dev called when someone fails to end a feeding on the 255 blocks timer\n\n    event FeedingFailed(uint256 tokenId);\n\n\n\n    /// @dev called when a horsey is renamed\n\n    event HorseyRenamed(uint256 tokenId, string newName);\n\n\n\n    /// @dev called when a horsey is freed for carrots\n\n    event HorseyFreed(uint256 tokenId);\n\n\n\n    /// @dev address of the RoyalStables\n\n    RoyalStablesInterface public stables;\n\n\n\n    ///@dev multiplier applied to carrots received from burning a horsey\n\n    uint8 public carrotsMultiplier = 1;\n\n\n\n    ///@dev multiplier applied to rarity bounds when feeding horsey\n\n    uint8 public rarityMultiplier = 1;\n\n\n\n    ///@dev fee to pay when claiming a token\n\n    uint256 public claimingFee = 0.008 ether;\n\n\n\n    /**\n\n        @dev Holds the necessary data to feed a horsey\n\n            The user has to create begin feeding and wait for the block\n\n            with the feeding transaction to be hashed\n\n            Only then he can stop the feeding\n\n    */\n\n    struct FeedingData {\n\n        uint256 blockNumber;    ///@dev Holds the block number where the feeding began\n\n        uint256 horsey;         ///@dev Holds the horsey id\n\n    }\n\n\n\n    /// @dev Maps a user to his pending feeding\n\n    mapping(address => FeedingData) public pendingFeedings;\n\n\n\n    /// @dev Stores the renaming fees per character a user has to pay upon renaming a horsey\n\n    uint256 public renamingCostsPerChar = 0.001 ether;\n\n\n\n    /**\n\n        @dev Contracts constructor\n\n            Initializes token data\n\n            is pausable,ownable\n\n        @param stablesAddress Address of the official RoyalStables contract\n\n    */\n\n    constructor(address stablesAddress) \n\n    EthorseHelpers() \n\n    Pausable() public {\n\n        stables = RoyalStablesInterface(stablesAddress);\n\n    }\n\n\n\n    /**\n\n        @dev Changes multiplier for rarity on feed\n\n        @param newRarityMultiplier The cost to charge in wei for each character of the name\n\n    */\n\n    function setRarityMultiplier(uint8 newRarityMultiplier) external \n\n    onlyOwner()  {\n\n        rarityMultiplier = newRarityMultiplier;\n\n    }\n\n\n\n    /**\n\n        @dev Sets a new muliplier for freeing a horse\n\n        @param newCarrotsMultiplier the new multiplier for feeding\n\n    */\n\n    function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external \n\n    onlyOwner()  {\n\n        carrotsMultiplier = newCarrotsMultiplier;\n\n    }\n\n\n\n    /**\n\n        @dev Sets a new renaming per character cost in wei\n\n            Any CLevel can call this function\n\n        @param newRenamingCost The cost to charge in wei for each character of the name\n\n    */\n\n    function setRenamingCosts(uint256 newRenamingCost) external \n\n    onlyOwner()  {\n\n        renamingCostsPerChar = newRenamingCost;\n\n    }\n\n\n\n    /**\n\n        @dev Sets a new claiming fee in wei\n\n            Any CLevel can call this function\n\n        @param newClaimingFee The cost to charge in wei for each claimed HRSY\n\n    */\n\n    function setClaimingCosts(uint256 newClaimingFee) external\n\n    onlyOwner()  {\n\n        claimingFee = newClaimingFee;\n\n    }\n\n\n\n    /**\n\n        @dev Allows to add a legit owner address for races validation\n\n        @param newAddress the dev address deploying BettingController to add\n\n    */\n\n    function addLegitDevAddress(address newAddress) external\n\n    onlyOwner() {\n\n        _addLegitOwner(newAddress);\n\n    }\n\n\n\n    /**\n\n        @dev Owner can withdraw the current balance\n\n    */\n\n    function withdraw() external \n\n    onlyOwner()  {\n\n        owner.transfer(address(this).balance); //throws on fail\n\n    }\n\n\n\n    //allows owner to add a horse name to the possible horses list (BTC,ETH,LTC,...)\n\n    /**\n\n        @dev Adds a new horse index to the possible horses list (BTC,ETH,LTC,...)\n\n            This is in case ethorse adds a new coin\n\n            Any CLevel can call this function\n\n        @param newHorse Index of the horse to add (same data type as the original ethorse erc20 contract code)\n\n    */\n\n    function addHorseIndex(bytes32 newHorse) external\n\n    onlyOwner() {\n\n        _addHorse(newHorse);\n\n    }\n\n\n\n    /**\n\n        @dev Gets the complete list of token ids which belongs to an address\n\n        @param eth_address The address you want to lookup owned tokens from\n\n        @return List of all owned by eth_address tokenIds\n\n    */\n\n    function getOwnedTokens(address eth_address) public view returns (uint256[]) {\n\n        return stables.getOwnedTokens(eth_address);\n\n    }\n\n    \n\n    /**\n\n        @dev Allows to check if an eth_address can claim a horsey from this contract\n\n            should we also check if already claimed here?\n\n        @param raceAddress The ethorse race you want to claim from\n\n        @param eth_address The users address you want to claim the token for\n\n        @return True only if eth_address is a winner of the race contract at raceAddress\n\n    */\n\n    function can_claim(address raceAddress, address eth_address) public view returns (bool) {\n\n        bool res;\n\n        (res,) = _isWinnerOf(raceAddress, eth_address);\n\n        return res;\n\n    }\n\n\n\n    /**\n\n        @dev Allows a user to claim a special horsey with the same dna as the race one\n\n            Cant be used on paused\n\n            The sender has to be a winner of the race and must never have claimed a special horsey from this race\n\n        @param raceAddress The race's address\n\n    */\n\n    function claim(address raceAddress) external payable\n\n    costs(claimingFee)\n\n    whenNotPaused()\n\n    {\n\n        //call _isWinnerOf with a 0 address to simply get the winner horse\n\n        bytes32 winner;\n\n        (,winner) = _isWinnerOf(raceAddress, address(0));\n\n        require(winner != bytes32(0),\"Winner is zero\");\n\n        require(can_claim(raceAddress, msg.sender),\"can_claim return false\");\n\n        //require(!exists(id)); should already be checked by mining function\n\n        uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);\n\n        emit Claimed(raceAddress, msg.sender, id);\n\n    }\n\n\n\n    /**\n\n        @dev Allows a user to give a horsey a name or rename it\n\n            This function is payable and its cost is renamingCostsPerChar * length(newname)\n\n            Cant be called while paused\n\n            If called with too low balance, the modifier will throw\n\n            If called with too much balance, we try to return the remaining funds back\n\n            Upon completion we update all ceos balances, maybe not very efficient?\n\n        @param tokenId ID of the horsey to rename\n\n        @param newName The name to give to the horsey\n\n    */\n\n    function renameHorsey(uint256 tokenId, string newName) external \n\n    whenNotPaused()\n\n    onlyOwnerOf(tokenId) \n\n    costs(renamingCostsPerChar * bytes(newName).length)\n\n    payable {\n\n        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;\n\n        //Return over paid amount to sender if necessary\n\n        if(msg.value > renamingFee) //overpaid\n\n        {\n\n            msg.sender.transfer(msg.value.sub(renamingFee));\n\n        }\n\n        //store the new name\n\n        stables.storeName(tokenId,newName);\n\n        emit HorseyRenamed(tokenId,newName);\n\n    }\n\n\n\n    /**\n\n        @dev Allows a user to burn a token he owns to get carrots\n\n            The mount of carrots given is equal to the horsey's feedingCounter upon burning\n\n            Cant be called on a horsey with a pending feeding\n\n            Cant be called while paused\n\n        @param tokenId ID of the token to burn\n\n    */\n\n    function freeForCarrots(uint256 tokenId) external \n\n    whenNotPaused()\n\n    onlyOwnerOf(tokenId) {\n\n        require(pendingFeedings[msg.sender].horsey != tokenId,\"\");\n\n        //credit carrots\n\n        uint8 feedingCounter;\n\n        (,,feedingCounter,) = stables.horseys(tokenId);\n\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));\n\n        stables.unstoreHorsey(tokenId);\n\n        emit HorseyFreed(tokenId);\n\n    }\n\n\n\n    /**\n\n        @dev Returns the amount of carrots the user owns\n\n            We have a getter to hide the carrots amount from public view\n\n        @return The current amount of carrot credits the sender owns \n\n    */\n\n    function getCarrotCredits() external view returns (uint32) {\n\n        return stables.carrot_credits(msg.sender);\n\n    }\n\n\n\n    /**\n\n        @dev Returns horsey data of a given token\n\n        @param tokenId ID of the horsey to fetch\n\n        @return (race address, dna, feedingCounter, name)\n\n    */\n\n    function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) {\n\n        RoyalStablesInterface.Horsey memory temp;\n\n        (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId);\n\n        return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId));\n\n    }\n\n\n\n    /**\n\n        @dev Allows to feed a horsey to increase its feedingCounter value\n\n            Gives a chance to get a rare trait\n\n            The amount of carrots required is the value of current feedingCounter\n\n            The carrots the user owns will be reduced accordingly upon success\n\n            Cant be called while paused\n\n        @param tokenId ID of the horsey to feed\n\n    */\n\n    function feed(uint256 tokenId) external \n\n    whenNotPaused()\n\n    onlyOwnerOf(tokenId) \n\n    carrotsMeetLevel(tokenId)\n\n    noFeedingInProgress()\n\n    {\n\n        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);\n\n        uint8 feedingCounter;\n\n        (,,feedingCounter,) = stables.horseys(tokenId);\n\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));\n\n        emit Feeding(tokenId);\n\n    }\n\n\n\n    /**\n\n        @dev Allows user to stop feeding a horsey\n\n            This will trigger a random rarity chance\n\n    */\n\n    function stopFeeding() external\n\n    feedingInProgress() returns (bool) {\n\n        uint256 blockNumber = pendingFeedings[msg.sender].blockNumber;\n\n        uint256 tokenId = pendingFeedings[msg.sender].horsey;\n\n        //you cant feed and stop feeding from the same block!\n\n        require(block.number - blockNumber >= 1,\"feeding and stop feeding are in same block\");\n\n\n\n        delete pendingFeedings[msg.sender];\n\n\n\n        //solidity only gives you access to the previous 256 blocks\n\n        //deny and remove this obsolete feeding if we cant fetch its blocks hash\n\n        if(block.number - blockNumber > 255) {\n\n            //the feeding is outdated = failed\n\n            //the user can feed again but he lost his carrots\n\n            emit FeedingFailed(tokenId);\n\n            return false; \n\n        }\n\n\n\n        //token could have been transfered in the meantime to someone else\n\n        if(stables.ownerOf(tokenId) != msg.sender) {\n\n            //the feeding is failed because the token no longer belongs to this user = failed\n\n            //the user has lost his carrots\n\n            emit FeedingFailed(tokenId);\n\n            return false; \n\n        }\n\n        \n\n        //call horsey generation with the claim block hash\n\n        _feed(tokenId, blockhash(blockNumber));\n\n        bytes32 dna;\n\n        (,dna,,) = stables.horseys(tokenId);\n\n        emit ReceivedCarrot(tokenId, dna);\n\n        return true;\n\n    }\n\n\n\n    /// @dev Only ether sent explicitly through the donation() function is accepted\n\n    function() external payable {\n\n        revert(\"Not accepting donations\");\n\n    }\n\n\n\n    /**\n\n        @dev Internal function to increase a horsey's rarity\n\n            Uses a random value to assess if the feeding process increases rarity\n\n            The chances of having a rarity increase are based on the current feedingCounter\n\n        @param tokenId ID of the token to \"feed\"\n\n        @param blockHash Hash of the block where the feeding began\n\n    */\n\n    function _feed(uint256 tokenId, bytes32 blockHash) internal {\n\n        //Grab the upperbound for probability 100,100\n\n        uint8 tier;\n\n        uint8 feedingCounter;\n\n        (,,feedingCounter,tier) = stables.horseys(tokenId);\n\n        uint256 probabilityByRarity = 10 ** (uint256(tier).add(1));\n\n        uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity;\n\n\n\n        //Scale probability based on horsey's level\n\n        if(randNum <= (feedingCounter * rarityMultiplier)){\n\n            _increaseRarity(tokenId, blockHash);\n\n        }\n\n\n\n        //Increment feedingCounter\n\n        //Maximum allowed is 255, which requires 32385 carrots, so we should never reach that\n\n        if(feedingCounter < 255) {\n\n            stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1);\n\n        }\n\n    }\n\n\n\n    /// @dev creates a special token id based on the race and the coin index\n\n    function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) {\n\n        return uint256(keccak256(abi.encodePacked(race, sender, coinIndex)));\n\n    }\n\n\n\n    /**\n\n        @dev Internal function to generate a SPECIAL horsey token\n\n            we then use the ERC721 inherited minting process\n\n            the dna is a bytes32 target for a keccak256. Not using blockhash\n\n            finaly, a bitmask zeros the first 2 bytes for rarity traits\n\n        @param race Address of the associated race\n\n        @param eth_address Address of the user to receive the token\n\n        @param coinIndex The index of the winning coin\n\n        @return ID of the token\n\n    */\n\n    function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) {\n\n        uint256 id = _makeSpecialId(race, eth_address, coinIndex);\n\n        //generate dna\n\n        bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16);\n\n         //storeHorsey checks if the token exists before minting already, so we dont have to here\n\n        stables.storeHorsey(eth_address,id,race,dna,1,0);\n\n        return id;\n\n    }\n\n    \n\n    /**\n\n        @dev Internal function called to increase a horsey rarity\n\n            We generate a random zeros mask with a single 1 in the leading 16 bits\n\n        @param tokenId Id of the token to increase rarity of\n\n        @param blockHash hash of the block where the feeding began\n\n    */\n\n    function _increaseRarity(uint256 tokenId, bytes32 blockHash) private {\n\n        uint8 tier;\n\n        bytes32 dna;\n\n        (,dna,,tier) = stables.horseys(tokenId);\n\n        if(tier < 255)\n\n            stables.modifyHorseyTier(tokenId,tier+1);\n\n        uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash)));\n\n        //this creates a mask of 256 bits such as one of the first 16 bits will be 1\n\n        bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240));\n\n        bytes32 newdna = dna | rarityMask; //apply mask to add the random flag\n\n        stables.modifyHorseyDna(tokenId,newdna);\n\n    }\n\n\n\n    /// @dev shifts a bytes32 left by n positions\n\n    function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) {\n\n        return bytes32(uint256(data)*(2 ** n));\n\n    }\n\n\n\n    /// @dev shifts a bytes32 right by n positions\n\n    function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) {\n\n        return bytes32(uint256(data)/(2 ** n));\n\n    }\n\n\n\n    /// @dev Modifier to ensure user can afford a rehorse\n\n    modifier carrotsMeetLevel(uint256 tokenId){\n\n        uint256 feedingCounter;\n\n        (,,feedingCounter,) = stables.horseys(tokenId);\n\n        require(feedingCounter <= stables.carrot_credits(msg.sender),\"Not enough carrots\");\n\n        _;\n\n    }\n\n\n\n    /// @dev insures the caller payed the required amount\n\n    modifier costs(uint256 amount) {\n\n        require(msg.value >= amount,\"Not enough funds\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires the address to be non null\n\n    modifier validAddress(address addr) {\n\n        require(addr != address(0),\"Address is zero\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires that the user isnt feeding a horsey already\n\n    modifier noFeedingInProgress() {\n\n        //if the key does not exit, then the default struct data is used where blockNumber is 0\n\n        require(pendingFeedings[msg.sender].blockNumber == 0,\"Already feeding\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires that the user isnt feeding a horsey already\n\n    modifier feedingInProgress() {\n\n        //if the key does not exit, then the default struct data is used where blockNumber is 0\n\n        require(pendingFeedings[msg.sender].blockNumber != 0,\"No pending feeding\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires that the user isnt feeding a horsey already\n\n    modifier onlyOwnerOf(uint256 tokenId) {\n\n        require(stables.ownerOf(tokenId) == msg.sender, \"Caller is not owner of this token\");\n\n        _;\n\n    }\n\n}\n\n\n\n// File: contracts\\HorseyPilot.sol\n\n\n\n/**\n\n    @title Adds rank management utilities and voting behavior\n\n    @dev Handles equities distribution and levels of access\n\n\n\n    EXCHANGE FUNCTIONS IT CAN CALL\n\n\n\n    setClaimingFee OK 5\n\n    setMarketFees OK 1\n\n    withdraw\n\n\n\n    TOKEN FUNCTIONS IT CAN CALL\n\n\n\n    setRenamingCosts OK 0\n\n    addHorseIndex OK 3\n\n    setCarrotsMultiplier 8\n\n    setRarityMultiplier 9\n\n    addLegitDevAddress 2\n\n    withdraw\n\n\n\n    PAUSING OK 4\n\n*/\n\n\n\ncontract HorseyPilot {\n\n    \n\n    using SafeMath for uint256;\n\n\n\n    /// @dev event that is fired when a new proposal is made\n\n    event NewProposal(uint8 methodId, uint parameter, address proposer);\n\n\n\n    /// @dev event that is fired when a proposal is accepted\n\n    event ProposalPassed(uint8 methodId, uint parameter, address proposer);\n\n\n\n    /// @dev minimum threshold that must be met in order to confirm\n\n    /// a contract update\n\n    uint8 constant votingThreshold = 2;\n\n\n\n    /// @dev minimum amount of time a proposal can live\n\n    /// after this time it can be forcefully invoked or killed by anyone\n\n    uint256 constant proposalLife = 7 days;\n\n\n\n    /// @dev amount of time until another proposal can be made\n\n    /// we use this to eliminate proposal spamming\n\n    uint256 constant proposalCooldown = 1 days;\n\n\n\n    /// @dev used to reference the exact time the last proposal vetoed\n\n    uint256 cooldownStart;\n\n\n\n    /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles.\n\n    address public jokerAddress;\n\n    address public knightAddress;\n\n    address public paladinAddress;\n\n\n\n    /// @dev List of all addresses allowed to vote\n\n    address[3] public voters;\n\n\n\n    /// @dev joker is the pool and gets the rest\n\n    uint8 constant public knightEquity = 40;\n\n    uint8 constant public paladinEquity = 10;\n\n\n\n    /// @dev deployed exchange and token addresses\n\n    address public exchangeAddress;\n\n    address public tokenAddress;\n\n\n\n    /// @dev Mapping to keep track of pending balance of contract owners\n\n    mapping(address => uint) internal _cBalance;\n\n\n\n    /// @dev Encapsulates information about a proposed update\n\n    struct Proposal{\n\n        address proposer;           /// @dev address of the CEO at the origin of this proposal\n\n        uint256 timestamp;          /// @dev the time at which this propsal was made\n\n        uint256 parameter;          /// @dev parameters associated with proposed method invocation\n\n        uint8   methodId;           /// @dev id maps to function 0:rename horse, 1:change fees, 2:?    \n\n        address[] yay;              /// @dev list of all addresses who voted     \n\n        address[] nay;              /// @dev list of all addresses who voted against     \n\n    }\n\n\n\n    /// @dev the pending proposal\n\n    Proposal public currentProposal;\n\n\n\n    /// @dev true if the proposal is waiting for votes\n\n    bool public proposalInProgress = false;\n\n\n\n    /// @dev Value to keep track of avaible balance\n\n    uint256 public toBeDistributed;\n\n\n\n    /// @dev used to deploy contracts only once\n\n    bool deployed = false;\n\n\n\n    /**\n\n        @param _jokerAddress joker\n\n        @param _knightAddress knight\n\n        @param _paladinAddress paladin\n\n        @param _voters list of all allowed voting addresses\n\n    */\n\n    constructor(\n\n    address _jokerAddress,\n\n    address _knightAddress,\n\n    address _paladinAddress,\n\n    address[3] _voters\n\n    ) public {\n\n        jokerAddress = _jokerAddress;\n\n        knightAddress = _knightAddress;\n\n        paladinAddress = _paladinAddress;\n\n\n\n        for(uint i = 0; i < 3; i++) {\n\n            voters[i] = _voters[i];\n\n        }\n\n\n\n        //Set cooldown start to 1 day ago so that cooldown is irrelevant\n\n        cooldownStart = block.timestamp - proposalCooldown;\n\n    }\n\n\n\n    /**\n\n        @dev Used to deploy children contracts as a one shot call\n\n    */\n\n    function deployChildren(address stablesAddress) external {\n\n        require(!deployed,\"already deployed\");\n\n        // deploy token and exchange contracts\n\n        exchangeAddress = new HorseyExchange();\n\n        tokenAddress = new HorseyToken(stablesAddress);\n\n\n\n        // the exchange requires horsey token address\n\n        HorseyExchange(exchangeAddress).setStables(stablesAddress);\n\n\n\n        deployed = true;\n\n    }\n\n\n\n    /**\n\n        @dev Transfers joker ownership to a new address\n\n        @param newJoker the new address\n\n    */\n\n    function transferJokerOwnership(address newJoker) external \n\n    validAddress(newJoker) {\n\n        require(jokerAddress == msg.sender,\"Not right role\");\n\n        _moveBalance(newJoker);\n\n        jokerAddress = newJoker;\n\n    }\n\n\n\n    /**\n\n        @dev Transfers knight ownership to a new address\n\n        @param newKnight the new address\n\n    */\n\n    function transferKnightOwnership(address newKnight) external \n\n    validAddress(newKnight) {\n\n        require(knightAddress == msg.sender,\"Not right role\");\n\n        _moveBalance(newKnight);\n\n        knightAddress = newKnight;\n\n    }\n\n\n\n    /**\n\n        @dev Transfers paladin ownership to a new address\n\n        @param newPaladin the new address\n\n    */\n\n    function transferPaladinOwnership(address newPaladin) external \n\n    validAddress(newPaladin) {\n\n        require(paladinAddress == msg.sender,\"Not right role\");\n\n        _moveBalance(newPaladin);\n\n        paladinAddress = newPaladin;\n\n    }\n\n\n\n    /**\n\n        @dev Allow CEO to withdraw from pending value always checks to update redist\n\n            We ONLY redist when a user tries to withdraw so we are not redistributing\n\n            on every payment\n\n        @param destination The address to send the ether to\n\n    */\n\n    function withdrawCeo(address destination) external \n\n    onlyCLevelAccess()\n\n    validAddress(destination) {\n\n        //Check that pending balance can be redistributed - if so perform\n\n        //this procedure\n\n        if(toBeDistributed > 0){\n\n            _updateDistribution();\n\n        }\n\n        \n\n        //Grab the balance of this CEO \n\n        uint256 balance = _cBalance[msg.sender];\n\n        \n\n        //If we have non-zero balance, CEO may withdraw from pending amount\n\n        if(balance > 0 && (address(this).balance >= balance)) {\n\n            destination.transfer(balance); //throws on fail\n\n            _cBalance[msg.sender] = 0;\n\n        }\n\n    }\n\n\n\n    /// @dev acquire funds from owned contracts\n\n    function syncFunds() external {\n\n        uint256 prevBalance = address(this).balance;\n\n        HorseyToken(tokenAddress).withdraw();\n\n        HorseyExchange(exchangeAddress).withdraw();\n\n        uint256 newBalance = address(this).balance;\n\n        //add to\n\n        toBeDistributed = toBeDistributed.add(newBalance - prevBalance);\n\n    }\n\n\n\n    /// @dev allows a noble to access his holdings\n\n    function getNobleBalance() external view\n\n    onlyCLevelAccess() returns (uint256) {\n\n        return _cBalance[msg.sender];\n\n    }\n\n\n\n    /**\n\n        @dev Make a proposal and add to pending proposals\n\n        @param methodId a string representing the function ie. 'renameHorsey()'\n\n        @param parameter parameter to be used if invocation is approved\n\n    */\n\n    function makeProposal( uint8 methodId, uint256 parameter ) external\n\n    onlyCLevelAccess()\n\n    proposalAvailable()\n\n    cooledDown()\n\n    {\n\n        currentProposal.timestamp = block.timestamp;\n\n        currentProposal.parameter = parameter;\n\n        currentProposal.methodId = methodId;\n\n        currentProposal.proposer = msg.sender;\n\n        delete currentProposal.yay;\n\n        delete currentProposal.nay;\n\n        proposalInProgress = true;\n\n        \n\n        emit NewProposal(methodId,parameter,msg.sender);\n\n    }\n\n\n\n    /**\n\n        @dev Call to vote on a pending proposal\n\n    */\n\n    function voteOnProposal(bool voteFor) external \n\n    proposalPending()\n\n    onlyVoters()\n\n    notVoted() {\n\n        //cant vote on expired!\n\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n\n        if(voteFor)\n\n        {\n\n            currentProposal.yay.push(msg.sender);\n\n            //Proposal went through? invoke it\n\n            if( currentProposal.yay.length >= votingThreshold )\n\n            {\n\n                _doProposal();\n\n                proposalInProgress = false;\n\n                //no need to reset cooldown on successful proposal\n\n                return;\n\n            }\n\n\n\n        } else {\n\n            currentProposal.nay.push(msg.sender);\n\n            //Proposal failed?\n\n            if( currentProposal.nay.length >= votingThreshold )\n\n            {\n\n                proposalInProgress = false;\n\n                cooldownStart = block.timestamp;\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n        @dev Helps moving pending balance from one role to another\n\n        @param newAddress the address to transfer the pending balance from the msg.sender account\n\n    */\n\n    function _moveBalance(address newAddress) internal\n\n    validAddress(newAddress) {\n\n        require(newAddress != msg.sender); /// @dev IMPORTANT or else the account balance gets reset here!\n\n        _cBalance[newAddress] = _cBalance[msg.sender];\n\n        _cBalance[msg.sender] = 0;\n\n    }\n\n\n\n    /**\n\n        @dev Called at the start of withdraw to distribute any pending balances that live in the contract\n\n            will only ever be called if balance is non-zero (funds should be distributed)\n\n    */\n\n    function _updateDistribution() internal {\n\n        require(toBeDistributed != 0,\"nothing to distribute\");\n\n        uint256 knightPayday = toBeDistributed.div(100).mul(knightEquity);\n\n        uint256 paladinPayday = toBeDistributed.div(100).mul(paladinEquity);\n\n\n\n        /// @dev due to the equities distribution, queen gets the remaining value\n\n        uint256 jokerPayday = toBeDistributed.sub(knightPayday).sub(paladinPayday);\n\n\n\n        _cBalance[jokerAddress] = _cBalance[jokerAddress].add(jokerPayday);\n\n        _cBalance[knightAddress] = _cBalance[knightAddress].add(knightPayday);\n\n        _cBalance[paladinAddress] = _cBalance[paladinAddress].add(paladinPayday);\n\n        //Reset balance to 0\n\n        toBeDistributed = 0;\n\n    }\n\n\n\n    /**\n\n        @dev Execute the proposal\n\n    */\n\n    function _doProposal() internal {\n\n        /// UPDATE the renaming cost\n\n        if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter);\n\n        \n\n        /// UPDATE the market fees\n\n        if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter);\n\n\n\n        /// UPDATE the legit dev addresses list\n\n        if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitDevAddress(address(currentProposal.parameter));\n\n\n\n        /// ADD a horse index to exchange\n\n        if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter));\n\n\n\n        /// PAUSE/UNPAUSE the dApp\n\n        if( currentProposal.methodId == 4 ) {\n\n            if(currentProposal.parameter == 0) {\n\n                HorseyExchange(exchangeAddress).unpause();\n\n                HorseyToken(tokenAddress).unpause();\n\n            } else {\n\n                HorseyExchange(exchangeAddress).pause();\n\n                HorseyToken(tokenAddress).pause();\n\n            }\n\n        }\n\n\n\n        /// UPDATE the claiming fees\n\n        if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter);\n\n\n\n        /// UPDATE carrots multiplier\n\n        if( currentProposal.methodId == 8 ){\n\n            HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter));\n\n        }\n\n\n\n        /// UPDATE rarity multiplier\n\n        if( currentProposal.methodId == 9 ){\n\n            HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter));\n\n        }\n\n\n\n        emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer);\n\n    }\n\n\n\n    /// @dev requires the address to be non null\n\n    modifier validAddress(address addr) {\n\n        require(addr != address(0),\"Address is zero\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires the sender to be on the contract owners list\n\n    modifier onlyCLevelAccess() {\n\n        require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),\"not c level\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires that a proposal is not in process or has exceeded its lifetime, and has cooled down\n\n    /// after being vetoed\n\n    modifier proposalAvailable(){\n\n        require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),\"proposal already pending\");\n\n        _;\n\n    }\n\n\n\n    // @dev requries that if this proposer was the last proposer, that he or she has reached the \n\n    // cooldown limit\n\n    modifier cooledDown( ){\n\n        if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){\n\n            revert(\"Cool down period not passed yet\");\n\n        }\n\n        _;\n\n    }\n\n\n\n    /// @dev requires a proposal to be active\n\n    modifier proposalPending() {\n\n        require(proposalInProgress,\"no proposal pending\");\n\n        _;\n\n    }\n\n\n\n    /// @dev requires the voter to not have voted already\n\n    modifier notVoted() {\n\n        uint256 length = currentProposal.yay.length;\n\n        for(uint i = 0; i < length; i++) {\n\n            if(currentProposal.yay[i] == msg.sender) {\n\n                revert(\"Already voted\");\n\n            }\n\n        }\n\n\n\n        length = currentProposal.nay.length;\n\n        for(i = 0; i < length; i++) {\n\n            if(currentProposal.nay[i] == msg.sender) {\n\n                revert(\"Already voted\");\n\n            }\n\n        }\n\n        _;\n\n    }\n\n\n\n    /// @dev requires the voter to not have voted already\n\n    modifier onlyVoters() {\n\n        bool found = false;\n\n        uint256 length = voters.length;\n\n        for(uint i = 0; i < length; i++) {\n\n            if(voters[i] == msg.sender) {\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if(!found) {\n\n            revert(\"not a voter\");\n\n        }\n\n        _;\n\n    }\n\n}"
  },
  {
    "id": 13,
    "addr4sss": "0x0002562b9c0a85ebb92989fc02d6486b3d0ccbeb",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.11;\n\n\n\n\n\n/**\n\n * Math operations with safety checks\n\n */\n\nlibrary SafeMath {\n\n  function mul(uint a, uint b) internal returns (uint) {\n\n    uint c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint a, uint b) internal returns (uint) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint a, uint b) internal returns (uint) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint a, uint b) internal returns (uint) {\n\n    uint c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n\n    return a >= b ? a : b;\n\n  }\n\n\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n\n    return a < b ? a : b;\n\n  }\n\n\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    return a >= b ? a : b;\n\n  }\n\n\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    return a < b ? a : b;\n\n  }\n\n\n\n  function assert(bool assertion) internal {\n\n    if (!assertion) {\n\n      throw;\n\n    }\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20Basic {\n\n  uint public totalSupply;\n\n  function balanceOf(address who) constant returns (uint);\n\n  function transfer(address to, uint value);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n}\n\n\n\n\n\n/**\n\n * @title Basic token\n\n * @dev Basic version of StandardToken, with no allowances.\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint;\n\n\n\n  mapping(address => uint) balances;\n\n\n\n  /**\n\n   * @dev Fix for the ERC20 short address attack.\n\n   */\n\n  modifier onlyPayloadSize(uint size) {\n\n     if(msg.data.length < size + 4) {\n\n       throw;\n\n     }\n\n     _;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function transferFrom(address from, address to, uint value);\n\n  function approve(address spender, uint value);\n\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n}\n\n\n\n\n\n/**\n\n * @title Standard ERC20 token\n\n *\n\n * @dev Implemantation of the basic standart token.\n\n * @dev https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract StandardToken is BasicToken, ERC20 {\n\n\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint the amout of tokens to be transfered\n\n   */\n\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\n    // if (_value > _allowance) throw;\n\n\n\n    balances[_to] = balances[_to].add(_value);\n\n    balances[_from] = balances[_from].sub(_value);\n\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n\n    Transfer(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint _value) {\n\n\n\n    // To change the approve amount you first have to reduce the addresses`\n\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n    //  already 0 to mitigate the race condition described here:\n\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    if (msg.sender != owner) {\n\n      throw;\n\n    }\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner {\n\n    if (newOwner != address(0)) {\n\n      owner = newOwner;\n\n    }\n\n  }\n\n\n\n}\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev modifier to allow actions only when the contract IS paused\n\n   */\n\n  modifier whenNotPaused() {\n\n    if (paused) throw;\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev modifier to allow actions only when the contract IS NOT paused\n\n   */\n\n  modifier whenPaused {\n\n    if (!paused) throw;\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused returns (bool) {\n\n    paused = true;\n\n    Pause();\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused returns (bool) {\n\n    paused = false;\n\n    Unpause();\n\n    return true;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * Pausable token\n\n *\n\n * Simple ERC20 Token example, with pausable token creation\n\n **/\n\n\n\ncontract PausableToken is StandardToken, Pausable {\n\n\n\n  function transfer(address _to, uint _value) whenNotPaused {\n\n    super.transfer(_to, _value);\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused {\n\n    super.transferFrom(_from, _to, _value);\n\n  }\n\n}\n\n\n\n\n\n\n\ncontract DMAToken is PausableToken {\n\n  using SafeMath for uint256;  \n\n  string public name = \"DataMiningAlliance\";\n\n  string public symbol = \"DMA\";\n\n  uint public decimals = 8;\n\n  function DMAToken(){\n\n\ttotalSupply = 500000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n\n    balances[msg.sender] = totalSupply;                // Give the creator all initial tokens\n\n\tTransfer(address(0x0), msg.sender, totalSupply);\n\n  }\n\n\n\n}"
  },
  {
    "id": 14,
    "addr4sss": "0x00059ae69c1622a7542edc15e8d17b060fe307b6",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n\n\n\n\ncontract Consts {\n\n    string constant TOKEN_NAME = \"AmonD\";\n\n    string constant TOKEN_SYMBOL = \"AMON\";\n\n    uint8 constant TOKEN_DECIMALS = 18;\n\n    uint256 constant TOKEN_AMOUNT = 7600000000;\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n    address public owner;\n\n\n\n\n\n    event OwnershipRenounced(address indexed previousOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n    /**\n\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n     * account.\n\n     */\n\n    constructor() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    /**\n\n     * @dev Throws if called by any account other than the owner.\n\n     */\n\n    modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n     * @param newOwner The address to transfer ownership to.\n\n     */\n\n    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n\n    }\n\n\n\n    /**\n\n     * @dev Allows the current owner to relinquish control of the contract.\n\n     */\n\n    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/179\n\n */\n\ncontract ERC20Basic {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n    /**\n\n      * @dev Multiplies two numbers, throws on overflow.\n\n      */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        // uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return a / b;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, throws on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n        c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}\n\n\n\n\n\n/**\n\n * @title Basic tokens\n\n * @dev Basic version of StandardToken, with no allowances.\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n    using SafeMath for uint256;\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    uint256 totalSupply_;\n\n\n\n    /**\n\n    * @dev total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n\n    }\n\n\n\n    /**\n\n    * @dev transfer tokens for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\n/**\n\n * @title Standard ERC20 tokens\n\n *\n\n * @dev Implementation of the basic standard tokens.\n\n * @dev https://github.com/ethereum/EIPs/issues/20\n\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n\n */\n\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n    /**\n\n     * @dev Transfer tokens from one address to another\n\n     * @param _from address The address which you want to send tokens from\n\n     * @param _to address The address which you want to transfer to\n\n     * @param _value uint256 the amount of tokens to be transferred\n\n     */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n     *\n\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _value The amount of tokens to be spent.\n\n     */\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n     * @param _owner address The address which owns the funds.\n\n     * @param _spender address The address which will spend the funds.\n\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n\n     */\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n\n    /**\n\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n     *\n\n     * approve should be called when allowed[_spender] == 0. To increment\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _addedValue The amount of tokens to increase the allowance by.\n\n     */\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n     *\n\n     * approve should be called when allowed[_spender] == 0. To decrement\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n     */\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n        uint oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n}\n\n\n\n\n\n/**\n\n * @title FreezableToken\n\n * @dev Freeze transfer of the specific addresses, if the address is hacked\n\n */\n\ncontract FreezableToken is StandardToken, Ownable {\n\n    mapping (address => bool) public freezeAddresses;\n\n\n\n    event FreezableAddressAdded(address indexed addr);\n\n    event FreezableAddressRemoved(address indexed addr);\n\n\n\n    function addFreezableAddresses(address[] addrs) public onlyOwner returns(bool success) {\n\n        for (uint256 i = 0; i < addrs.length; i++) {\n\n            if (addFreezableAddress(addrs[i])) {\n\n                success = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    function addFreezableAddress(address addr) public onlyOwner returns(bool success) {\n\n        if (!freezeAddresses[addr]) {\n\n            freezeAddresses[addr] = true;\n\n            emit FreezableAddressAdded(addr);\n\n            success = true;\n\n        }\n\n    }\n\n\n\n    function removeFreezableAddresses(address[] addrs) public onlyOwner returns(bool success) {\n\n        for (uint256 i = 0; i < addrs.length; i++) {\n\n            if (removeFreezableAddress(addrs[i])) {\n\n                success = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    function removeFreezableAddress(address addr) public onlyOwner returns(bool success) {\n\n        if (freezeAddresses[addr]) {\n\n            freezeAddresses[addr] = false;\n\n            emit FreezableAddressRemoved(addr);\n\n            success = true;\n\n        }\n\n    }\n\n\n\n    /**\n\n    */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n        require(!freezeAddresses[_from]);\n\n        require(!freezeAddresses[_to]);\n\n        return super.transferFrom(_from, _to, _value);\n\n    }\n\n\n\n    /**\n\n    */\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(!freezeAddresses[msg.sender]);\n\n        require(!freezeAddresses[_to]);\n\n        return super.transfer(_to, _value);\n\n    }\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title TransferableToken\n\n */\n\ncontract TransferableToken is StandardToken, Ownable {\n\n    bool public isLock;\n\n\n\n    mapping (address => bool) public transferableAddresses;\n\n\n\n    constructor() public {\n\n        isLock = true;\n\n        transferableAddresses[msg.sender] = true;\n\n    }\n\n\n\n    event Unlock();\n\n    event TransferableAddressAdded(address indexed addr);\n\n    event TransferableAddressRemoved(address indexed addr);\n\n\n\n    function unlock() public onlyOwner {\n\n        isLock = false;\n\n        emit Unlock();\n\n    }\n\n\n\n    function isTransferable(address addr) public view returns(bool) {\n\n        return !isLock || transferableAddresses[addr];\n\n    }\n\n\n\n    function addTransferableAddresses(address[] addrs) public onlyOwner returns(bool success) {\n\n        for (uint256 i = 0; i < addrs.length; i++) {\n\n            if (addTransferableAddress(addrs[i])) {\n\n                success = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    function addTransferableAddress(address addr) public onlyOwner returns(bool success) {\n\n        if (!transferableAddresses[addr]) {\n\n            transferableAddresses[addr] = true;\n\n            emit TransferableAddressAdded(addr);\n\n            success = true;\n\n        }\n\n    }\n\n\n\n    function removeTransferableAddresses(address[] addrs) public onlyOwner returns(bool success) {\n\n        for (uint256 i = 0; i < addrs.length; i++) {\n\n            if (removeTransferableAddress(addrs[i])) {\n\n                success = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    function removeTransferableAddress(address addr) public onlyOwner returns(bool success) {\n\n        if (transferableAddresses[addr]) {\n\n            transferableAddresses[addr] = false;\n\n            emit TransferableAddressRemoved(addr);\n\n            success = true;\n\n        }\n\n    }\n\n\n\n    /**\n\n    */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n        require(isTransferable(_from));\n\n        return super.transferFrom(_from, _to, _value);\n\n    }\n\n\n\n    /**\n\n    */\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(isTransferable(msg.sender));\n\n        return super.transfer(_to, _value);\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n    event Pause();\n\n    event Unpause();\n\n\n\n    bool public paused = false;\n\n\n\n\n\n    /**\n\n     * @dev Modifier to make a function callable only when the contract is not paused.\n\n     */\n\n    modifier whenNotPaused() {\n\n        require(!paused);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Modifier to makeWhitelist a function callable only when the contract is paused.\n\n     */\n\n    modifier whenPaused() {\n\n        require(paused);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev called by the owner to pause, triggers stopped state\n\n     */\n\n    function pause() onlyOwner whenNotPaused public {\n\n        paused = true;\n\n        emit Pause();\n\n    }\n\n\n\n    /**\n\n     * @dev called by the owner to unpause, returns to normal state\n\n     */\n\n    function unpause() onlyOwner whenPaused public {\n\n        paused = false;\n\n        emit Unpause();\n\n    }\n\n}\n\n\n\n\n\n/**\n\n * @title Pausable tokens\n\n * @dev StandardToken modified with pausable transfers.\n\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n\n\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n        return super.transfer(_to, _value);\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n\n        return super.transferFrom(_from, _to, _value);\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n\n        return super.approve(_spender, _value);\n\n    }\n\n\n\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n\n        return super.increaseApproval(_spender, _addedValue);\n\n    }\n\n\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n\n        return super.decreaseApproval(_spender, _subtractedValue);\n\n    }\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Mintable token\n\n * @dev Simple ERC20 Token example, with mintable token creation\n\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n\n */\n\ncontract MintableToken is StandardToken, Ownable {\n\n    event Mint(address indexed to, uint256 amount);\n\n    event MintFinished();\n\n\n\n    bool public mintingFinished = false;\n\n\n\n\n\n    modifier canMint() {\n\n        require(!mintingFinished);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Function to mint tokens\n\n     * @param _to The address that will receive the minted tokens.\n\n     * @param _amount The amount of tokens to mint.\n\n     * @return A boolean that indicates if the operation was successful.\n\n     */\n\n    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n\n        totalSupply_ = totalSupply_.add(_amount);\n\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Mint(_to, _amount);\n\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Function to stop minting new tokens.\n\n     * @return True if the operation was successful.\n\n     */\n\n    function finishMinting() onlyOwner canMint public returns (bool) {\n\n        mintingFinished = true;\n\n        emit MintFinished();\n\n        return true;\n\n    }\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Burnable Token\n\n * @dev Token that can be irreversibly burned (destroyed).\n\n */\n\ncontract BurnableToken is BasicToken, Pausable {\n\n\n\n    event Burn(address indexed burner, uint256 value);\n\n\n\n    /**\n\n     * @dev Burns a specific amount of tokens.\n\n     * @param _value The amount of tokens to be burned.\n\n     */\n\n    function burn(uint256 _value) whenNotPaused public {\n\n        _burn(msg.sender, _value);\n\n    }\n\n\n\n    function _burn(address _who, uint256 _value) internal {\n\n        require(_value <= balances[_who]);\n\n        // no need to require value <= totalSupply, since that would imply the\n\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n        balances[_who] = balances[_who].sub(_value);\n\n        totalSupply_ = totalSupply_.sub(_value);\n\n        emit Burn(_who, _value);\n\n        emit Transfer(_who, address(0), _value);\n\n    }\n\n}\n\n\n\n\n\n/**\n\n * @title MainToken\n\n */\n\ncontract MainToken is Consts, FreezableToken, TransferableToken, PausableToken, MintableToken, BurnableToken {\n\n    string public constant name = TOKEN_NAME; // solium-disable-line uppercase\n\n    string public constant symbol = TOKEN_SYMBOL; // solium-disable-line uppercase\n\n    uint8 public constant decimals = TOKEN_DECIMALS; // solium-disable-line uppercase\n\n\n\n    uint256 public constant INITIAL_SUPPLY = TOKEN_AMOUNT * (10 ** uint256(decimals));\n\n\n\n    constructor() public {\n\n        totalSupply_ = INITIAL_SUPPLY;\n\n        balances[msg.sender] = INITIAL_SUPPLY;\n\n        emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\n    }\n\n}"
  },
  {
    "id": 15,
    "addr4sss": "0x000621424c60951cb69e9d75d64b79813846d498",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.13;\n\n\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner {\n\n    if (newOwner != address(0)) {\n\n      owner = newOwner;\n\n    }\n\n  }\n\n\n\n}\n\n\n\ncontract Destructible is Ownable {\n\n\n\n  function Destructible() payable { } \n\n\n\n  /**\n\n   * @dev Transfers the current balance to the owner and terminates the contract. \n\n   */\n\n  function destroy() onlyOwner {\n\n    selfdestruct(owner);\n\n  }\n\n\n\n  function destroyAndSend(address _recipient) onlyOwner {\n\n    selfdestruct(_recipient);\n\n  }\n\n}\n\n\n\ncontract HasNoEther is Ownable {\n\n\n\n  /**\n\n  * @dev Constructor that rejects incoming Ether\n\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n\n  * we could use assembly to access msg.value.\n\n  */\n\n  function HasNoEther() payable {\n\n    require(msg.value == 0);\n\n  }\n\n\n\n  /**\n\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\n\n   */\n\n  function() external {\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer all Ether held by the contract to the owner.\n\n   */\n\n  function reclaimEther() external onlyOwner {\n\n    assert(owner.send(this.balance));\n\n  }\n\n}\n\n\n\ncontract HasNoTokens is Ownable {\n\n\n\n /**\n\n  * @dev Reject all ERC23 compatible tokens\n\n  * @param from_ address The address that is transferring the tokens\n\n  * @param value_ uint256 the amount of the specified token\n\n  * @param data_ Bytes The data passed from the caller.\n\n  */\n\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n\n    revert();\n\n  }\n\n\n\n  /**\n\n   * @dev Reclaim all ERC20Basic compatible tokens\n\n   * @param tokenAddr address The address of the token contract\n\n   */\n\n  function reclaimToken(address tokenAddr) external onlyOwner {\n\n    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\n\n    uint256 balance = tokenInst.balanceOf(this);\n\n    tokenInst.transfer(owner, balance);\n\n  }\n\n}\n\n\n\ncontract ERC20Basic {\n\n  uint256 public totalSupply;\n\n  function balanceOf(address who) constant returns (uint256);\n\n  function transfer(address to, uint256 value) returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) returns (bool) {\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of. \n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) constant returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) returns (bool);\n\n  function approve(address spender, uint256 value) returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amout of tokens to be transfered\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\n    // require (_value <= _allowance);\n\n\n\n    balances[_to] = balances[_to].add(_value);\n\n    balances[_from] = balances[_from].sub(_value);\n\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) returns (bool) {\n\n\n\n    // To change the approve amount you first have to reduce the addresses`\n\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n    //  already 0 to mitigate the race condition described here:\n\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n}\n\n\n\ncontract WIZE is StandardToken, Ownable, Destructible, HasNoEther, HasNoTokens  {\n\n\n\n\tstring public name = \"WIZE\";\n\n\tstring public symbol = \"WIZE\";\n\n\tuint256 public decimals = 8;\n\n\n\n\tfunction WIZE() {\n\n\t\ttotalSupply = 100e6 * 10**decimals;\n\n\t\tbalances[0x14010814F3d6fBDe4970E4f7B36CdfFB23B5FA4A] = totalSupply;\n\n\t}\n\n\n\n}"
  },
  {
    "id": 16,
    "addr4sss": "0x00125893df6ca0792c99601c462764ba5d80268a",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n\n\ncontract owned {\n\n    constructor() public { owner = msg.sender; }\n\n\n\n    address owner;\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n}\n\n\n\n\n\ncontract ERC20 {\n\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n\n    function transfer(address to, uint256 tokens) public returns (bool success);\n\n}\n\n\n\n\n\ncontract GasManager is owned {\n\n\n\n    function () payable public {}\n\n\n\n    function sendInBatch(address[] toAddressList, uint256[] amountList) public onlyOwner {\n\n        require(toAddressList.length == amountList.length);\n\n\n\n        for (uint i = 0; i < toAddressList.length; i++) {\n\n            toAddressList[i].transfer(amountList[i]);\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 17,
    "addr4sss": "0x0013d3b508a23feeeca45c4c62cc88966fb71aed",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.23;\n\n\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/179\n\n */\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender)\n\n    public view returns (uint256);\n\n\n\n  function transferFrom(address from, address to, uint256 value)\n\n    public returns (bool);\n\n\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(\n\n    address indexed owner,\n\n    address indexed spender,\n\n    uint256 value\n\n  );\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n\n    // benefit is lost if 'b' is also tested.\n\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n\n\n    c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    // uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return a / b;\n\n  }\n\n\n\n  /**\n\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title Crowdsale\n\n * @dev Crowdsale is a base contract for managing a token crowdsale,\n\n * allowing investors to purchase tokens with ether. This contract implements\n\n * such functionality in its most fundamental form and can be extended to provide additional\n\n * functionality and/or custom behavior.\n\n * The external interface represents the basic interface for purchasing tokens, and conform\n\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\n\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n\n * the methods to add functionality. Consider using 'super' where appropiate to concatenate\n\n * behavior.\n\n */\n\ncontract Crowdsale {\n\n  using SafeMath for uint256;\n\n\n\n  // The token being sold\n\n  ERC20 public token;\n\n\n\n  // Address where funds are collected\n\n  address public wallet;\n\n\n\n  // How many token units a buyer gets per wei.\n\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\n\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\n\n  // 1 wei will give you 1 unit, or 0.001 TOK.\n\n  uint256 public rate;\n\n\n\n  // Amount of wei raised\n\n  uint256 public weiRaised;\n\n\n\n  /**\n\n   * Event for token purchase logging\n\n   * @param purchaser who paid for the tokens\n\n   * @param beneficiary who got the tokens\n\n   * @param value weis paid for purchase\n\n   * @param amount amount of tokens purchased\n\n   */\n\n  event TokenPurchase(\n\n    address indexed purchaser,\n\n    address indexed beneficiary,\n\n    uint256 value,\n\n    uint256 amount\n\n  );\n\n\n\n  /**\n\n   * @param _rate Number of token units a buyer gets per wei\n\n   * @param _wallet Address where collected funds will be forwarded to\n\n   * @param _token Address of the token being sold\n\n   */\n\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n\n    require(_rate > 0);\n\n    require(_wallet != address(0));\n\n    require(_token != address(0));\n\n\n\n    rate = _rate;\n\n    wallet = _wallet;\n\n    token = _token;\n\n  }\n\n\n\n  // -----------------------------------------\n\n  // Crowdsale external interface\n\n  // -----------------------------------------\n\n\n\n  /**\n\n   * @dev fallback function ***DO NOT OVERRIDE***\n\n   */\n\n  function () external payable {\n\n    buyTokens(msg.sender);\n\n  }\n\n\n\n  /**\n\n   * @dev low level token purchase ***DO NOT OVERRIDE***\n\n   * @param _beneficiary Address performing the token purchase\n\n   */\n\n  function buyTokens(address _beneficiary) public payable {\n\n\n\n    uint256 weiAmount = msg.value;\n\n    _preValidatePurchase(_beneficiary, weiAmount);\n\n\n\n    // calculate token amount to be created\n\n    uint256 tokens = _getTokenAmount(weiAmount);\n\n\n\n    // update state\n\n    weiRaised = weiRaised.add(weiAmount);\n\n\n\n    _processPurchase(_beneficiary, tokens);\n\n    emit TokenPurchase(\n\n      msg.sender,\n\n      _beneficiary,\n\n      weiAmount,\n\n      tokens\n\n    );\n\n\n\n    _updatePurchasingState(_beneficiary, weiAmount);\n\n\n\n    _forwardFunds();\n\n    _postValidatePurchase(_beneficiary, weiAmount);\n\n  }\n\n\n\n  // -----------------------------------------\n\n  // Internal interface (extensible)\n\n  // -----------------------------------------\n\n\n\n  /**\n\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n\n   * @param _beneficiary Address performing the token purchase\n\n   * @param _weiAmount Value in wei involved in the purchase\n\n   */\n\n  function _preValidatePurchase(\n\n    address _beneficiary,\n\n    uint256 _weiAmount\n\n  )\n\n    internal\n\n  {\n\n    require(_beneficiary != address(0));\n\n    require(_weiAmount != 0);\n\n  }\n\n\n\n  /**\n\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n\n   * @param _beneficiary Address performing the token purchase\n\n   * @param _weiAmount Value in wei involved in the purchase\n\n   */\n\n  function _postValidatePurchase(\n\n    address _beneficiary,\n\n    uint256 _weiAmount\n\n  )\n\n    internal\n\n  {\n\n    // optional override\n\n  }\n\n\n\n  /**\n\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n\n   * @param _beneficiary Address performing the token purchase\n\n   * @param _tokenAmount Number of tokens to be emitted\n\n   */\n\n  function _deliverTokens(\n\n    address _beneficiary,\n\n    uint256 _tokenAmount\n\n  )\n\n    internal\n\n  {\n\n    token.transfer(_beneficiary, _tokenAmount);\n\n  }\n\n\n\n  /**\n\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n\n   * @param _beneficiary Address receiving the tokens\n\n   * @param _tokenAmount Number of tokens to be purchased\n\n   */\n\n  function _processPurchase(\n\n    address _beneficiary,\n\n    uint256 _tokenAmount\n\n  )\n\n    internal\n\n  {\n\n    _deliverTokens(_beneficiary, _tokenAmount);\n\n  }\n\n\n\n  /**\n\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n\n   * @param _beneficiary Address receiving the tokens\n\n   * @param _weiAmount Value in wei involved in the purchase\n\n   */\n\n  function _updatePurchasingState(\n\n    address _beneficiary,\n\n    uint256 _weiAmount\n\n  )\n\n    internal\n\n  {\n\n    // optional override\n\n  }\n\n\n\n  /**\n\n   * @dev Override to extend the way in which ether is converted to tokens.\n\n   * @param _weiAmount Value in wei to be converted into tokens\n\n   * @return Number of tokens that can be purchased with the specified _weiAmount\n\n   */\n\n  function _getTokenAmount(uint256 _weiAmount)\n\n    internal view returns (uint256)\n\n  {\n\n    return _weiAmount.mul(rate);\n\n  }\n\n\n\n  /**\n\n   * @dev Determines how ETH is stored/forwarded on purchases.\n\n   */\n\n  function _forwardFunds() internal {\n\n    wallet.transfer(msg.value);\n\n  }\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n\n  event OwnershipTransferred(\n\n    address indexed previousOwner,\n\n    address indexed newOwner\n\n  );\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  constructor() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to relinquish control of the contract.\n\n   */\n\n  function renounceOwnership() public onlyOwner {\n\n    emit OwnershipRenounced(owner);\n\n    owner = address(0);\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param _newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n\n    _transferOwnership(_newOwner);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfers control of the contract to a newOwner.\n\n   * @param _newOwner The address to transfer ownership to.\n\n   */\n\n  function _transferOwnership(address _newOwner) internal {\n\n    require(_newOwner != address(0));\n\n    emit OwnershipTransferred(owner, _newOwner);\n\n    owner = _newOwner;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title TimedCrowdsale\n\n * @dev Crowdsale accepting contributions only within a time frame.\n\n */\n\ncontract TimedCrowdsale is Crowdsale {\n\n  using SafeMath for uint256;\n\n\n\n  uint256 public openingTime;\n\n  uint256 public closingTime;\n\n\n\n  /**\n\n   * @dev Reverts if not in crowdsale time range.\n\n   */\n\n  modifier onlyWhileOpen {\n\n    // solium-disable-next-line security/no-block-members\n\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Constructor, takes crowdsale opening and closing times.\n\n   * @param _openingTime Crowdsale opening time\n\n   * @param _closingTime Crowdsale closing time\n\n   */\n\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\n\n    // solium-disable-next-line security/no-block-members\n\n    require(_openingTime >= block.timestamp);\n\n    require(_closingTime >= _openingTime);\n\n\n\n    openingTime = _openingTime;\n\n    closingTime = _closingTime;\n\n  }\n\n\n\n  /**\n\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n\n   * @return Whether crowdsale period has elapsed\n\n   */\n\n  function hasClosed() public view returns (bool) {\n\n    // solium-disable-next-line security/no-block-members\n\n    return block.timestamp > closingTime;\n\n  }\n\n\n\n  /**\n\n   * @dev Extend parent behavior requiring to be within contributing period\n\n   * @param _beneficiary Token purchaser\n\n   * @param _weiAmount Amount of wei contributed\n\n   */\n\n  function _preValidatePurchase(\n\n    address _beneficiary,\n\n    uint256 _weiAmount\n\n  )\n\n    internal\n\n    onlyWhileOpen\n\n  {\n\n    super._preValidatePurchase(_beneficiary, _weiAmount);\n\n  }\n\n\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Basic token\n\n * @dev Basic version of StandardToken, with no allowances.\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  /**\n\n  * @dev total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title Standard ERC20 token\n\n *\n\n * @dev Implementation of the basic standard token.\n\n * @dev https://github.com/ethereum/EIPs/issues/20\n\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n\n */\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(\n\n    address _from,\n\n    address _to,\n\n    uint256 _value\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(_to != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    emit Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(\n\n    address _owner,\n\n    address _spender\n\n   )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(\n\n    address _spender,\n\n    uint _addedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    allowed[msg.sender][_spender] = (\n\n      allowed[msg.sender][_spender].add(_addedValue));\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(\n\n    address _spender,\n\n    uint _subtractedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title Mintable token\n\n * @dev Simple ERC20 Token example, with mintable token creation\n\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n\n */\n\ncontract MintableToken is StandardToken, Ownable {\n\n  event Mint(address indexed to, uint256 amount);\n\n  event MintFinished();\n\n\n\n  bool public mintingFinished = false;\n\n\n\n\n\n  modifier canMint() {\n\n    require(!mintingFinished);\n\n    _;\n\n  }\n\n\n\n  modifier hasMintPermission() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to mint tokens\n\n   * @param _to The address that will receive the minted tokens.\n\n   * @param _amount The amount of tokens to mint.\n\n   * @return A boolean that indicates if the operation was successful.\n\n   */\n\n  function mint(\n\n    address _to,\n\n    uint256 _amount\n\n  )\n\n    hasMintPermission\n\n    canMint\n\n    public\n\n    returns (bool)\n\n  {\n\n    totalSupply_ = totalSupply_.add(_amount);\n\n    balances[_to] = balances[_to].add(_amount);\n\n    emit Mint(_to, _amount);\n\n    emit Transfer(address(0), _to, _amount);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to stop minting new tokens.\n\n   * @return True if the operation was successful.\n\n   */\n\n  function finishMinting() onlyOwner canMint public returns (bool) {\n\n    mintingFinished = true;\n\n    emit MintFinished();\n\n    return true;\n\n  }\n\n}\n\n\n\n\n\ncontract FreezableToken is StandardToken {\n\n    // freezing chains\n\n    mapping (bytes32 => uint64) internal chains;\n\n    // freezing amounts for each chain\n\n    mapping (bytes32 => uint) internal freezings;\n\n    // total freezing balance per address\n\n    mapping (address => uint) internal freezingBalance;\n\n\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n\n    event Released(address indexed owner, uint amount);\n\n\n\n    /**\n\n     * @dev Gets the balance of the specified address include freezing tokens.\n\n     * @param _owner The address to query the the balance of.\n\n     * @return An uint256 representing the amount owned by the passed address.\n\n     */\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the balance of the specified address without freezing tokens.\n\n     * @param _owner The address to query the the balance of.\n\n     * @return An uint256 representing the amount owned by the passed address.\n\n     */\n\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n\n        return super.balanceOf(_owner);\n\n    }\n\n\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n\n        return freezingBalance[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev gets freezing count\n\n     * @param _addr Address of freeze tokens owner.\n\n     */\n\n    function freezingCount(address _addr) public view returns (uint count) {\n\n        uint64 release = chains[toKey(_addr, 0)];\n\n        while (release != 0) {\n\n            count++;\n\n            release = chains[toKey(_addr, release)];\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n\n     * @param _addr Address of freeze tokens owner.\n\n     * @param _index Freezing portion index. It ordered by release date descending.\n\n     */\n\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n\n        for (uint i = 0; i < _index + 1; i++) {\n\n            _release = chains[toKey(_addr, _release)];\n\n            if (_release == 0) {\n\n                return;\n\n            }\n\n        }\n\n        _balance = freezings[toKey(_addr, _release)];\n\n    }\n\n\n\n    /**\n\n     * @dev freeze your tokens to the specified address.\n\n     *      Be careful, gas usage is not deterministic,\n\n     *      and depends on how many freezes _to address already has.\n\n     * @param _to Address to which token will be freeze.\n\n     * @param _amount Amount of token to freeze.\n\n     * @param _until Release date, must be in future.\n\n     */\n\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n\n        require(_to != address(0));\n\n        require(_amount <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n\n\n        bytes32 currentKey = toKey(_to, _until);\n\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n\n\n        freeze(_to, _until);\n\n        emit Transfer(msg.sender, _to, _amount);\n\n        emit Freezed(_to, _until, _amount);\n\n    }\n\n\n\n    /**\n\n     * @dev release first available freezing tokens.\n\n     */\n\n    function releaseOnce() public {\n\n        bytes32 headKey = toKey(msg.sender, 0);\n\n        uint64 head = chains[headKey];\n\n        require(head != 0);\n\n        require(uint64(block.timestamp) > head);\n\n        bytes32 currentKey = toKey(msg.sender, head);\n\n\n\n        uint64 next = chains[currentKey];\n\n\n\n        uint amount = freezings[currentKey];\n\n        delete freezings[currentKey];\n\n\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n\n\n        if (next == 0) {\n\n            delete chains[headKey];\n\n        } else {\n\n            chains[headKey] = next;\n\n            delete chains[currentKey];\n\n        }\n\n        emit Released(msg.sender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n\n     * @return how many tokens was released\n\n     */\n\n    function releaseAll() public returns (uint tokens) {\n\n        uint release;\n\n        uint balance;\n\n        (release, balance) = getFreezing(msg.sender, 0);\n\n        while (release != 0 && block.timestamp > release) {\n\n            releaseOnce();\n\n            tokens += balance;\n\n            (release, balance) = getFreezing(msg.sender, 0);\n\n        }\n\n    }\n\n\n\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n\n        // WISH masc to increase entropy\n\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n\n        assembly {\n\n            result := or(result, mul(_addr, 0x10000000000000000))\n\n            result := or(result, _release)\n\n        }\n\n    }\n\n\n\n    function freeze(address _to, uint64 _until) internal {\n\n        require(_until > block.timestamp);\n\n        bytes32 key = toKey(_to, _until);\n\n        bytes32 parentKey = toKey(_to, uint64(0));\n\n        uint64 next = chains[parentKey];\n\n\n\n        if (next == 0) {\n\n            chains[parentKey] = _until;\n\n            return;\n\n        }\n\n\n\n        bytes32 nextKey = toKey(_to, next);\n\n        uint parent;\n\n\n\n        while (next != 0 && _until > next) {\n\n            parent = next;\n\n            parentKey = nextKey;\n\n\n\n            next = chains[nextKey];\n\n            nextKey = toKey(_to, next);\n\n        }\n\n\n\n        if (_until == next) {\n\n            return;\n\n        }\n\n\n\n        if (next != 0) {\n\n            chains[key] = next;\n\n        }\n\n\n\n        chains[parentKey] = _until;\n\n    }\n\n}\n\n\n\n\n\n/**\n\n * @title Burnable Token\n\n * @dev Token that can be irreversibly burned (destroyed).\n\n */\n\ncontract BurnableToken is BasicToken {\n\n\n\n  event Burn(address indexed burner, uint256 value);\n\n\n\n  /**\n\n   * @dev Burns a specific amount of tokens.\n\n   * @param _value The amount of token to be burned.\n\n   */\n\n  function burn(uint256 _value) public {\n\n    _burn(msg.sender, _value);\n\n  }\n\n\n\n  function _burn(address _who, uint256 _value) internal {\n\n    require(_value <= balances[_who]);\n\n    // no need to require value <= totalSupply, since that would imply the\n\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n    balances[_who] = balances[_who].sub(_value);\n\n    totalSupply_ = totalSupply_.sub(_value);\n\n    emit Burn(_who, _value);\n\n    emit Transfer(_who, address(0), _value);\n\n  }\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    emit Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    emit Unpause();\n\n  }\n\n}\n\n\n\n\n\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n\n    /**\n\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n\n     *      Be careful, gas usage is not deterministic,\n\n     *      and depends on how many freezes _to address already has.\n\n     * @param _to Address to which token will be freeze.\n\n     * @param _amount Amount of token to mint and freeze.\n\n     * @param _until Release date, must be in future.\n\n     * @return A boolean that indicates if the operation was successful.\n\n     */\n\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n\n        totalSupply_ = totalSupply_.add(_amount);\n\n\n\n        bytes32 currentKey = toKey(_to, _until);\n\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n\n\n        freeze(_to, _until);\n\n        emit Mint(_to, _amount);\n\n        emit Freezed(_to, _until, _amount);\n\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n\n    }\n\n}\n\n\n\n\n\n\n\ncontract Consts {\n\n    uint public constant TOKEN_DECIMALS = 18;\n\n    uint8 public constant TOKEN_DECIMALS_UINT8 = 18;\n\n    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n\n\n\n    string public constant TOKEN_NAME = \"CarnaLife Token\";\n\n    string public constant TOKEN_SYMBOL = \"CLC\";\n\n    bool public constant PAUSED = true;\n\n    address public constant TARGET_USER = 0x69D8fD25c05d07D3Fc5280040ba0BDe4d5C4d399;\n\n    \n\n    uint public constant START_TIME = 1550230200;\n\n    \n\n    bool public constant CONTINUE_MINTING = true;\n\n}\n\n\n\n\n\n\n\n\n\n/**\n\n * @title FinalizableCrowdsale\n\n * @dev Extension of Crowdsale where an owner can do extra work\n\n * after finishing.\n\n */\n\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n\n  using SafeMath for uint256;\n\n\n\n  bool public isFinalized = false;\n\n\n\n  event Finalized();\n\n\n\n  /**\n\n   * @dev Must be called after crowdsale ends, to do some extra finalization\n\n   * work. Calls the contract's finalization function.\n\n   */\n\n  function finalize() onlyOwner public {\n\n    require(!isFinalized);\n\n    require(hasClosed());\n\n\n\n    finalization();\n\n    emit Finalized();\n\n\n\n    isFinalized = true;\n\n  }\n\n\n\n  /**\n\n   * @dev Can be overridden to add finalization logic. The overriding function\n\n   * should call super.finalization() to ensure the chain of finalization is\n\n   * executed entirely.\n\n   */\n\n  function finalization() internal {\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title CappedCrowdsale\n\n * @dev Crowdsale with a limit for total contributions.\n\n */\n\ncontract CappedCrowdsale is Crowdsale {\n\n  using SafeMath for uint256;\n\n\n\n  uint256 public cap;\n\n\n\n  /**\n\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n\n   * @param _cap Max amount of wei to be contributed\n\n   */\n\n  constructor(uint256 _cap) public {\n\n    require(_cap > 0);\n\n    cap = _cap;\n\n  }\n\n\n\n  /**\n\n   * @dev Checks whether the cap has been reached.\n\n   * @return Whether the cap was reached\n\n   */\n\n  function capReached() public view returns (bool) {\n\n    return weiRaised >= cap;\n\n  }\n\n\n\n  /**\n\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\n\n   * @param _beneficiary Token purchaser\n\n   * @param _weiAmount Amount of wei contributed\n\n   */\n\n  function _preValidatePurchase(\n\n    address _beneficiary,\n\n    uint256 _weiAmount\n\n  )\n\n    internal\n\n  {\n\n    super._preValidatePurchase(_beneficiary, _weiAmount);\n\n    require(weiRaised.add(_weiAmount) <= cap);\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title MintedCrowdsale\n\n * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.\n\n * Token ownership should be transferred to MintedCrowdsale for minting.\n\n */\n\ncontract MintedCrowdsale is Crowdsale {\n\n\n\n  /**\n\n   * @dev Overrides delivery by minting tokens upon purchase.\n\n   * @param _beneficiary Token purchaser\n\n   * @param _tokenAmount Number of tokens to be minted\n\n   */\n\n  function _deliverTokens(\n\n    address _beneficiary,\n\n    uint256 _tokenAmount\n\n  )\n\n    internal\n\n  {\n\n    require(MintableToken(token).mint(_beneficiary, _tokenAmount));\n\n  }\n\n}\n\n\n\n\n\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n\n    \n\n{\n\n    \n\n\n\n    function name() public pure returns (string _name) {\n\n        return TOKEN_NAME;\n\n    }\n\n\n\n    function symbol() public pure returns (string _symbol) {\n\n        return TOKEN_SYMBOL;\n\n    }\n\n\n\n    function decimals() public pure returns (uint8 _decimals) {\n\n        return TOKEN_DECIMALS_UINT8;\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n\n        require(!paused);\n\n        return super.transferFrom(_from, _to, _value);\n\n    }\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n\n        require(!paused);\n\n        return super.transfer(_to, _value);\n\n    }\n\n\n\n    \n\n}\n\n\n\n\n\n\n\n\n\ncontract MainCrowdsale is Consts, FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale {\n\n    function hasStarted() public view returns (bool) {\n\n        return now >= openingTime;\n\n    }\n\n\n\n    function startTime() public view returns (uint256) {\n\n        return openingTime;\n\n    }\n\n\n\n    function endTime() public view returns (uint256) {\n\n        return closingTime;\n\n    }\n\n\n\n    function hasClosed() public view returns (bool) {\n\n        return super.hasClosed() || capReached();\n\n    }\n\n\n\n    function hasEnded() public view returns (bool) {\n\n        return hasClosed();\n\n    }\n\n\n\n    function finalization() internal {\n\n        super.finalization();\n\n\n\n        if (PAUSED) {\n\n            MainToken(token).unpause();\n\n        }\n\n\n\n        if (!CONTINUE_MINTING) {\n\n            require(MintableToken(token).finishMinting());\n\n        }\n\n\n\n        Ownable(token).transferOwnership(TARGET_USER);\n\n    }\n\n\n\n    /**\n\n     * @dev Override to extend the way in which ether is converted to tokens.\n\n     * @param _weiAmount Value in wei to be converted into tokens\n\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n\n     */\n\n    function _getTokenAmount(uint256 _weiAmount)\n\n        internal view returns (uint256)\n\n    {\n\n        return _weiAmount.mul(rate).div(1 ether);\n\n    }\n\n}\n\n\n\n\n\ncontract BonusableCrowdsale is Consts, Crowdsale {\n\n    /**\n\n     * @dev Override to extend the way in which ether is converted to tokens.\n\n     * @param _weiAmount Value in wei to be converted into tokens\n\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n\n     */\n\n    function _getTokenAmount(uint256 _weiAmount)\n\n        internal view returns (uint256)\n\n    {\n\n        uint256 bonusRate = getBonusRate(_weiAmount);\n\n        return _weiAmount.mul(bonusRate).div(1 ether);\n\n    }\n\n\n\n    function getBonusRate(uint256 _weiAmount) internal view returns (uint256) {\n\n        uint256 bonusRate = rate;\n\n\n\n        \n\n        // apply bonus for time & weiRaised\n\n        uint[2] memory weiRaisedStartsBounds = [uint(0),uint(0)];\n\n        uint[2] memory weiRaisedEndsBounds = [uint(700000000000000000000000),uint(700000000000000000000000)];\n\n        uint64[2] memory timeStartsBounds = [uint64(1550230200),uint64(1552597140)];\n\n        uint64[2] memory timeEndsBounds = [uint64(1552597140),uint64(1555189195)];\n\n        uint[2] memory weiRaisedAndTimeRates = [uint(100),uint(50)];\n\n\n\n        for (uint i = 0; i < 2; i++) {\n\n            bool weiRaisedInBound = (weiRaisedStartsBounds[i] <= weiRaised) && (weiRaised < weiRaisedEndsBounds[i]);\n\n            bool timeInBound = (timeStartsBounds[i] <= now) && (now < timeEndsBounds[i]);\n\n            if (weiRaisedInBound && timeInBound) {\n\n                bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;\n\n            }\n\n        }\n\n        \n\n\n\n        \n\n\n\n        return bonusRate;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\ncontract TemplateCrowdsale is Consts, MainCrowdsale\n\n    \n\n    , BonusableCrowdsale\n\n    \n\n    \n\n    \n\n    \n\n{\n\n    event Initialized();\n\n    event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);\n\n    bool public initialized = false;\n\n\n\n    constructor(MintableToken _token) public\n\n        Crowdsale(4000 * TOKEN_DECIMAL_MULTIPLIER, 0x8651Dbfa480fAC7721afB8fc75dd15df5C3FeeFF, _token)\n\n        TimedCrowdsale(START_TIME > now ? START_TIME : now, 1555189200)\n\n        CappedCrowdsale(700000000000000000000000)\n\n        \n\n    {\n\n    }\n\n\n\n    function init() public onlyOwner {\n\n        require(!initialized);\n\n        initialized = true;\n\n\n\n        if (PAUSED) {\n\n            MainToken(token).pause();\n\n        }\n\n\n\n        \n\n        address[5] memory addresses = [address(0x69d8fd25c05d07d3fc5280040ba0bde4d5c4d399),address(0xe011be20adc30aaea2def2b8df8d62f38dc6ce59),address(0x9e336bb3bb2e31c20f6728133d8b281760840437),address(0x109184b0c6d1bc3e5c6bda2a7fd5e58e86a2023d),address(0x7ae2620c28160446f140958c6fd5f9a8b3088c25)];\n\n        uint[5] memory amounts = [uint(2100000000000000000000000000),uint(1500000000000000000000000000),uint(800000000000000000000000000),uint(800000000000000000000000000),uint(2000000000000000000000000000)];\n\n        uint64[5] memory freezes = [uint64(1555189263),uint64(1555189263),uint64(1555189263),uint64(1555189263),uint64(1555189263)];\n\n\n\n        for (uint i = 0; i < addresses.length; i++) {\n\n            if (freezes[i] == 0) {\n\n                MainToken(token).mint(addresses[i], amounts[i]);\n\n            } else {\n\n                MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n\n            }\n\n        }\n\n        \n\n\n\n        transferOwnership(TARGET_USER);\n\n\n\n        emit Initialized();\n\n    }\n\n\n\n    \n\n    /**\n\n     * @dev override hasClosed to add minimal value logic\n\n     * @return true if remained to achieve less than minimal\n\n     */\n\n    function hasClosed() public view returns (bool) {\n\n        bool remainValue = cap.sub(weiRaised) < 250000000000000000;\n\n        return super.hasClosed() || remainValue;\n\n    }\n\n    \n\n\n\n    \n\n\n\n    \n\n    function setEndTime(uint _endTime) public onlyOwner {\n\n        // only if CS was not ended\n\n        require(now < closingTime);\n\n        // only if new end time in future\n\n        require(now < _endTime);\n\n        require(_endTime > openingTime);\n\n        emit TimesChanged(openingTime, _endTime, openingTime, closingTime);\n\n        closingTime = _endTime;\n\n    }\n\n    \n\n\n\n    \n\n\n\n    \n\n\n\n    \n\n    /**\n\n     * @dev override purchase validation to add extra value logic.\n\n     * @return true if sended more than minimal value\n\n     */\n\n    function _preValidatePurchase(\n\n        address _beneficiary,\n\n        uint256 _weiAmount\n\n    )\n\n        internal\n\n    {\n\n        \n\n        require(msg.value >= 250000000000000000);\n\n        \n\n        \n\n        require(msg.value <= 4000000000000000000000);\n\n        \n\n        super._preValidatePurchase(_beneficiary, _weiAmount);\n\n    }\n\n    \n\n}"
  },
  {
    "id": 18,
    "addr4sss": "0x001b22d44e1b8edf01c1bccd08bb99e2e6198092",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n \n\ncontract BCFVault {\n\n \n\n    using SafeMath for uint256;\n\n \n\n    mapping(address => uint256) investments;\n\n    mapping(address => uint256) joined;\n\n    mapping(address => uint256) withdrawals;\n\n    mapping(address => uint256) referrer;\n\n \n\n    uint256 public step = 1;\n\n    uint256 public minimum = 10 finney;\n\n    uint256 public stakingRequirement = 2 ether;\n\n    address public blueDividendAddr;\n\n    address public owner;\n\n \n\n    event Invest(address investor, uint256 amount);\n\n    event Withdraw(address investor, uint256 amount);\n\n    event Bounty(address hunter, uint256 amount);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n \n\n    /**\n\n     * @dev \u0421onstructor Sets the original roles of the contract\n\n     */\n\n \n\n    constructor() public {\n\n        owner = msg.sender;\n\n        blueDividendAddr = 0xB40b8e3C726155FF1c6EEBD22067436D0e2669dd;\n\n    }\n\n \n\n    /**\n\n     * @dev Modifiers\n\n     */\n\n \n\n    modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n \n\n    /**\n\n     * @dev Allows current owner to transfer control of the contract to a newOwner.\n\n     * @param newOwner The address to transfer ownership to.\n\n     */\n\n    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n\n    }\n\n \n\n    /**\n\n     * @dev Investments\n\n     */\n\n    function () public payable {\n\n        invest(0x0);\n\n    }\n\n \n\n    function invest(address _referredBy) public payable {\n\n        require(msg.value >= minimum);\n\n \n\n        address _customerAddress = msg.sender;\n\n \n\n        if(\n\n           // is this a referred purchase?\n\n           _referredBy != 0x0000000000000000000000000000000000000000 &&\n\n \n\n           // no cheating!\n\n           _referredBy != _customerAddress &&\n\n \n\n           // does the referrer have at least X whole tokens?\n\n           // i.e is the referrer a godly chad masternode\n\n           investments[_referredBy] >= stakingRequirement\n\n       ){\n\n           // wealth redistribution\n\n           referrer[_referredBy] = referrer[_referredBy].add(msg.value.mul(5).div(100));\n\n       }\n\n \n\n       if (investments[msg.sender] > 0){\n\n           if (withdraw()){\n\n               withdrawals[msg.sender] = 0;\n\n           }\n\n       }\n\n       investments[msg.sender] = investments[msg.sender].add(msg.value);\n\n       joined[msg.sender] = block.timestamp;\n\n       blueDividendAddr.transfer(msg.value.mul(5).div(100));\n\n       emit Invest(msg.sender, msg.value);\n\n    }\n\n \n\n    /**\n\n    * @dev Evaluate current balance\n\n    * @param _address Address of investor\n\n    */\n\n    function getBalance(address _address) view public returns (uint256) {\n\n        uint256 minutesCount = now.sub(joined[_address]).div(1 minutes);\n\n        uint256 percent = investments[_address].mul(step).div(100);\n\n        uint256 different = percent.mul(minutesCount).div(1440);\n\n        uint256 balance = different.sub(withdrawals[_address]);\n\n \n\n        return balance;\n\n    }\n\n \n\n    /**\n\n    * @dev Withdraw dividends from contract\n\n    */\n\n    function withdraw() public returns (bool){\n\n        require(joined[msg.sender] > 0);\n\n        uint256 balance = getBalance(msg.sender);\n\n        if (address(this).balance > balance){\n\n            if (balance > 0){\n\n                withdrawals[msg.sender] = withdrawals[msg.sender].add(balance);\n\n                msg.sender.transfer(balance);\n\n                emit Withdraw(msg.sender, balance);\n\n            }\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n \n\n    /**\n\n    * @dev Bounty reward\n\n    */\n\n    function bounty() public {\n\n        uint256 refBalance = checkReferral(msg.sender);\n\n        if(refBalance >= minimum) {\n\n             if (address(this).balance > refBalance) {\n\n                referrer[msg.sender] = 0;\n\n                msg.sender.transfer(refBalance);\n\n                emit Bounty(msg.sender, refBalance);\n\n             }\n\n        }\n\n    }\n\n \n\n    /**\n\n    * @dev Gets balance of the sender address.\n\n    * @return An uint256 representing the amount owned by the msg.sender.\n\n    */\n\n    function checkBalance() public view returns (uint256) {\n\n        return getBalance(msg.sender);\n\n    }\n\n \n\n    /**\n\n    * @dev Gets withdrawals of the specified address.\n\n    * @param _investor The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function checkWithdrawals(address _investor) public view returns (uint256) {\n\n        return withdrawals[_investor];\n\n    }\n\n \n\n    /**\n\n    * @dev Gets investments of the specified address.\n\n    * @param _investor The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function checkInvestments(address _investor) public view returns (uint256) {\n\n        return investments[_investor];\n\n    }\n\n \n\n    /**\n\n    * @dev Gets referrer balance of the specified address.\n\n    * @param _hunter The address of the referrer\n\n    * @return An uint256 representing the referral earnings.\n\n    */\n\n    function checkReferral(address _hunter) public view returns (uint256) {\n\n        return referrer[_hunter];\n\n    }\n\n}\n\n \n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        uint256 c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n\n    }\n\n \n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n\n    }\n\n \n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n \n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}"
  },
  {
    "id": 19,
    "addr4sss": "0x001ea8150f4965195e10e5b5568047e1555a6dcd",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.11;\n\n\n\ninterface IERC20{\n\n   function totalSupply() constant returns (uint256 totalSupply);\n\n   function balanceOf(address _owner) constant returns (uint256 balance);\n\n   function transfer(address _to, uint256 _value) returns (bool success);\n\n   function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n   function approve(address _spender, uint256 _value) returns (bool success);\n\n   function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n\n\ncontract SenseProtocol is IERC20 {\n\n\n\nusing SafeMath for uint256;\n\n\n\nuint public _totalSupply = 0;\n\n\n\nstring public constant symbol = \"SENSE\";\n\nstring public constant name = \"Sense\";\n\nuint8 public constant decimals = 18;\n\n\n\n// 1 ETH = 1000 Simple\n\nuint256 public constant RATE = 500;\n\n\n\n// Sets Maximum Tokens to be Created\n\nuint256 public constant maxTokens = 40000000000000000000000000;\n\n\n\naddress public owner;\n\n\n\nmapping (address => uint256) public balances;\n\nmapping(address => mapping(address => uint256)) allowed;\n\n\n\nfunction () payable{\n\n    createTokens();\n\n}\n\n\n\nfunction SenseProtocol(){\n\n    owner = msg.sender;\n\n}\n\n\n\nfunction createTokens() payable{\n\n    require(msg.value > 0);\n\n    uint256 tokens = msg.value.mul(RATE);\n\n    require(_totalSupply.add(tokens) <= maxTokens);\n\n    balances[msg.sender] = balances[msg.sender].add(tokens);\n\n    _totalSupply = _totalSupply.add(tokens);\n\n    owner.transfer(msg.value);\n\n}\n\n\n\nfunction totalSupply() public constant returns (uint256 totalSupply) {\n\n    return _totalSupply;\n\n}\n\n\n\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n}\n\n\n\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\n\n    require(balances[msg.sender] >= _value && _value > 0);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n}\n\n\n\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\n\n    balances[_from] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n}\n\n\n\nfunction approve(address _spender, uint256 _value) public returns (bool success) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n}\n\n\n\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n}\n\n\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\n\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n\n}"
  },
  {
    "id": 20,
    "addr4sss": "0x001f0aa5da15585e5b2305dbab2bac425ea71007",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.19;\n\n\n\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n\n\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/179\n\n */\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n\n\n\n/**\n\n * @title Basic token\n\n * @dev Basic version of StandardToken, with no allowances.\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  /**\n\n  * @dev total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n\n\n\n/**\n\n * @title Standard ERC20 token\n\n *\n\n * @dev Implementation of the basic standard token.\n\n * @dev https://github.com/ethereum/EIPs/issues/20\n\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n\n */\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n}\n\n\n\n// File: contracts/IpsxToken.sol\n\n\n\n/**\n\n * @title IpsxToken\n\n * @author https://bit-sentinel.com\n\n */\n\ncontract IpsxToken is StandardToken, Ownable {\n\n  /**\n\n   * @dev event for logging token burns\n\n   * @dev burner address of the burner\n\n   * @dev value of tokens burned\n\n   */\n\n  event Burn(address indexed burner, uint256 value);\n\n\n\n  /**\n\n   * @dev event for logging enablement of transfers\n\n   */\n\n  event EnabledTransfers();\n\n\n\n  /**\n\n   * @dev event for logging crowdsale address set\n\n   * @param crowdsale address of the crowdsale\n\n   */\n\n  event SetCrowdsaleAddress(address indexed crowdsale);\n\n\n\n  // Address of the crowdsale.\n\n  address public crowdsale;\n\n\n\n\n\n  // Public variables of the Token.\n\n  string public name = \"IPSX\"; \n\n  uint8 public decimals = 18;\n\n  string public symbol = \"IPSX\";\n\n\n\n  // The totalSupply is constant, no more tokens will be issued\n\n  // after the contract will be initialized.\n\n  uint256 public totalSupply = 1800000000e18;\n\n\n\n  // If the token is transferable or not.\n\n  bool public transferable = false;\n\n\n\n  /**\n\n   * @dev Initialize the IpsxToken and transfers the totalSupply to the\n\n   *      contract creator. \n\n   */\n\n  function IpsxToken() public {\n\n    balances[msg.sender] = totalSupply;\n\n  }\n\n\n\n  /**\n\n   * @dev Ensure the transfer is valid.\n\n   */\n\n  modifier canTransfer() {\n\n    require(transferable || (crowdsale != address(0) && crowdsale == msg.sender));\n\n    _; \n\n  }\n\n\n\n  /**\n\n   * @dev Enable the transfers of this token. Can only be called once.\n\n   */\n\n  function enableTransfers() external onlyOwner {\n\n    require(!transferable);\n\n    transferable = true;\n\n    EnabledTransfers();\n\n  }\n\n\n\n  /**\n\n   * @dev Set the crowdsale address.\n\n   * @param _addr address\n\n   */\n\n  function setCrowdsaleAddress(address _addr) external onlyOwner {\n\n    require(_addr != address(0));\n\n    crowdsale = _addr;\n\n    SetCrowdsaleAddress(_addr);\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public canTransfer returns (bool) {\n\n    return super.transfer(_to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) {\n\n    return super.transferFrom(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Burns a specific amount of tokens.\n\n   * @param _value The amount of token to be burned.\n\n   */\n\n  function burn(uint256 _value) public onlyOwner {\n\n    require(_value <= balances[owner]);\n\n    balances[owner] = balances[owner].sub(_value);\n\n    totalSupply = totalSupply.sub(_value);\n\n    Burn(owner, _value);\n\n  }\n\n}"
  },
  {
    "id": 21,
    "addr4sss": "0x001f52daa8a4f7b9b26da16baf449c0d270dbe63",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.20;\n\n\n\n/*\n\n    -------------------------------------------------------------------------------------------------------\n\n    Website: https://zarixcoin.com\n\n    Exchange (We recomand to use MetaMask or TrustWallet): https://zarixcoin.com/exchange.html\n\n    Twitter: https://twitter.com/ZarixCoin\n\n    Telegram Group: https://t.me/joinchat/ItCwUlbaxvUEE0C2SHyIVQ\n\n    Discord : https://discord.gg/ZFx5hHz\n\n    -------------------------------------------------------------------------------------------------------\n\n\tZarixCoin \n\n     ZarixCoin Earn Passive Ethereum. \n\n\t- Buys - 10% fee goes to all current token holders. \n\n\t- Sells - 5% fee to all current tokens holders. And it\u2019s lower because you shouldn\u2019t have to pay the sane fee exiting. You deserve more. \n\n\t- Transfers - 0% fee! We have plans for games and we don't want that to be an obstacle!\n\n\t- Masternode - you get 5% from deposit of all players who enter using your Masternode . \n\n*/\n\n\n\ncontract ZarixCoin {\n\n    /*=================================\n\n    =            MODIFIERS            =\n\n    =================================*/\n\n    // only people with tokens\n\n    modifier onlyBagholders() {\n\n        require(myTokens() > 0);\n\n        _;\n\n    }\n\n\n\n    // only people with profits\n\n    modifier onlyStronghands() {\n\n        require(myDividends(true) > 0);\n\n        _;\n\n    }\n\n\n\n    // administrators can:\n\n    // -> change the name of the contract\n\n    // -> change the name of the token\n\n    // -> change the PoS difficulty (How many tokens it costs to hold a masternode, in case it gets crazy high later)\n\n    // they CANNOT:\n\n    // -> take funds\n\n    // -> disable withdrawals\n\n    // -> kill the contract\n\n    // -> change the price of tokens\n\n    modifier onlyAdministrator(){\n\n        address _customerAddress = msg.sender;\n\n        require(administrators[_customerAddress]);\n\n        _;\n\n    }\n\n\n\n\n\n    // ensures that the first tokens in the contract will be equally distributed\n\n    // meaning, no divine dump will be ever possible\n\n    // result: healthy longevity.\n\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\n\n        address _customerAddress = msg.sender;\n\n\n\n        // are we still in the vulnerable phase?\n\n        // if so, enact anti early whale protocol\n\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\n\n            require(\n\n                // is the customer in the ambassador list?\n\n                ambassadors_[_customerAddress] == true &&\n\n\n\n                // does the customer purchase exceed the max ambassador quota?\n\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\n\n\n\n            );\n\n\n\n            // updated the accumulated quota\n\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\n\n\n\n            // execute\n\n            _;\n\n        } else {\n\n            // in case the ether count drops low, the ambassador phase won't reinitiate\n\n            onlyAmbassadors = false;\n\n            _;\n\n        }\n\n    }\n\n\n\n    /*==============================\n\n    =            EVENTS            =\n\n    ==============================*/\n\n    event onTokenPurchase(\n\n        address indexed customerAddress,\n\n        uint256 incomingEthereum,\n\n        uint256 tokensMinted,\n\n        address indexed referredBy\n\n    );\n\n\n\n    event onTokenSell(\n\n        address indexed customerAddress,\n\n        uint256 tokensBurned,\n\n        uint256 ethereumEarned\n\n    );\n\n\n\n    event onReinvestment(\n\n        address indexed customerAddress,\n\n        uint256 ethereumReinvested,\n\n        uint256 tokensMinted\n\n    );\n\n\n\n    event onWithdraw(\n\n        address indexed customerAddress,\n\n        uint256 ethereumWithdrawn\n\n    );\n\n\n\n    // ERC20\n\n    event Transfer(\n\n        address indexed from,\n\n        address indexed to,\n\n        uint256 tokens\n\n    );\n\n\n\n    /*=====================================\n\n    =            CONFIGURABLES            =\n\n    =====================================*/\n\n    string public name = \"ZarixCoin\";\n\n    string public symbol = \"ZarixCoin\";\n\n    uint8 constant public decimals = 18;\n\n    uint8 constant internal entryFee_ = 10; // 10% to enter our community\n\n    uint8 constant internal refferalFee_ = 50; // 50% from enter fee divs or 5% for each invite, great for inviting new members on ZarixCoin\n\n    uint8 constant internal exitFee_ = 5; // 5% for selling\n\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\n\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\n\n    uint256 constant internal magnitude = 2**64;\n\n\n\n    // proof of stake (defaults at 100 tokens)\n\n    uint256 public stakingRequirement = 100e18;\n\n\n\n    // ambassador program\n\n    mapping(address => bool) internal ambassadors_;\n\n    uint256 constant internal ambassadorMaxPurchase_ = 2 ether;\n\n    uint256 constant internal ambassadorQuota_ = 3 ether;\n\n\n\n    // referral program\n\n    mapping(address => uint256) internal referrals;\n\n    mapping(address => bool) internal isUser;\n\n    address[] public usersAddresses;\n\n\n\n   /*================================\n\n    =            DATASETS            =\n\n    ================================*/\n\n    // amount of shares for each address (scaled number)\n\n    mapping(address => uint256) internal tokenBalanceLedger_;\n\n    mapping(address => uint256) internal referralBalance_;\n\n    mapping(address => int256) internal payoutsTo_;\n\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n\n    uint256 internal tokenSupply_ = 0;\n\n    uint256 internal profitPerShare_;\n\n\n\n    // administrator list (see above on what they can do)\n\n    mapping(address => bool) public administrators;\n\n\n\n    // when this is set to true, only ambassadors can purchase tokens (this prevents a whale premine, it ensures a fairly distributed upper pyramid)\n\n    bool public onlyAmbassadors = true;\n\n\n\n    /*=======================================\n\n    =            PUBLIC FUNCTIONS            =\n\n    =======================================*/\n\n    /*\n\n    * -- APPLICATION ENTRY POINTS --\n\n    */\n\n    function ZarixCoinActivate()\n\n        public\n\n    {\n\n        // add administrators here with their wallets\n\n\n\n  \t\t// bungalogic\n\n\t\t// Website developer, concept and design. Community\n\n\t\tadministrators[0x9A692495f83697F95Cd485ce89B8E6a4F07B99fC] = true;\n\n\t\tambassadors_[0x9A692495f83697F95Cd485ce89B8E6a4F07B99fC] = true;\n\n\t\tadministrators[0x5F7B3BAD5463cE82EE91a1CC86be9Ec1f42BD941] = true;\n\n\t\tambassadors_[0x5F7B3BAD5463cE82EE91a1CC86be9Ec1f42BD941] = true;\n\n\t\tadministrators[0x322cC4ed7Dab7158676D81cA396062d1C18b1598] = true;\n\n\t\tambassadors_[0x322cC4ed7Dab7158676D81cA396062d1C18b1598] = true;\n\n\t\tadministrators[0x275E0367228aa38dD698039809Ba2B63fb30E425] = true;\n\n\t\tambassadors_[0x275E0367228aa38dD698039809Ba2B63fb30E425] = true;\n\n\n\n\t\t// clumsier \n\n\t\t// Solidity Developer, website,  ZARIXCOIN \n\n\t\tadministrators[msg.sender] = true;\n\n\t\tambassadors_[msg.sender] = true;\n\n    }\n\n\n\n\n\n    /**\n\n     * Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n\n     */\n\n    function buy(address _referredBy)\n\n        public\n\n        payable\n\n        returns(uint256)\n\n    {\n\n        purchaseTokens(msg.value, _referredBy);\n\n    }\n\n\n\n    /**\n\n     * Fallback function to handle ethereum that was send straight to the contract\n\n     * Unfortunately we cannot use a referral address this way.\n\n     */\n\n    function()\n\n        payable\n\n        public\n\n    {\n\n        purchaseTokens(msg.value, 0x0);\n\n    }\n\n\n\n    /* Converts all of caller's dividends to tokens. */\n\n    function reinvest() onlyStronghands() public {\n\n        // fetch dividends\n\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\n\n\n\n        // pay out the dividends virtually\n\n        address _customerAddress = msg.sender;\n\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n\n\n\n        // retrieve ref. bonus\n\n        _dividends += referralBalance_[_customerAddress];\n\n        referralBalance_[_customerAddress] = 0;\n\n\n\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n\n        uint256 _tokens = purchaseTokens(_dividends, 0x0);\n\n\n\n        // fire event\n\n        onReinvestment(_customerAddress, _dividends, _tokens);\n\n    }\n\n\n\n    /* Alias of sell() and withdraw(). */\n\n    function exit() public {\n\n        // get token count for caller & sell them all\n\n        address _customerAddress = msg.sender;\n\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n\n        if(_tokens > 0) sell(_tokens);\n\n\n\n        // lambo delivery service\n\n        withdraw();\n\n    }\n\n\n\n    /* Withdraws all of the callers earnings. */\n\n    function withdraw() onlyStronghands() public {\n\n        // setup data\n\n        address _customerAddress = msg.sender;\n\n        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\n\n\n\n        // update dividend tracker\n\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n\n\n\n        // add ref. bonus\n\n        _dividends += referralBalance_[_customerAddress];\n\n        referralBalance_[_customerAddress] = 0;\n\n\n\n        // lambo delivery service\n\n        _customerAddress.transfer(_dividends);\n\n\n\n        // fire event\n\n        onWithdraw(_customerAddress, _dividends);\n\n    }\n\n\n\n    /* Liquifies tokens to ethereum. */\n\n    function sell(uint256 _amountOfTokens) onlyBagholders() public {\n\n        // setup data\n\n        address _customerAddress = msg.sender;\n\n        // russian hackers BTFO\n\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        uint256 _tokens = _amountOfTokens;\n\n        uint256 _ethereum = tokensToEthereum_(_tokens);\n\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n\n\n\n        // burn the sold tokens\n\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n\n\n\n        // update dividends tracker\n\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\n\n\n\n        // dividing by zero is a bad idea\n\n        if (tokenSupply_ > 0) {\n\n            // update the amount of dividends per token\n\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n\n        }\n\n\n\n        // fire event\n\n        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n\n    }\n\n\n\n\n\n    /* Transfer tokens from the caller to a new holder. * No fee! */\n\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders() public returns(bool) {\n\n        // setup\n\n        address _customerAddress = msg.sender;\n\n\n\n        // make sure we have the requested tokens\n\n        // also disables transfers until ambassador phase is over\n\n        // ( we dont want whale premines )\n\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n\n\n        // withdraw all outstanding dividends first\n\n        if(myDividends(true) > 0) withdraw();\n\n\n\n        // exchange tokens\n\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\n\n\n\n        // update dividend trackers\n\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);\n\n\n\n        // fire event\n\n        Transfer(_customerAddress, _toAddress, _amountOfTokens);\n\n\n\n        // ERC20\n\n        return true;\n\n\n\n    }\n\n\n\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n\n    /**\n\n     * In case the amassador quota is not met, the administrator can manually disable the ambassador phase.\n\n     */\n\n    function disableInitialStage()\n\n        onlyAdministrator()\n\n        public\n\n    {\n\n        onlyAmbassadors = false;\n\n    }\n\n\n\n    /**\n\n     * In case one of us dies, we need to replace ourselves.\n\n     */\n\n    function setAdministrator(address _identifier, bool _status)\n\n        onlyAdministrator()\n\n        public\n\n    {\n\n        administrators[_identifier] = _status;\n\n    }\n\n\n\n    /**\n\n     * Precautionary measures in case we need to adjust the masternode rate.\n\n     */\n\n    function setStakingRequirement(uint256 _amountOfTokens)\n\n        onlyAdministrator()\n\n        public\n\n    {\n\n        stakingRequirement = _amountOfTokens;\n\n    }\n\n\n\n    /**\n\n     * If we want to rebrand, we can.\n\n     */\n\n    function setName(string _name)\n\n        onlyAdministrator()\n\n        public\n\n    {\n\n        name = _name;\n\n    }\n\n\n\n    /**\n\n     * If we want to rebrand, we can.\n\n     */\n\n    function setSymbol(string _symbol)\n\n        onlyAdministrator()\n\n        public\n\n    {\n\n        symbol = _symbol;\n\n    }\n\n\n\n\n\n    /*----------  HELPERS AND CALCULATORS  ----------*/\n\n    /**\n\n     * Method to view the current Ethereum stored in the contract\n\n     * Example: totalEthereumBalance()\n\n     */\n\n    function totalEthereumBalance()\n\n        public\n\n        view\n\n        returns(uint)\n\n    {\n\n        return this.balance;\n\n    }\n\n\n\n    /**\n\n     * Retrieve the total token supply.\n\n     */\n\n    function totalSupply()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return tokenSupply_;\n\n    }\n\n\n\n    /**\n\n     * Retrieve the tokens owned by the caller.\n\n     */\n\n    function myTokens()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        address _customerAddress = msg.sender;\n\n        return balanceOf(_customerAddress);\n\n    }\n\n\n\n    function referralsOf(address _customerAddress)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return referrals[_customerAddress];\n\n    }\n\n\n\n    function totalUsers()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return usersAddresses.length;\n\n    }\n\n\n\n    /**\n\n     * Retrieve the dividends owned by the caller.\n\n     * If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n\n     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n\n     * But in the internal calculations, we want them separate.\n\n     */\n\n    function myDividends(bool _includeReferralBonus)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        address _customerAddress = msg.sender;\n\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n\n    }\n\n\n\n    /**\n\n     * Retrieve the token balance of any single address.\n\n     */\n\n    function balanceOf(address _customerAddress)\n\n        view\n\n        public\n\n        returns(uint256)\n\n    {\n\n        return tokenBalanceLedger_[_customerAddress];\n\n    }\n\n\n\n    /**\n\n     * Retrieve the dividend balance of any single address.\n\n     */\n\n    function dividendsOf(address _customerAddress)\n\n        view\n\n        public\n\n        returns(uint256)\n\n    {\n\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n\n    }\n\n\n\n    /**\n\n     * Return the buy price of 1 individual token.\n\n     */\n\n    function sellPrice()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // our calculation relies on the token supply, so we need supply. Doh.\n\n        if(tokenSupply_ == 0){\n\n            return tokenPriceInitial_ - tokenPriceIncremental_;\n\n        } else {\n\n            uint256 _ethereum = tokensToEthereum_(1e18);\n\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n\n            return _taxedEthereum;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Return the sell price of 1 individual token.\n\n     */\n\n    function buyPrice()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // our calculation relies on the token supply, so we need supply. Doh.\n\n        if(tokenSupply_ == 0){\n\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n\n        } else {\n\n            uint256 _ethereum = tokensToEthereum_(1e18);\n\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, entryFee_), 100);\n\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n\n            return _taxedEthereum;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\n\n     */\n\n    function calculateTokensReceived(uint256 _ethereumToSpend)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\n\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n\n\n\n        return _amountOfTokens;\n\n    }\n\n\n\n    /**\n\n     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\n\n     */\n\n    function calculateEthereumReceived(uint256 _tokensToSell)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        require(_tokensToSell <= tokenSupply_);\n\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n\n        return _taxedEthereum;\n\n    }\n\n\n\n\n\n    /*==========================================\n\n    =            INTERNAL FUNCTIONS            =\n\n    ==========================================*/\n\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n\n        antiEarlyWhale(_incomingEthereum)\n\n        internal\n\n        returns(uint256)\n\n    {\n\n        // data setup\n\n        address _customerAddress = msg.sender;\n\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n\n        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, refferalFee_), 100);\n\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n\n        uint256 _fee = _dividends * magnitude;\n\n\n\n        // no point in continuing execution if OP is a poorfag russian hacker\n\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n\n        // (or hackers)\n\n        // and yes we know that the safemath function automatically rules out the \"greater then\" equasion.\n\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n\n\n\n        // is the user referred by a masternode?\n\n        if(\n\n            // is this a referred purchase?\n\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\n\n\n\n            // no cheating!\n\n            _referredBy != _customerAddress &&\n\n\n\n            // does the referrer have at least X whole tokens?\n\n            // i.e is the referrer a Kekly chad masternode\n\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n\n        ){\n\n            // wealth redistribution\n\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n\n\n\n            if (isUser[_customerAddress] == false) {\n\n            \treferrals[_referredBy]++;\n\n            }     \n\n\n\n        } else {\n\n            // no ref purchase\n\n            // add the referral bonus back to the global dividends cake\n\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n\n            _fee = _dividends * magnitude;\n\n        }\n\n\n\n        if (isUser[_customerAddress] == false ) {\n\n        \tisUser[_customerAddress] = true;\n\n        \tusersAddresses.push(_customerAddress);\n\n        }\n\n\n\n        // we can't give people infinite ethereum\n\n        if(tokenSupply_ > 0){\n\n\n\n            // add tokens to the pool\n\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n\n\n\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n\n\n\n            // calculate the amount of tokens the customer receives over his purchase\n\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n\n\n\n        } else {\n\n            // add tokens to the pool\n\n            tokenSupply_ = _amountOfTokens;\n\n        }\n\n\n\n        // update circulating supply & the ledger address for the customer\n\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n\n\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n\n        //really i know you think you do but you don't\n\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n\n        payoutsTo_[_customerAddress] += _updatedPayouts;\n\n\n\n        // fire event\n\n        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\n\n\n\n        return _amountOfTokens;\n\n    }\n\n\n\n    /**\n\n     * Calculate Token price based on an amount of incoming ethereum\n\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n\n     */\n\n    function ethereumToTokens_(uint256 _ethereum)\n\n        internal\n\n        view\n\n        returns(uint256)\n\n    {\n\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n\n        uint256 _tokensReceived =\n\n         (\n\n            (\n\n                // underflow attempts BTFO\n\n                SafeMath.sub(\n\n                    (sqrt\n\n                        (\n\n                            (_tokenPriceInitial**2)\n\n                            +\n\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n\n                            +\n\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n\n                            +\n\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n\n                        )\n\n                    ), _tokenPriceInitial\n\n                )\n\n            )/(tokenPriceIncremental_)\n\n        )-(tokenSupply_)\n\n        ;\n\n\n\n        return _tokensReceived;\n\n    }\n\n\n\n    /**\n\n     * Calculate token sell value.\n\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n\n     */\n\n     function tokensToEthereum_(uint256 _tokens)\n\n        internal\n\n        view\n\n        returns(uint256)\n\n    {\n\n\n\n        uint256 tokens_ = (_tokens + 1e18);\n\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n\n        uint256 _etherReceived =\n\n        (\n\n            // underflow attempts BTFO\n\n            SafeMath.sub(\n\n                (\n\n                    (\n\n                        (\n\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n\n                        )-tokenPriceIncremental_\n\n                    )*(tokens_ - 1e18)\n\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n\n            )\n\n        /1e18);\n\n        return _etherReceived;\n\n    }\n\n\n\n\n\n    //This is where all your gas goes, sorry\n\n    //Not sorry, you probably only paid 1 gwei\n\n    function sqrt(uint x) internal pure returns (uint y) {\n\n        uint z = (x + 1) / 2;\n\n        y = x;\n\n        while (z < y) {\n\n            y = z;\n\n            z = (x / z + z) / 2;\n\n        }\n\n    }\n\n}\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, throws on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        uint256 c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, throws on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}"
  },
  {
    "id": 22,
    "addr4sss": "0x001fc4a7f2f586596308091c7b296d4535a25a90",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 1,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\n// ----------------------------------------------------------------------------\n\n// 'Hubscop' Token Contract\n\n//\n\n// Deployed To : 0x001fc4a7f2f586596308091c7b296d4535a25a90\n\n// Symbol      : HUBS\n\n// Name        : Hubscop\n\n// Total Supply: 97,000,000 HUBS\n\n// Decimals    : 18\n\n//\n\n// (c) By 'Hubscop' With 'HUBS' Symbol 2019. The MIT Licence.\n\n// ERC20 Smart Contract Developed By: https://SoftCode.space Blockchain Developer Team.\n\n// ----------------------------------------------------------------------------\n\n\n\n\n\ncontract SafeMath {\n\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n\n        c = a + b;\n\n        require(c >= a);\n\n    }\n\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n\n        require(b <= a);\n\n        c = a - b;\n\n    }\n\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n\n        c = a * b;\n\n        require(a == 0 || c / a == b);\n\n    }\n\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n\n        require(b > 0);\n\n        c = a / b;\n\n    }\n\n}\n\n\n\n\n\ncontract ERC20Interface {\n\n    function totalSupply() public constant returns (uint);\n\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n\n    function transfer(address to, uint tokens) public returns (bool success);\n\n    function approve(address spender, uint tokens) public returns (bool success);\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n}\n\n\n\n\n\ncontract ApproveAndCallFallBack {\n\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n\n}\n\n\n\n\n\ncontract Owned {\n\n    address public owner;\n\n    address public newOwner;\n\n\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n\n\n    function Owned() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n\n        newOwner = _newOwner;\n\n    }\n\n    function acceptOwnership() public {\n\n        require(msg.sender == newOwner);\n\n        OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = address(0);\n\n    }\n\n}\n\n\n\n\n\ncontract Hubscop is ERC20Interface, Owned, SafeMath {\n\n    string public symbol;\n\n    string public  name;\n\n    uint8 public decimals;\n\n    uint public _totalSupply;\n\n\n\n    mapping(address => uint) balances;\n\n    mapping(address => mapping(address => uint)) allowed;\n\n\n\n\n\n    function Hubscop() public {\n\n        symbol = \"HUBS\";\n\n        name = \"Hubscop\";\n\n        decimals = 18;\n\n        _totalSupply = 97000000000000000000000000;\n\n        balances[0x1350A57A424225Bca3CF8489CE6E1e93DA63b3Ff] = _totalSupply;\n\n        Transfer(address(0), 0x1350A57A424225Bca3CF8489CE6E1e93DA63b3Ff, _totalSupply);\n\n    }\n\n\n\n\n\n    function totalSupply() public constant returns (uint) {\n\n        return _totalSupply  - balances[address(0)];\n\n    }\n\n\n\n\n\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n\n        return balances[tokenOwner];\n\n    }\n\n\n\n\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n\n        balances[to] = safeAdd(balances[to], tokens);\n\n        Transfer(msg.sender, to, tokens);\n\n        return true;\n\n    }\n\n\n\n\n\n    function approve(address spender, uint tokens) public returns (bool success) {\n\n        allowed[msg.sender][spender] = tokens;\n\n        Approval(msg.sender, spender, tokens);\n\n        return true;\n\n    }\n\n\n\n\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n\n        balances[from] = safeSub(balances[from], tokens);\n\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n\n        balances[to] = safeAdd(balances[to], tokens);\n\n        Transfer(from, to, tokens);\n\n        return true;\n\n    }\n\n\n\n\n\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n\n        return allowed[tokenOwner][spender];\n\n    }\n\n\n\n\n\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n\n        allowed[msg.sender][spender] = tokens;\n\n        Approval(msg.sender, spender, tokens);\n\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n\n        return true;\n\n    }\n\n\n\n\n\n    function () public payable {\n\n        revert();\n\n    }\n\n\n\n\n\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n\n    }\n\n}"
  },
  {
    "id": 23,
    "addr4sss": "0x002036ed3d00736787a31a19b1e28f7a86c72672",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\n\n\n/**\n\n * v0.4.21+commit.dfe3193c\n\n */\n\ncontract DLP {\n\n    // Public variables of the token\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals = 18;\n\n    // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public totalSupply;\n\n\n\n    // This creates an array with all balances\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    // This generates a public event on the blockchain that will notify clients\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    // This notifies clients about the amount burnt\n\n    event Burn(address indexed from, uint256 value);\n\n\n\n    /**\n\n     * Constructor function\n\n     *\n\n     * Initializes contract with initial supply tokens to the creator of the contract\n\n     */\n\n    function DLP() public {\n\n        totalSupply = 2000000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n\n        name = \"Distributed Lottery Platform\";                                   // Set the name for display purposes\n\n        symbol = \"DLP\";                               // Set the symbol for display purposes\n\n    }\n\n\n\n    /**\n\n     * Internal transfer, only can be called by this contract\n\n     */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        // Prevent transfer to 0x0 address. Use burn() instead\n\n        require(_to != 0x0);\n\n        // Check if the sender has enough\n\n        require(balanceOf[_from] >= _value);\n\n        // Check for overflows\n\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n\n        // Save this for an assertion in the future\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        // Subtract from the sender\n\n        balanceOf[_from] -= _value;\n\n        // Add the same to the recipient\n\n        balanceOf[_to] += _value;\n\n        emit Transfer(_from, _to, _value);\n\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens\n\n     *\n\n     * Send `_value` tokens to `_to` from your account\n\n     *\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transfer(address _to, uint256 _value) public {\n\n        _transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens from other address\n\n     *\n\n     * Send `_value` tokens to `_to` on behalf of `_from`\n\n     *\n\n     * @param _from The address of the sender\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     */\n\n    function approve(address _spender, uint256 _value) public\n\n        returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address and notify\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     * @param _extraData some extra information to send to the approved contract\n\n     */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n\n        public\n\n        returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly\n\n     *\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n\n        totalSupply -= _value;                      // Updates totalSupply\n\n        emit Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens from other account\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n\n     *\n\n     * @param _from the address of the sender\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n\n        totalSupply -= _value;                              // Update totalSupply\n\n        emit Burn(_from, _value);\n\n        return true;\n\n    }\n\n}"
  },
  {
    "id": 24,
    "addr4sss": "0x00214120d3469a74ca586bc9557c0ff8fb09b157",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, throws on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        // uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return a / b;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, throws on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n        c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}\n\n\n\ncontract ForeignToken {\n\n    function balanceOf(address _owner) constant public returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n}\n\n\n\ncontract ERC20Basic {\n\n    uint256 public totalSupply;\n\n    function balanceOf(address who) public constant returns (uint256);\n\n    function transfer(address to, uint256 value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n    function allowance(address owner, address spender) public constant returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\ncontract TrueToken is ERC20 {\n\n    \n\n    using SafeMath for uint256;\n\n    address owner = msg.sender;\n\n\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;    \n\n\n\n    string public constant name = \"TrueToken\";\n\n    string public constant symbol = \"TRU\";\n\n    uint public constant decimals = 18;\n\n    \n\n    uint256 public totalSupply = 20000000000e18;\n\n    uint256 public totalDistributed = 10000000000e18;    \n\n    uint256 public constant MIN_CONTRIBUTION = 1 ether / 1000; // 0.001 Ether\n\n    uint256 public tokensPerEth = 20000000e18;\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    \n\n    event Distr(address indexed to, uint256 amount);\n\n    event DistrFinished();\n\n\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    \n\n    event Burn(address indexed burner, uint256 value);\n\n\n\n    bool public distributionFinished = false;\n\n    \n\n    modifier canDistr() {\n\n        require(!distributionFinished);\n\n        _;\n\n    }\n\n    \n\n    modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n    \n\n    \n\n    function TrueToken () public {\n\n        owner = msg.sender;        \n\n        distr(owner, totalDistributed);\n\n    }\n\n    \n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n\n    }\n\n    \n\n\n\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n\n        distributionFinished = true;\n\n        emit DistrFinished();\n\n        return true;\n\n    }\n\n    \n\n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n\n        totalDistributed = totalDistributed.add(_amount);        \n\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Distr(_to, _amount);\n\n        emit Transfer(address(0), _to, _amount);\n\n\n\n        return true;\n\n    }\n\n\n\n    function doAirdrop(address _participant, uint _amount) internal {\n\n\n\n        require( _amount > 0 );      \n\n\n\n        require( totalDistributed < totalSupply );\n\n        \n\n        balances[_participant] = balances[_participant].add(_amount);\n\n        totalDistributed = totalDistributed.add(_amount);\n\n\n\n        if (totalDistributed >= totalSupply) {\n\n            distributionFinished = true;\n\n        }\n\n\n\n        // log\n\n        emit Airdrop(_participant, _amount, balances[_participant]);\n\n        emit Transfer(address(0), _participant, _amount);\n\n    }\n\n\n\n    function adminClaimAirdrop(address _participant, uint _amount) external {        \n\n        doAirdrop(_participant, _amount);\n\n    }\n\n\n\n    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) external {        \n\n        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);\n\n    }\n\n\n\n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n\n        tokensPerEth = _tokensPerEth;\n\n        emit TokensPerEthUpdated(_tokensPerEth);\n\n    }\n\n           \n\n    function () external payable {\n\n        getTokens();\n\n     }\n\n    \n\n    function getTokens() payable canDistr  public {\n\n        uint256 tokens = 0;\n\n\n\n        // minimum contribution\n\n        require( msg.value >= MIN_CONTRIBUTION );\n\n\n\n        require( msg.value > 0 );\n\n\n\n        // get baseline number of tokens\n\n        tokens = tokensPerEth.mul(msg.value) / 1 ether;        \n\n        address investor = msg.sender;\n\n        \n\n        if (tokens > 0) {\n\n            distr(investor, tokens);\n\n        }\n\n\n\n        if (totalDistributed >= totalSupply) {\n\n            distributionFinished = true;\n\n        }\n\n    }\n\n\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    // mitigates the ERC20 short address attack\n\n    modifier onlyPayloadSize(uint size) {\n\n        assert(msg.data.length >= size + 4);\n\n        _;\n\n    }\n\n    \n\n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n\n\n        require(_to != address(0));\n\n        require(_amount <= balances[msg.sender]);\n\n        \n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n\n    }\n\n    \n\n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n\n\n\n        require(_to != address(0));\n\n        require(_amount <= balances[_from]);\n\n        require(_amount <= allowed[_from][msg.sender]);\n\n        \n\n        balances[_from] = balances[_from].sub(_amount);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Transfer(_from, _to, _amount);\n\n        return true;\n\n    }\n\n    \n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        // mitigates the ERC20 spend/approval race condition\n\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n    \n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n    \n\n    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n\n        ForeignToken t = ForeignToken(tokenAddress);\n\n        uint bal = t.balanceOf(who);\n\n        return bal;\n\n    }\n\n    \n\n    function withdraw() onlyOwner public {\n\n        address myAddress = this;\n\n        uint256 etherBalance = myAddress.balance;\n\n        owner.transfer(etherBalance);\n\n    }\n\n    \n\n    function burn(uint256 _value) onlyOwner public {\n\n        require(_value <= balances[msg.sender]);\n\n        // no need to require value <= totalSupply, since that would imply the\n\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n        address burner = msg.sender;\n\n        balances[burner] = balances[burner].sub(_value);\n\n        totalSupply = totalSupply.sub(_value);\n\n        totalDistributed = totalDistributed.sub(_value);\n\n        emit Burn(burner, _value);\n\n    }\n\n    \n\n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n\n        ForeignToken token = ForeignToken(_tokenContract);\n\n        uint256 amount = token.balanceOf(address(this));\n\n        return token.transfer(owner, amount);\n\n    }\n\n}"
  },
  {
    "id": 25,
    "addr4sss": "0x0022ee765799c1f836a36612b8c62be098fd0bbb",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity \t\t^0.4.21\t;\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\ncontract\tSOCGEN_301201\t\t\t\t{\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tmapping (address => uint256) public balanceOf;\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tstring\tpublic\t\tname =\t\"\tSOCGEN_301201\t\t\"\t;\n\n\tstring\tpublic\t\tsymbol =\t\"\tSOCGI\t\t\"\t;\n\n\tuint8\tpublic\t\tdecimals =\t\t18\t\t\t;\n\n\t\t\t\t\t\t\t\t\t\n\n\tuint256 public totalSupply =\t\t10780817168445100000000000\t\t\t\t\t;\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tfunction SimpleERC20Token() public {\t\t\t\t\t\t\t\t\n\n\t\tbalanceOf[msg.sender] = totalSupply;\t\t\t\t\t\t\t\n\n\t\temit Transfer(address(0), msg.sender, totalSupply);\t\t\t\t\t\t\t\n\n\t}\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tfunction transfer(address to, uint256 value) public returns (bool success) {\t\t\t\t\t\t\t\t\n\n\t\trequire(balanceOf[msg.sender] >= value);\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\t\tbalanceOf[msg.sender] -= value;  // deduct from sender's balance\t\t\t\t\t\t\t\n\n\t\tbalanceOf[to] += value;          // add to recipient's balance\t\t\t\t\t\t\t\n\n\t\temit Transfer(msg.sender, to, value);\t\t\t\t\t\t\t\n\n\t\treturn true;\t\t\t\t\t\t\t\n\n\t}\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tmapping(address => mapping(address => uint256)) public allowance;\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tfunction approve(address spender, uint256 value)\t\t\t\t\t\t\t\t\n\n\t\tpublic\t\t\t\t\t\t\t\n\n\t\treturns (bool success)\t\t\t\t\t\t\t\n\n\t{\t\t\t\t\t\t\t\t\n\n\t\tallowance[msg.sender][spender] = value;\t\t\t\t\t\t\t\n\n\t\temit Approval(msg.sender, spender, value);\t\t\t\t\t\t\t\n\n\t\treturn true;\t\t\t\t\t\t\t\n\n\t}\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\tfunction transferFrom(address from, address to, uint256 value)\t\t\t\t\t\t\t\t\n\n\t\tpublic\t\t\t\t\t\t\t\n\n\t\treturns (bool success)\t\t\t\t\t\t\t\n\n\t{\t\t\t\t\t\t\t\t\n\n\t\trequire(value <= balanceOf[from]);\t\t\t\t\t\t\t\n\n\t\trequire(value <= allowance[from][msg.sender]);\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\n\t\tbalanceOf[from] -= value;\t\t\t\t\t\t\t\n\n\t\tbalanceOf[to] += value;\t\t\t\t\t\t\t\n\n\t\tallowance[from][msg.sender] -= value;\t\t\t\t\t\t\t\n\n\t\temit Transfer(from, to, value);\t\t\t\t\t\t\t\n\n\t\treturn true;\t\t\t\t\t\t\t\n\n\t}\t\t\t\t\t\t\t\t\n\n}"
  },
  {
    "id": 26,
    "addr4sss": "0x0027449bf0887ca3e431d263ffdefb244d95b555",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/179\n\n */\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\n\n\ncontract NotCoin is ERC20 {\n\n  uint constant MAX_UINT = 2**256 - 1;\n\n  string public name;\n\n  string public symbol;\n\n  uint8 public decimals;\n\n\n\n  function NotCoin(string _name, string _symbol, uint8 _decimals) public {\n\n    name = _name;\n\n    symbol = _symbol;\n\n    decimals = _decimals;\n\n  }\n\n\n\n\n\n  function totalSupply() public view returns (uint) {\n\n    return MAX_UINT;\n\n  }\n\n\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return MAX_UINT;\n\n  }\n\n\n\n  function transfer(address _to, uint _value) public returns (bool)  {\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n\n    return MAX_UINT;\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n}"
  },
  {
    "id": 27,
    "addr4sss": "0x002842529757eab873cce9c251087e1b993f9200",
    "ARTHM": 0,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\n\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        uint256 c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n\n    }\n\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n\n    }\n\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}\n\n\n\n\n\ncontract StupidToken {\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n}\n\n\n\n\n\ncontract StupidCrowdsale {\n\n\n\n    using SafeMath for uint256;\n\n\n\n    StupidToken public token;\n\n\n\n    //Tokens per 1 eth\n\n    uint256 constant public rate = 10000;\n\n    \n\n    uint256 constant public goal = 20000000 * (10 ** 18);\n\n    uint256 public startTime;\n\n    uint256 public endTime;\n\n    uint256 public weiRaised;\n\n    uint256 public tokensSold;\n\n\n\n    bool public crowdsaleActive = true;\n\n\n\n    address public wallet;\n\n    address public tokenOwner;\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n\n\n    /**\n\n    * @param _startTime Unix timestamp\n\n    * @param _endTime Unix timestamp\n\n    * @param _wallet Ethereum address to which the invested funds are forwarded\n\n    * @param _token Address of the token that will be rewarded for the investors\n\n    * @param _tokenOwner Address of the token owner who can execute restricted functions\n\n    */\n\n    function StupidCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _tokenOwner) public {\n\n        require(_startTime < _endTime);\n\n        require(_wallet != address(0));\n\n        require(_token != address(0));\n\n        require(_tokenOwner != address(0));\n\n\n\n        startTime = _startTime;\n\n        endTime = _endTime;\n\n\n\n        wallet = _wallet;\n\n        tokenOwner = _tokenOwner;\n\n        token = StupidToken(_token);\n\n    }\n\n\n\n    // fallback function can be used to buy tokens\n\n    function () external payable {\n\n        buyTokens(msg.sender);\n\n    }\n\n\n\n    // low level token purchase function\n\n    function buyTokens(address investor) public payable {\n\n        require(investor != address(0));\n\n        require(now >= startTime && now <= endTime);\n\n        require(crowdsaleActive);\n\n        require(msg.value != 0);\n\n\n\n        uint256 weiAmount = msg.value;\n\n\n\n        // calculate token amount to be created\n\n        uint256 tokens = weiAmount.mul(rate);\n\n\n\n        require(tokensSold.add(tokens) <= goal);\n\n\n\n        // update state\n\n        weiRaised = weiRaised.add(weiAmount);\n\n        tokensSold = tokensSold.add(tokens);\n\n        balances[investor] = balances[investor].add(weiAmount);\n\n\n\n        assert(token.transferFrom(tokenOwner, investor, tokens));\n\n        TokenPurchase(msg.sender, investor, weiAmount, tokens);\n\n\n\n        wallet.transfer(msg.value);\n\n    }\n\n\n\n    function setCrowdsaleActive(bool _crowdsaleActive) public {\n\n        require(msg.sender == tokenOwner);\n\n        crowdsaleActive = _crowdsaleActive;\n\n    }\n\n\n\n    /**\n\n        * @dev Gets the balance of the specified address.\n\n        * @param _owner The address to query the the balance of.\n\n        * @return An uint256 representing the amount owned by the passed address.\n\n        */\n\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n}"
  },
  {
    "id": 28,
    "addr4sss": "0x00285f9aad90013a782fb6c85584d97f120b54d8",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ncontract owned {\n\n    address public owner;\n\n\n\n    function owned() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        owner = newOwner;\n\n    }\n\n}\n\n\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\n\n\ncontract TokenERC20 {\n\n    // Public variables of the token\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals = 18;\n\n    // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public totalSupply;\n\n\n\n    // This creates an array with all balances\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    // This generates a public event on the blockchain that will notify clients\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n\n    // This generates a public event on the blockchain that will notify clients\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n\n    // This notifies clients about the amount burnt\n\n    event Burn(address indexed from, uint256 value);\n\n\n\n    /**\n\n     * Constrctor function\n\n     *\n\n     * Initializes contract with initial supply tokens to the creator of the contract\n\n     */\n\n    function TokenERC20(\n\n        uint256 initialSupply,\n\n        string tokenName,\n\n        string tokenSymbol\n\n    ) public {\n\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n\n        name = tokenName;                                   // Set the name for display purposes\n\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\n    }\n\n\n\n    /**\n\n     * Internal transfer, only can be called by this contract\n\n     */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        // Prevent transfer to 0x0 address. Use burn() instead\n\n        require(_to != 0x0);\n\n        // Check if the sender has enough\n\n        require(balanceOf[_from] >= _value);\n\n        // Check for overflows\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        // Save this for an assertion in the future\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        // Subtract from the sender\n\n        balanceOf[_from] -= _value;\n\n        // Add the same to the recipient\n\n        balanceOf[_to] += _value;\n\n        emit Transfer(_from, _to, _value);\n\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens\n\n     *\n\n     * Send `_value` tokens to `_to` from your account\n\n     *\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n        _transfer(msg.sender, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens from other address\n\n     *\n\n     * Send `_value` tokens to `_to` in behalf of `_from`\n\n     *\n\n     * @param _from The address of the sender\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     */\n\n    function approve(address _spender, uint256 _value) public\n\n        returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address and notify\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     * @param _extraData some extra information to send to the approved contract\n\n     */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n\n        public\n\n        returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly\n\n     *\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n\n        totalSupply -= _value;                      // Updates totalSupply\n\n        emit Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens from other account\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n\n     *\n\n     * @param _from the address of the sender\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n\n        totalSupply -= _value;                              // Update totalSupply\n\n        emit Burn(_from, _value);\n\n        return true;\n\n    }\n\n}\n\n\n\n/******************************************/\n\n/*       ADVANCED TOKEN STARTS HERE       */\n\n/******************************************/\n\n\n\ncontract SurgeToken is owned, TokenERC20 {\n\n\n\n    uint256 public sellPrice;\n\n    uint256 public buyPrice;\n\n\n\n    mapping (address => bool) public frozenAccount;\n\n\n\n    /* This generates a public event on the blockchain that will notify clients */\n\n    event FrozenFunds(address target, bool frozen);\n\n\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n\n    function SurgeToken(\n\n    ) TokenERC20(100000000, \"Surge Token\", \"SRG\") public {\n\n        owner = msg.sender; \n\n    }\n\n\n\n    /* Internal transfer, only can be called by this contract */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n\n        emit Transfer(_from, _to, _value);\n\n    }\n\n\n\n    /// @notice Create `mintedAmount` tokens and send it to `target`\n\n    /// @param target Address to receive the tokens\n\n    /// @param mintedAmount the amount of tokens it will receive\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n\n        balanceOf[target] += mintedAmount;\n\n        totalSupply += mintedAmount;\n\n        emit Transfer(0, this, mintedAmount);\n\n        emit Transfer(this, target, mintedAmount);\n\n    }\n\n\n\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n\n    /// @param target Address to be frozen\n\n    /// @param freeze either to freeze it or not\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n\n        frozenAccount[target] = freeze;\n\n        emit FrozenFunds(target, freeze);\n\n    }\n\n\n\n    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n\n    /// @param newSellPrice Price the users can sell to the contract\n\n    /// @param newBuyPrice Price users can buy from the contract\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n\n        sellPrice = newSellPrice;\n\n        buyPrice = newBuyPrice;\n\n    }\n\n\n\n    /// @notice Buy tokens from contract by sending ether\n\n    function buy() payable public {\n\n        uint amount = msg.value / buyPrice;               // calculates the amount\n\n        _transfer(this, msg.sender, amount);              // makes the transfers\n\n    }\n\n\n\n    /// @notice Sell `amount` tokens to contract\n\n    /// @param amount amount of tokens to be sold\n\n    function sell(uint256 amount) public {\n\n        address myAddress = this;\n\n        require(myAddress.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy\n\n        _transfer(msg.sender, this, amount);              // makes the transfers\n\n        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks\n\n    }\n\n}"
  },
  {
    "id": 29,
    "addr4sss": "0x002c74b0cd9354ba5464db519cae76d7cfaa070a",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.13;\n\n\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a / b;\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract Ownable {\n\n  address public owner;\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  function transferOwnership(address newOwner) onlyOwner {\n\n    if (newOwner != address(0)) {\n\n      owner = newOwner;\n\n    }\n\n  }\n\n\n\n}\n\n\n\ncontract ERC20Basic {\n\n  uint256 public totalSupply;\n\n  function balanceOf(address who) constant returns (uint256);\n\n  function transfer(address to, uint256 value) returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n  \n\n  function transfer(address _to, uint256 _value) returns (bool) {\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) constant returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) returns (bool);\n\n  function approve(address spender, uint256 value) returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n    balances[_to] = balances[_to].add(_value);\n\n    balances[_from] = balances[_from].sub(_value);\n\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function approve(address _spender, uint256 _value) returns (bool) {\n\n\n\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n}\n\n\n\ncontract MintableToken is StandardToken, Ownable {\n\n  event Mint(address indexed to, uint256 amount);\n\n  event MintFinished();\n\n\n\n  bool public mintingFinished = false;\n\n\n\n\n\n  modifier canMint() {\n\n    require(!mintingFinished);\n\n    _;\n\n  }\n\n\n\n  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n\n    totalSupply = totalSupply.add(_amount);\n\n    balances[_to] = balances[_to].add(_amount);\n\n    Mint(_to, _amount);\n\n    return true;\n\n  }\n\n\n\n  function finishMinting() onlyOwner returns (bool) {\n\n    mintingFinished = true;\n\n    MintFinished();\n\n    return true;\n\n  }\n\n}\n\n\n\ncontract DemoTokenMintable is MintableToken {\n\n\n\n        string public name = \"Tronic\";\n\n        string public symbol = \"TRNC\";\n\n        uint256 public decimals = 7;\n\n\n\n}"
  },
  {
    "id": 30,
    "addr4sss": "0x00312b3d7f39f63b15d5b2078f2862249b09338d",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.11;\n\n\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/179\n\n */\n\ncontract ERC20Basic {\n\n  uint256 public totalSupply;\n\n  function balanceOf(address who) public constant returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner public {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title Basic token\n\n * @dev Basic version of StandardToken, with no allowances.\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public constant returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\n\n\n/**\n\n * @title Standard ERC20 token\n\n *\n\n * @dev Implementation of the basic standard token.\n\n * @dev https://github.com/ethereum/EIPs/issues/20\n\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n\n */\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n\n\n    uint256 _allowance = allowed[_from][msg.sender];\n\n\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\n    // require (_value <= _allowance);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   */\n\n  function increaseApproval (address _spender, uint _addedValue)\n\n    returns (bool success) {\n\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  function decreaseApproval (address _spender, uint _subtractedValue)\n\n    returns (bool success) {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    Unpause();\n\n  }\n\n}\n\n\n\ncontract APToken is StandardToken, Pausable {\n\n\n\n  string public constant name = 'APT Token';                              // Set the token name for display\n\n  string public constant symbol = 'APT';                                  // Set the token symbol for display\n\n  uint8 public constant decimals = 18;                                     // Set the number of decimals for display\n\n  uint256 public constant INITIAL_SUPPLY = 5e8 * 10**uint256(decimals); // supply specified in Grains\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier rejectTokensToContract(address _to) {\n\n    require(_to != address(this));\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev APToken Constructor\n\n   * Runs only on initial contract creation.\n\n   */\n\n  function APToken() {\n\n    totalSupply = INITIAL_SUPPLY;                               // Set the total supply\n\n    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all\n\n    Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer token for a specified address when not paused\n\n   * @param _to The address to transfer to.\n\n   * @param _value The amount to be transferred.\n\n   */\n\n  function transfer(address _to, uint256 _value) rejectTokensToContract(_to) public whenNotPaused returns (bool) {\n\n    return super.transfer(_to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another when not paused\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) rejectTokensToContract(_to) public whenNotPaused returns (bool) {\n\n    return super.transferFrom(_from, _to, _value);\n\n  }\n\n\n\n  /**\n\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender when not paused.\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n\n    return super.approve(_spender, _value);\n\n  }\n\n\n\n  /**\n\n   * Adding whenNotPaused\n\n   */\n\n  function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n\n    return super.increaseApproval(_spender, _addedValue);\n\n  }\n\n\n\n  /**\n\n   * Adding whenNotPaused\n\n   */\n\n  function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n\n    return super.decreaseApproval(_spender, _subtractedValue);\n\n  }\n\n\n\n}"
  },
  {
    "id": 31,
    "addr4sss": "0x0033fb5561719b8b697b604466d6d39308c58191",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ncontract owned {\n\n    address public owner;\n\n\n\n    function owned() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        owner = newOwner;\n\n    }\n\n}\n\n\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\n\n\ncontract TokenERC20 {\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals = 18;  // decimals \u53ef\u4ee5\u6709\u7684\u5c0f\u6570\u70b9\u4e2a\u6570\uff0c\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u300218 \u662f\u5efa\u8bae\u7684\u9ed8\u8ba4\u503c\n\n    uint256 public totalSupply;\n\n\n\n    // \u7528mapping\u4fdd\u5b58\u6bcf\u4e2a\u5730\u5740\u5bf9\u5e94\u7684\u4f59\u989d\n\n    mapping (address => uint256) public balanceOf;\n\n    \n\n    // \u5b58\u50a8\u5bf9\u8d26\u53f7\u7684\u63a7\u5236\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ea4\u6613\u53d1\u751f\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ee3\u5e01\u88ab\u6d88\u8d39\n\n    event Burn(address indexed from, uint256 value);\n\n\t\n\n\t\n\n    /**\n\n     * \u521d\u59cb\u5316\u6784\u9020\n\n     */\n\n    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {\n\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // \u4f9b\u5e94\u7684\u4efd\u989d\uff0c\u4efd\u989d\u8ddf\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u6709\u5173\uff0c\u4efd\u989d = \u5e01\u6570 * 10 ** decimals\u3002\n\n        balanceOf[msg.sender] = totalSupply;                // \u521b\u5efa\u8005\u62e5\u6709\u6240\u6709\u7684\u4ee3\u5e01\n\n        name = tokenName;                                   // \u4ee3\u5e01\u540d\u79f0\n\n        symbol = tokenSymbol;                               // \u4ee3\u5e01\u7b26\u53f7\n\n    }\n\n\n\n    /**\n\n     * \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb\u7684\u5185\u90e8\u5b9e\u73b0\n\n     */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        // \u786e\u4fdd\u76ee\u6807\u5730\u5740\u4e0d\u4e3a0x0\uff0c\u56e0\u4e3a0x0\u5730\u5740\u4ee3\u8868\u9500\u6bc1\n\n        require(_to != 0x0);\n\n        // \u68c0\u67e5\u53d1\u9001\u8005\u4f59\u989d\n\n        require(balanceOf[_from] >= _value);\n\n        // \u786e\u4fdd\u8f6c\u79fb\u4e3a\u6b63\u6570\u4e2a\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n\n\n        // \u4ee5\u4e0b\u7528\u6765\u68c0\u67e5\u4ea4\u6613\uff0c\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        // Subtract from the sender\n\n        balanceOf[_from] -= _value;\n\n        // Add the same to the recipient\n\n        balanceOf[_to] += _value;\n\n        Transfer(_from, _to, _value);\n\n\n\n        // \u7528assert\u6765\u68c0\u67e5\u4ee3\u7801\u903b\u8f91\u3002\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n\n\n    /**\n\n     *  \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb\n\n     * \u4ece\u521b\u5efa\u4ea4\u6613\u8005\u8d26\u53f7\u53d1\u9001`_value`\u4e2a\u4ee3\u5e01\u5230 `_to`\u8d26\u53f7\n\n     *\n\n     * @param _to \u63a5\u6536\u8005\u5730\u5740\n\n     * @param _value \u8f6c\u79fb\u6570\u989d\n\n     */\n\n    function transfer(address _to, uint256 _value) public {\n\n        _transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * \u8d26\u53f7\u4e4b\u95f4\u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb\n\n     * @param _from \u53d1\u9001\u8005\u5730\u5740\n\n     * @param _to \u63a5\u6536\u8005\u5730\u5740\n\n     * @param _value \u8f6c\u79fb\u6570\u989d\n\n     */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * \u8bbe\u7f6e\u67d0\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u53ef\u4ee5\u4ea4\u6613\u8005\u540d\u4e49\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002\n\n     *\n\n     * \u5141\u8bb8\u53d1\u9001\u8005`_spender` \u82b1\u8d39\u4e0d\u591a\u4e8e `_value` \u4e2a\u4ee3\u5e01\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     */\n\n    function approve(address _spender, uint256 _value) public\n\n        returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * \u8bbe\u7f6e\u5141\u8bb8\u4e00\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u4ee5\u4ea4\u6613\u8005\u540d\u4e49\u53ef\u6700\u591a\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002\n\n     *\n\n     * @param _spender \u88ab\u6388\u6743\u7684\u5730\u5740\uff08\u5408\u7ea6\uff09\n\n     * @param _value \u6700\u5927\u53ef\u82b1\u8d39\u4ee3\u5e01\u6570\n\n     * @param _extraData \u53d1\u9001\u7ed9\u5408\u7ea6\u7684\u9644\u52a0\u6570\u636e\n\n     */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n\n        public\n\n        returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * \u9500\u6bc1\u521b\u5efa\u8005\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01\n\n     */\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n\n        totalSupply -= _value;                      // Updates totalSupply\n\n        Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * \u9500\u6bc1\u7528\u6237\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n\n     *\n\n     * @param _from the address of the sender\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n\n        totalSupply -= _value;                              // Update totalSupply\n\n        Burn(_from, _value);\n\n        return true;\n\n    }\n\n}\n\n\n\ncontract EncryptedToken is owned, TokenERC20 {\n\n  uint256 INITIAL_SUPPLY = 500000000;\n\n  uint256 public buyPrice = 2000;\n\n  mapping (address => bool) public frozenAccount;\n\n\n\n    /* This generates a public event on the blockchain that will notify clients */\n\n    event FrozenFunds(address target, bool frozen);\n\n\t\n\n\tfunction EncryptedToken() TokenERC20(INITIAL_SUPPLY, 'TEME', '18') payable public {\n\n    \t\t\n\n    \t\t\n\n    }\n\n    \n\n\t/* Internal transfer, only can be called by this contract */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n\n        Transfer(_from, _to, _value);\n\n        \n\n    }\n\n\n\n    /// @notice Create `mintedAmount` tokens and send it to `target`\n\n    /// @param target Address to receive the tokens\n\n    /// @param mintedAmount the amount of tokens it will receive\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n\n        balanceOf[target] += mintedAmount;\n\n        totalSupply += mintedAmount;\n\n        Transfer(0, this, mintedAmount);\n\n        Transfer(this, target, mintedAmount);\n\n    }\n\n\n\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n\n    /// @param target Address to be frozen\n\n    /// @param freeze either to freeze it or not\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n\n        frozenAccount[target] = freeze;\n\n        FrozenFunds(target, freeze);\n\n    }\n\n\n\n    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n\n    /// @param newBuyPrice Price users can buy from the contract\n\n    function setPrices(uint256 newBuyPrice) onlyOwner public {\n\n        buyPrice = newBuyPrice;\n\n    }\n\n\n\n    /// @notice Buy tokens from contract by sending ether\n\n    function buy() payable public {\n\n        uint amount = msg.value / buyPrice;               // calculates the amount\n\n        _transfer(this, msg.sender, amount);              // makes the transfers\n\n    }\n\n\n\n\n\n    \n\n    function () payable public {\n\n    \t\tuint amount = msg.value * buyPrice;               // calculates the amount\n\n    \t\t_transfer(owner, msg.sender, amount);\n\n    }\n\n    \n\n    //\u9500\u6bc1\u5408\u540c\uff0c\u5c06\u5e01\u5168\u90e8\u8f6c\u7ed9\u7ba1\u7406\u8005\n\n    function selfdestructs() payable public {\n\n    \t\tselfdestruct(owner);\n\n    }\n\n    \n\n        //\u5c06\u6307\u5b9a\u6570\u91cf\u7684eth\u8f6c\u7ed9\u7ba1\u7406\u8005\n\n    function getEth(uint num) payable public {\n\n    \t\towner.send(num);\n\n    }\n\n    \n\n    //\u67e5\u770b\u6307\u5b9a\u5730\u5740\u7684\u4f59\u989d\n\n  function balanceOfa(address _owner) public constant returns (uint256) {\n\n    return balanceOf[_owner];\n\n  }\n\n}"
  },
  {
    "id": 32,
    "addr4sss": "0x00346fddca107aec034a367b7324f0d6419bf4b9",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ninterface token {\n\n    function transfer(address receiver, uint amount) public;\n\n}\n\n\n\ncontract Crowdsale {\n\n    address public beneficiary;\n\n    uint public fundingGoal;\n\n    uint public amountRaised;\n\n    uint public deadline;\n\n    uint public price;\n\n    token public tokenReward;\n\n    mapping(address => uint256) public balanceOf;\n\n    bool fundingGoalReached = false;\n\n    bool crowdsaleClosed = false;\n\n\n\n    event GoalReached(address recipient, uint totalAmountRaised);\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n\n\n    /**\n\n     * Constrctor function\n\n     *\n\n     * Setup the owner\n\n     */\n\n    function Crowdsale(\n\n        address ifSuccessfulSendTo,\n\n        uint fundingGoalInEthers,\n\n        address addressOfTokenUsedAsReward\n\n    )  public{\n\n        beneficiary = ifSuccessfulSendTo;\n\n        fundingGoal = fundingGoalInEthers * 1 ether;\n\n        price =  (0.00001 ether)/100000  ;\n\n        tokenReward = token(addressOfTokenUsedAsReward);\n\n    }\n\n\n\n    /**\n\n     * Fallback function\n\n     *\n\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\n\n     */\n\n    function () payable public {\n\n        require(!crowdsaleClosed);\n\n        uint amount = msg.value;\n\n        balanceOf[msg.sender] += amount;\n\n        amountRaised += amount;\n\n        tokenReward.transfer(msg.sender, amount / price);\n\n        FundTransfer(msg.sender, amount, true);\n\n    }\n\n\n\n    modifier afterDeadline() { if (now >= deadline) _; }\n\n\n\n    /**\n\n     * Check if goal was reached\n\n     *\n\n     * Checks if the goal or time limit has been reached and ends the campaign\n\n     */\n\n    function checkGoalReached() afterDeadline public {\n\n        if (amountRaised >= fundingGoal){\n\n            fundingGoalReached = true;\n\n            GoalReached(beneficiary, amountRaised);\n\n        }\n\n        crowdsaleClosed = true;\n\n    }\n\n\n\n\n\n    /**\n\n     * Withdraw the funds\n\n     *\n\n     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n\n     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\n\n     * the amount they contributed.\n\n     */\n\n    function safeWithdrawal() afterDeadline public {\n\n        if (!fundingGoalReached) {\n\n            uint amount = balanceOf[msg.sender];\n\n            balanceOf[msg.sender] = 0;\n\n            if (amount > 0) {\n\n                if (msg.sender.send(amount)) {\n\n                    FundTransfer(msg.sender, amount, false);\n\n                } else {\n\n                    balanceOf[msg.sender] = amount;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (fundingGoalReached && beneficiary == msg.sender) {\n\n            if (beneficiary.send(amountRaised)) {\n\n                FundTransfer(beneficiary, amountRaised, false);\n\n            } else {\n\n                //If we fail to send the funds to beneficiary, unlock funders balance\n\n                fundingGoalReached = false;\n\n            }\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 33,
    "addr4sss": "0x00359e48665c081ecba0519cacff26c7ca889296",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.13;\n\n\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\ncontract ERC20Basic {\n\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address who) public view returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  /**\n\n  * @dev total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    emit Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   *\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n}\n\n\n\ncontract KNTTToken is StandardToken {\n\n  string public name    = \"KnightCommentToken\";\n\n  string public symbol  = \"KNTT\";\n\n  uint8 public decimals = 18;\n\n\n\n  // one billion in initial supply\n\n  uint256 public constant INITIAL_SUPPLY = 10000000000;\n\n\n\n  function KNTTToken() public {\n\n    totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));\n\n    balances[msg.sender] = totalSupply_;\n\n  }\n\n}"
  },
  {
    "id": 34,
    "addr4sss": "0x003ad9c18bc279f40632e7e5de2fd213931215d0",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n/**\n\n * @title IERC165\n\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n\n */\n\ninterface IERC165 {\n\n\n\n  /**\n\n   * @notice Query if a contract implements an interface\n\n   * @param interfaceId The interface identifier, as specified in ERC-165\n\n   * @dev Interface identification is specified in ERC-165. This function\n\n   * uses less than 30,000 gas.\n\n   */\n\n  function supportsInterface(bytes4 interfaceId)\n\n    external\n\n    view\n\n    returns (bool);\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title ERC165\n\n * @author Matt Condon (@shrugs)\n\n * @dev Implements ERC165 using a lookup table.\n\n */\n\ncontract ERC165 is IERC165 {\n\n\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n\n  /**\n\n   * 0x01ffc9a7 ===\n\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n\n   */\n\n\n\n  /**\n\n   * @dev a mapping of interface id to whether or not it's supported\n\n   */\n\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n\n\n  /**\n\n   * @dev A contract implementing SupportsInterfaceWithLookup\n\n   * implement ERC165 itself\n\n   */\n\n  constructor()\n\n    internal\n\n  {\n\n    _registerInterface(_InterfaceId_ERC165);\n\n  }\n\n\n\n  /**\n\n   * @dev implement supportsInterface(bytes4) using a lookup table\n\n   */\n\n  function supportsInterface(bytes4 interfaceId)\n\n    external\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _supportedInterfaces[interfaceId];\n\n  }\n\n\n\n  /**\n\n   * @dev internal method for registering an interface\n\n   */\n\n  function _registerInterface(bytes4 interfaceId)\n\n    internal\n\n  {\n\n    require(interfaceId != 0xffffffff);\n\n    _supportedInterfaces[interfaceId] = true;\n\n  }\n\n}\n\n\n\n// current address: 0x499E33164116002329Bf4bB8f7B2dfc97A31F223\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n\n * @title ERC721 Non-Fungible Token Standard basic interface\n\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n\n */\n\ncontract IERC721 is IERC165 {\n\n\n\n  event Transfer(\n\n    address indexed from,\n\n    address indexed to,\n\n    uint256 indexed tokenId\n\n  );\n\n  event Approval(\n\n    address indexed owner,\n\n    address indexed approved,\n\n    uint256 indexed tokenId\n\n  );\n\n  event ApprovalForAll(\n\n    address indexed owner,\n\n    address indexed operator,\n\n    bool approved\n\n  );\n\n\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n\n\n  function approve(address to, uint256 tokenId) public;\n\n  function getApproved(uint256 tokenId)\n\n    public view returns (address operator);\n\n\n\n  function setApprovalForAll(address operator, bool _approved) public;\n\n  function isApprovedForAll(address owner, address operator)\n\n    public view returns (bool);\n\n\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n\n    public;\n\n\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes data\n\n  )\n\n    public;\n\n}\n\n\n\n\n\n/**\n\n * @title ERC721 token receiver interface\n\n * @dev Interface for any contract that wants to support safeTransfers\n\n * from ERC721 asset contracts.\n\n */\n\ncontract IERC721Receiver {\n\n  /**\n\n   * @notice Handle the receipt of an NFT\n\n   * @dev The ERC721 smart contract calls this function on the recipient\n\n   * after a `safeTransfer`. This function MUST return the function selector,\n\n   * otherwise the caller will revert the transaction. The selector to be\n\n   * returned can be obtained as `this.onERC721Received.selector`. This\n\n   * function MAY throw to revert and reject the transfer.\n\n   * Note: the ERC721 contract address is always the message sender.\n\n   * @param operator The address which called `safeTransferFrom` function\n\n   * @param from The address which previously owned the token\n\n   * @param tokenId The NFT identifier which is being transferred\n\n   * @param data Additional data with no specified format\n\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\n   */\n\n  function onERC721Received(\n\n    address operator,\n\n    address from,\n\n    uint256 tokenId,\n\n    bytes data\n\n  )\n\n    public\n\n    returns(bytes4);\n\n}\n\n\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that revert on error\n\n */\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, reverts on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n    // benefit is lost if 'b' is also tested.\n\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n\n\n    uint256 c = a * b;\n\n    require(c / a == b);\n\n\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    require(b <= a);\n\n    uint256 c = a - b;\n\n\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, reverts on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    require(c >= a);\n\n\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n\n  * reverts when dividing by zero.\n\n  */\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    require(b != 0);\n\n    return a % b;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * Utility library of inline functions on addresses\n\n */\n\nlibrary Address {\n\n\n\n  /**\n\n   * Returns whether the target address is a contract\n\n   * @dev This function will return false if invoked during the constructor of a contract,\n\n   * as the code is not actually created until after the constructor finishes.\n\n   * @param account address of the account to check\n\n   * @return whether the target address is a contract\n\n   */\n\n  function isContract(address account) internal view returns (bool) {\n\n    uint256 size;\n\n    // XXX Currently there is no better way to check if there is a contract in an address\n\n    // than to check the size of the code at that address.\n\n    // See https://ethereum.stackexchange.com/a/14016/36603\n\n    // for more details about how this works.\n\n    // TODO Check this again before the Serenity release, because all addresses will be\n\n    // contracts then.\n\n    // solium-disable-next-line security/no-inline-assembly\n\n    assembly { size := extcodesize(account) }\n\n    return size > 0;\n\n  }\n\n\n\n}\n\n\n\n\n\n/**\n\n * @title ERC721 Non-Fungible Token Standard basic implementation\n\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n\n */\n\ncontract ERC721_custom is ERC165, IERC721 {\n\n\n\n  using SafeMath for uint256;\n\n  using Address for address;\n\n\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n\n\n  // Mapping from token ID to owner\n\n  mapping (uint256 => address) private _tokenOwner;\n\n\n\n  // Mapping from token ID to approved address\n\n  mapping (uint256 => address) private _tokenApprovals;\n\n\n\n  // Mapping from owner to number of owned token\n\n  mapping (address => uint256) private _ownedTokensCount;\n\n\n\n  // Mapping from owner to operator approvals\n\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n\n  /*\n\n   * 0x80ac58cd ===\n\n   *   bytes4(keccak256('balanceOf(address)')) ^\n\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n\n   */\n\n\n\n  constructor()\n\n    public\n\n  {\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n\n    _registerInterface(_InterfaceId_ERC721);\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the balance of the specified address\n\n   * @param owner address to query the balance of\n\n   * @return uint256 representing the amount owned by the passed address\n\n   */\n\n  function balanceOf(address owner) public view returns (uint256) {\n\n    require(owner != address(0));\n\n    return _ownedTokensCount[owner];\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the owner of the specified token ID\n\n   * @param tokenId uint256 ID of the token to query the owner of\n\n   * @return owner address currently marked as the owner of the given token ID\n\n   */\n\n  function ownerOf(uint256 tokenId) public view returns (address) {\n\n    address owner = _tokenOwner[tokenId];\n\n    require(owner != address(0));\n\n    return owner;\n\n  }\n\n\n\n  /**\n\n   * @dev Approves another address to transfer the given token ID\n\n   * The zero address indicates there is no approved address.\n\n   * There can only be one approved address per token at a given time.\n\n   * Can only be called by the token owner or an approved operator.\n\n   * @param to address to be approved for the given token ID\n\n   * @param tokenId uint256 ID of the token to be approved\n\n   */\n\n  function approve(address to, uint256 tokenId) public {\n\n    address owner = ownerOf(tokenId);\n\n    require(to != owner);\n\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n    _tokenApprovals[tokenId] = to;\n\n    emit Approval(owner, to, tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the approved address for a token ID, or zero if no address set\n\n   * Reverts if the token ID does not exist.\n\n   * @param tokenId uint256 ID of the token to query the approval of\n\n   * @return address currently approved for the given token ID\n\n   */\n\n  function getApproved(uint256 tokenId) public view returns (address) {\n\n    require(_exists(tokenId));\n\n    return _tokenApprovals[tokenId];\n\n  }\n\n\n\n  /**\n\n   * @dev Sets or unsets the approval of a given operator\n\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n\n   * @param to operator address to set the approval\n\n   * @param approved representing the status of the approval to be set\n\n   */\n\n  function setApprovalForAll(address to, bool approved) public {\n\n    require(to != msg.sender);\n\n    _operatorApprovals[msg.sender][to] = approved;\n\n    emit ApprovalForAll(msg.sender, to, approved);\n\n  }\n\n\n\n  /**\n\n   * @dev Tells whether an operator is approved by a given owner\n\n   * @param owner owner address which you want to query the approval of\n\n   * @param operator operator address which you want to query the approval of\n\n   * @return bool whether the given operator is approved by the given owner\n\n   */\n\n  function isApprovedForAll(\n\n    address owner,\n\n    address operator\n\n  )\n\n    public\n\n    view\n\n    returns (bool)\n\n  {\n\n    return _operatorApprovals[owner][operator];\n\n  }\n\n\n\n  /**\n\n   * @dev Transfers the ownership of a given token ID to another address\n\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n  */\n\n  function transferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId\n\n  )\n\n    public\n\n  {\n\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n\n    require(to != address(0));\n\n\n\n    _clearApproval(from, tokenId);\n\n    _removeTokenFrom(from, tokenId);\n\n    _addTokenTo(to, tokenId);\n\n\n\n    emit Transfer(from, to, tokenId);\n\n  }\n\n  \n\n  \n\n  \n\n  \n\n    function internal_transferFrom(\n\n        address _from,\n\n        address to,\n\n        uint256 tokenId\n\n    )\n\n    internal\n\n  {\n\n    // permissions already checked on price basis\n\n    \n\n    require(to != address(0));\n\n\n\n    if (_tokenApprovals[tokenId] != address(0)) {\n\n      _tokenApprovals[tokenId] = address(0);\n\n    }\n\n    \n\n    //_removeTokenFrom(from, tokenId);\n\n    if(_ownedTokensCount[_from] > 1) {\n\n    _ownedTokensCount[_from] = _ownedTokensCount[_from] -1; //.sub(1); // error here\n\n    // works without .sub()????\n\n    \n\n    }\n\n    _tokenOwner[tokenId] = address(0); \n\n    \n\n    _addTokenTo(to, tokenId); // error here?\n\n\n\n    emit Transfer(_from, to, tokenId);\n\n    \n\n  }\n\n\n\n  /**\n\n   * @dev Safely transfers the ownership of a given token ID to another address\n\n   * If the target address is a contract, it must implement `onERC721Received`,\n\n   * which is called upon a safe transfer, and return the magic value\n\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n   * the transfer is reverted.\n\n   *\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n  */\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId\n\n  )\n\n    public\n\n  {\n\n    // solium-disable-next-line arg-overflow\n\n    safeTransferFrom(from, to, tokenId, \"\");\n\n  }\n\n\n\n  /**\n\n   * @dev Safely transfers the ownership of a given token ID to another address\n\n   * If the target address is a contract, it must implement `onERC721Received`,\n\n   * which is called upon a safe transfer, and return the magic value\n\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n\n   * the transfer is reverted.\n\n   * Requires the msg sender to be the owner, approved, or operator\n\n   * @param from current owner of the token\n\n   * @param to address to receive the ownership of the given token ID\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @param _data bytes data to send along with a safe transfer check\n\n   */\n\n  function safeTransferFrom(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes _data\n\n  )\n\n    public\n\n  {\n\n    transferFrom(from, to, tokenId);\n\n    // solium-disable-next-line arg-overflow\n\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n\n  }\n\n\n\n  /**\n\n   * @dev Returns whether the specified token exists\n\n   * @param tokenId uint256 ID of the token to query the existence of\n\n   * @return whether the token exists\n\n   */\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n\n    address owner = _tokenOwner[tokenId];\n\n    return owner != address(0);\n\n  }\n\n\n\n  /**\n\n   * @dev Returns whether the given spender can transfer a given token ID\n\n   * @param spender address of the spender to query\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @return bool whether the msg.sender is approved for the given token ID,\n\n   *  is an operator of the owner, or is the owner of the token\n\n   */\n\n  function _isApprovedOrOwner(\n\n    address spender,\n\n    uint256 tokenId\n\n  )\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    address owner = ownerOf(tokenId);\n\n    // Disable solium check because of\n\n    // https://github.com/duaraghav8/Solium/issues/175\n\n    // solium-disable-next-line operator-whitespace\n\n    return (\n\n      spender == owner ||\n\n      getApproved(tokenId) == spender ||\n\n      isApprovedForAll(owner, spender)\n\n    );\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to mint a new token\n\n   * Reverts if the given token ID already exists\n\n   * @param to The address that will own the minted token\n\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n\n   */\n\n  function _mint(address to, uint256 tokenId) internal {\n\n    require(to != address(0));\n\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(address(0), to, tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to burn a specific token\n\n   * Reverts if the token does not exist\n\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n\n   */\n\n  function _burn(address owner, uint256 tokenId) internal {\n\n    _clearApproval(owner, tokenId);\n\n    _removeTokenFrom(owner, tokenId);\n\n    emit Transfer(owner, address(0), tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to add a token ID to the list of a given address\n\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n\n   * @param to address representing the new owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n   */\n\n  function _addTokenTo(address to, uint256 tokenId) internal {\n\n    require(_tokenOwner[tokenId] == address(0));\n\n    _tokenOwner[tokenId] = to;\n\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to remove a token ID from the list of a given address\n\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n\n   * and doesn't clear approvals.\n\n   * @param from address representing the previous owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n   */\n\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n    require(ownerOf(tokenId) == from);\n\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n\n    _tokenOwner[tokenId] = address(0);\n\n  }\n\n  \n\n  \n\n\n\n  /**\n\n   * @dev Internal function to invoke `onERC721Received` on a target address\n\n   * The call is not executed if the target address is not a contract\n\n   * @param from address representing the previous owner of the given token ID\n\n   * @param to target address that will receive the tokens\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   * @param _data bytes optional data to send along with the call\n\n   * @return whether the call correctly returned the expected magic value\n\n   */\n\n  function _checkOnERC721Received(\n\n    address from,\n\n    address to,\n\n    uint256 tokenId,\n\n    bytes _data\n\n  )\n\n    internal\n\n    returns (bool)\n\n  {\n\n    if (!to.isContract()) {\n\n      return true;\n\n    }\n\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n\n      msg.sender, from, tokenId, _data);\n\n    return (retval == _ERC721_RECEIVED);\n\n  }\n\n\n\n  /**\n\n   * @dev Private function to clear current approval of a given token ID\n\n   * Reverts if the given address is not indeed the owner of the token\n\n   * @param owner owner of the token\n\n   * @param tokenId uint256 ID of the token to be transferred\n\n   */\n\n  function _clearApproval(address owner, uint256 tokenId) private {\n\n    require(ownerOf(tokenId) == owner);\n\n    if (_tokenApprovals[tokenId] != address(0)) {\n\n      _tokenApprovals[tokenId] = address(0);\n\n    }\n\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n\n */\n\ncontract IERC721Enumerable is IERC721 {\n\n  function totalSupply() public view returns (uint256);\n\n  function tokenOfOwnerByIndex(\n\n    address owner,\n\n    uint256 index\n\n  )\n\n    public\n\n    view\n\n    returns (uint256 tokenId);\n\n\n\n  function tokenByIndex(uint256 index) public view returns (uint256);\n\n}\n\n\n\n\n\n\n\n/**\n\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n\n */\n\ncontract ERC721Enumerable_custom is ERC165, ERC721_custom, IERC721Enumerable {\n\n  // Mapping from owner to list of owned token IDs\n\n  mapping(address => uint256[]) private _ownedTokens;\n\n\n\n  // Mapping from token ID to index of the owner tokens list\n\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n\n\n  // Array with all token ids, used for enumeration\n\n  uint256[] private _allTokens;\n\n\n\n  // Mapping from token id to position in the allTokens array\n\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n\n\n  bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n\n  /**\n\n   * 0x780e9d63 ===\n\n   *   bytes4(keccak256('totalSupply()')) ^\n\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\n\n   */\n\n\n\n  /**\n\n   * @dev Constructor function\n\n   */\n\n  constructor() public {\n\n    // register the supported interface to conform to ERC721 via ERC165\n\n    _registerInterface(_InterfaceId_ERC721Enumerable);\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n\n   * @param owner address owning the tokens list to be accessed\n\n   * @param index uint256 representing the index to be accessed of the requested tokens list\n\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n\n   */\n\n  function tokenOfOwnerByIndex(\n\n    address owner,\n\n    uint256 index\n\n  )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    require(index < balanceOf(owner));\n\n    return _ownedTokens[owner][index];\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the total amount of tokens stored by the contract\n\n   * @return uint256 representing the total amount of tokens\n\n   */\n\n  function totalSupply() public view returns (uint256) {\n\n    return _allTokens.length;\n\n  }\n\n\n\n  /**\n\n   * @dev Gets the token ID at a given index of all the tokens in this contract\n\n   * Reverts if the index is greater or equal to the total number of tokens\n\n   * @param index uint256 representing the index to be accessed of the tokens list\n\n   * @return uint256 token ID at the given index of the tokens list\n\n   */\n\n  function tokenByIndex(uint256 index) public view returns (uint256) {\n\n    require(index < totalSupply());\n\n    return _allTokens[index];\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to add a token ID to the list of a given address\n\n   * This function is internal due to language limitations, see the note in ERC721.sol.\n\n   * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n\n   * @param to address representing the new owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n   */\n\n  function _addTokenTo(address to, uint256 tokenId) internal {\n\n    super._addTokenTo(to, tokenId);\n\n    uint256 length = _ownedTokens[to].length;\n\n    _ownedTokens[to].push(tokenId);\n\n    _ownedTokensIndex[tokenId] = length;\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to remove a token ID from the list of a given address\n\n   * This function is internal due to language limitations, see the note in ERC721.sol.\n\n   * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n\n   * and doesn't clear approvals.\n\n   * @param from address representing the previous owner of the given token ID\n\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n   */\n\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n\n    super._removeTokenFrom(from, tokenId);\n\n\n\n    // To prevent a gap in the array, we store the last token in the index of the token to delete, and\n\n    // then delete the last slot.\n\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n    uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n\n    uint256 lastToken = _ownedTokens[from][lastTokenIndex];\n\n\n\n    _ownedTokens[from][tokenIndex] = lastToken;\n\n    // This also deletes the contents at the last position of the array\n\n    _ownedTokens[from].length--;\n\n\n\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n\n    // be zero. Then we can make sure that we will remove tokenId from the ownedTokens list since we are first swapping\n\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n\n\n    _ownedTokensIndex[tokenId] = 0;\n\n    _ownedTokensIndex[lastToken] = tokenIndex;\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to mint a new token\n\n   * Reverts if the given token ID already exists\n\n   * @param to address the beneficiary that will own the minted token\n\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n\n   */\n\n  function _mint(address to, uint256 tokenId) internal {\n\n    super._mint(to, tokenId);\n\n\n\n    _allTokensIndex[tokenId] = _allTokens.length;\n\n    _allTokens.push(tokenId);\n\n  }\n\n\n\n  /**\n\n   * @dev Internal function to burn a specific token\n\n   * Reverts if the token does not exist\n\n   * @param owner owner of the token to burn\n\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n\n   */\n\n  function _burn(address owner, uint256 tokenId) internal {\n\n    super._burn(owner, tokenId);\n\n\n\n    // Reorg all tokens array\n\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n\n    uint256 lastTokenIndex = _allTokens.length.sub(1);\n\n    uint256 lastToken = _allTokens[lastTokenIndex];\n\n\n\n    _allTokens[tokenIndex] = lastToken;\n\n    _allTokens[lastTokenIndex] = 0;\n\n\n\n    _allTokens.length--;\n\n    _allTokensIndex[tokenId] = 0;\n\n    _allTokensIndex[lastToken] = tokenIndex;\n\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract IERC721Metadata is IERC721 {\n\n  function name() external view returns (string);\n\n  function symbol() external view returns (string);\n\n  function tokenURI(uint256 tokenId) external view returns (string);\n\n}\n\n\n\n\n\ncontract ERC721Metadata_custom is ERC165, ERC721_custom, IERC721Metadata {\n\n  // Token name\n\n  string private _name;\n\n\n\n  // Token symbol\n\n  string private _symbol;\n\n\n\n  // Optional mapping for token URIs\n\n  mapping(uint256 => string) private _tokenURIs;\n\n\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n\n  /**\n\n   * 0x5b5e139f ===\n\n   *   bytes4(keccak256('name()')) ^\n\n   *   bytes4(keccak256('symbol()')) ^\n\n   *   bytes4(keccak256('tokenURI(uint256)'))\n\n   */\n\n\n\n  /**\n\n   * @dev Constructor function\n\n   */\n\n  constructor(string name, string symbol) public {\n\n    _name = name;\n\n    _symbol = symbol;\n\n\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n\n    _registerInterface(InterfaceId_ERC721Metadata);\n\n  }\n\n\n\n  function name() external view returns (string) {\n\n    return _name;\n\n  }\n\n\n\n  \n\n  function symbol() external view returns (string) {\n\n    return _symbol;\n\n  }\n\n\n\n  \n\n  function tokenURI(uint256 tokenId) external view returns (string) {\n\n    require(_exists(tokenId));\n\n    return _tokenURIs[tokenId];\n\n  }\n\n\n\n  \n\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n\n    require(_exists(tokenId));\n\n    _tokenURIs[tokenId] = uri;\n\n  }\n\n\n\n  \n\n  function _burn(address owner, uint256 tokenId) internal {\n\n    super._burn(owner, tokenId);\n\n\n\n    // Clear metadata (if any)\n\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n\n      delete _tokenURIs[tokenId];\n\n    }\n\n  }\n\n}\n\n\n\n\n\ncontract ERC721Full_custom is ERC721_custom, ERC721Enumerable_custom, ERC721Metadata_custom {\n\n  constructor(string name, string symbol) ERC721Metadata_custom(name, symbol)\n\n    public\n\n  {\n\n  }\n\n}\n\n\n\n\n\ninterface PlanetCryptoCoin_I {\n\n    function balanceOf(address owner) external returns(uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n\n}\n\n\n\ninterface PlanetCryptoUtils_I {\n\n    function validateLand(address _sender, int256[] plots_lat, int256[] plots_lng) external returns(bool);\n\n    function validatePurchase(address _sender, uint256 _value, int256[] plots_lat, int256[] plots_lng) external returns(bool);\n\n    function validateTokenPurchase(address _sender, int256[] plots_lat, int256[] plots_lng) external returns(bool);\n\n    function validateResale(address _sender, uint256 _value, uint256 _token_id) external returns(bool);\n\n\n\n    //UTILS\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e, string _f) external view returns (string);\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) external view returns (string);\n\n    function strConcat(string _a, string _b, string _c, string _d) external view returns (string);\n\n    function strConcat(string _a, string _b, string _c) external view returns (string);\n\n    function strConcat(string _a, string _b) external view returns (string);\n\n    function int2str(int i) external view returns (string);\n\n    function uint2str(uint i) external view returns (string);\n\n    function substring(string str, uint startIndex, uint endIndex) external view returns (string);\n\n    function utfStringLength(string str) external view returns (uint length);\n\n    function ceil1(int256 a, int256 m) external view returns (int256 );\n\n    function parseInt(string _a, uint _b) external view returns (uint);\n\n}\n\n\n\nlibrary Percent {\n\n\n\n  struct percent {\n\n    uint num;\n\n    uint den;\n\n  }\n\n  function mul(percent storage p, uint a) internal view returns (uint) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    return a*p.num/p.den;\n\n  }\n\n\n\n  function div(percent storage p, uint a) internal view returns (uint) {\n\n    return a/p.num*p.den;\n\n  }\n\n\n\n  function sub(percent storage p, uint a) internal view returns (uint) {\n\n    uint b = mul(p, a);\n\n    if (b >= a) return 0;\n\n    return a - b;\n\n  }\n\n\n\n  function add(percent storage p, uint a) internal view returns (uint) {\n\n    return a + mul(p, a);\n\n  }\n\n}\n\n\n\n\n\n\n\ncontract PlanetCryptoToken is ERC721Full_custom{\n\n    \n\n    using Percent for Percent.percent;\n\n    \n\n    \n\n    // EVENTS\n\n        \n\n    event referralPaid(address indexed search_to,\n\n                    address to, uint256 amnt, uint256 timestamp);\n\n    \n\n    event issueCoinTokens(address indexed searched_to, \n\n                    address to, uint256 amnt, uint256 timestamp);\n\n    \n\n    event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, \n\n            uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp);\n\n    \n\n    event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp);\n\n    \n\n    event cardBought(\n\n                    uint256 indexed search_token_id, address indexed search_from, address indexed search_to,\n\n                    uint256 token_id, address from, address to, \n\n                    bytes32 name,\n\n                    uint256 orig_value, \n\n                    uint256 new_value,\n\n                    uint256 empireScore, uint256 newEmpireScore, uint256 now);\n\n\n\n    // CONTRACT MANAGERS\n\n    address owner;\n\n    address devBankAddress; // where marketing funds are sent\n\n    address tokenBankAddress; \n\n\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n    \n\n    modifier validateLand(int256[] plots_lat, int256[] plots_lng) {\n\n        \n\n        require(planetCryptoUtils_interface.validateLand(msg.sender, plots_lat, plots_lng) == true, \"Some of this land already owned!\");\n\n\n\n        \n\n        _;\n\n    }\n\n    \n\n    modifier validatePurchase(int256[] plots_lat, int256[] plots_lng) {\n\n\n\n        require(planetCryptoUtils_interface.validatePurchase(msg.sender, msg.value, plots_lat, plots_lng) == true, \"Not enough ETH!\");\n\n        _;\n\n    }\n\n    \n\n    \n\n    modifier validateTokenPurchase(int256[] plots_lat, int256[] plots_lng) {\n\n\n\n        require(planetCryptoUtils_interface.validateTokenPurchase(msg.sender, plots_lat, plots_lng) == true, \"Not enough COINS to buy these plots!\");\n\n        \n\n\n\n        \n\n\n\n        require(planetCryptoCoin_interface.transferFrom(msg.sender, tokenBankAddress, plots_lat.length) == true, \"Token transfer failed\");\n\n        \n\n        \n\n        _;\n\n    }\n\n    \n\n    \n\n    modifier validateResale(uint256 _token_id) {\n\n        require(planetCryptoUtils_interface.validateResale(msg.sender, msg.value, _token_id) == true, \"Not enough ETH to buy this card!\");\n\n        _;\n\n    }\n\n    \n\n    \n\n    modifier updateUsersLastAccess() {\n\n        \n\n        uint256 allPlyersIdx = playerAddressToPlayerObjectID[msg.sender];\n\n        if(allPlyersIdx == 0){\n\n\n\n            all_playerObjects.push(player(msg.sender,now,0,0));\n\n            playerAddressToPlayerObjectID[msg.sender] = all_playerObjects.length-1;\n\n        } else {\n\n            all_playerObjects[allPlyersIdx].lastAccess = now;\n\n        }\n\n        \n\n        _;\n\n    }\n\n    \n\n    // STRUCTS\n\n    struct plotDetail {\n\n        bytes32 name;\n\n        uint256 orig_value;\n\n        uint256 current_value;\n\n        uint256 empire_score;\n\n        int256[] plots_lat;\n\n        int256[] plots_lng;\n\n    }\n\n    \n\n    struct plotBasic {\n\n        int256 lat;\n\n        int256 lng;\n\n    }\n\n    \n\n    struct player {\n\n        address playerAddress;\n\n        uint256 lastAccess;\n\n        uint256 totalEmpireScore;\n\n        uint256 totalLand;\n\n        \n\n        \n\n    }\n\n    \n\n\n\n    // INTERFACES\n\n    address planetCryptoCoinAddress = 0xEF5B27207bD9Cd7B7708755CDF1A4523CB0b1f7D;\n\n    PlanetCryptoCoin_I internal planetCryptoCoin_interface;\n\n    \n\n\n\n    address planetCryptoUtilsAddress = 0x6cd067629939290C5aBFf20E1F6fC8bd750508C0;\n\n    PlanetCryptoUtils_I internal planetCryptoUtils_interface;\n\n    \n\n    \n\n    // settings\n\n    Percent.percent private m_newPlot_devPercent = Percent.percent(75,100); //75/100*100% = 75%\n\n    Percent.percent private m_newPlot_taxPercent = Percent.percent(25,100); //25%\n\n    \n\n    Percent.percent private m_resalePlot_devPercent = Percent.percent(10,100); // 10%\n\n    Percent.percent private m_resalePlot_taxPercent = Percent.percent(10,100); // 10%\n\n    Percent.percent private m_resalePlot_ownerPercent = Percent.percent(80,100); // 80%\n\n    \n\n    Percent.percent private m_refPercent = Percent.percent(5,100); // 5% referral \n\n    \n\n    Percent.percent private m_empireScoreMultiplier = Percent.percent(150,100); // 150%\n\n    Percent.percent private m_resaleMultipler = Percent.percent(200,100); // 200%;\n\n\n\n    \n\n    \n\n    \n\n    uint256 public devHoldings = 0; // holds dev funds in cases where the instant transfer fails\n\n\n\n\n\n    mapping(address => uint256) internal playersFundsOwed; // can sit within all_playerObjects\n\n\n\n\n\n\n\n\n\n\n\n    // add in limit of land plots before tokens stop being distributed\n\n    uint256 public tokens_rewards_available;\n\n    uint256 public tokens_rewards_allocated;\n\n    \n\n    // add in spend amount required to earn tokens\n\n    uint256 public min_plots_purchase_for_token_reward = 10;\n\n    uint256 public plots_token_reward_divisor = 10;\n\n    \n\n    \n\n    // GAME SETTINGS\n\n    uint256 public current_plot_price = 20000000000000000;\n\n    uint256 public price_update_amount = 2000000000000;\n\n\n\n    uint256 public current_plot_empire_score = 100;\n\n\n\n    \n\n    \n\n    uint256 public tax_fund = 0;\n\n    uint256 public tax_distributed = 0;\n\n\n\n\n\n    // GAME STATS\n\n    uint256 public total_land_sold = 0;\n\n    uint256 public total_trades = 0;\n\n\n\n    \n\n    uint256 public total_empire_score; \n\n    player[] public all_playerObjects;\n\n    mapping(address => uint256) internal playerAddressToPlayerObjectID;\n\n    \n\n    \n\n    \n\n    \n\n    plotDetail[] plotDetails;\n\n    mapping(uint256 => uint256) internal tokenIDplotdetailsIndexId; // e.g. tokenIDplotdetailsIndexId shows us the index of the detail obj for each token\n\n\n\n\n\n\n\n    \n\n    mapping(int256 => mapping(int256 => uint256)) internal latlngTokenID_grids;\n\n    mapping(uint256 => plotBasic[]) internal tokenIDlatlngLookup;\n\n    \n\n    \n\n    \n\n    mapping(uint8 => mapping(int256 => mapping(int256 => uint256))) internal latlngTokenID_zoomAll;\n\n\n\n    mapping(uint8 => mapping(uint256 => plotBasic[])) internal tokenIDlatlngLookup_zoomAll;\n\n\n\n\n\n   \n\n    \n\n    constructor() ERC721Full_custom(\"PlanetCrypto\", \"PTC\") public {\n\n        owner = msg.sender;\n\n        tokenBankAddress = owner;\n\n        devBankAddress = owner;\n\n        planetCryptoCoin_interface = PlanetCryptoCoin_I(planetCryptoCoinAddress);\n\n        planetCryptoUtils_interface = PlanetCryptoUtils_I(planetCryptoUtilsAddress);\n\n        \n\n        // empty playerAddressToPlayerObjectID player to allow easy checks...\n\n\n\n        all_playerObjects.push(player(address(0x0),0,0,0));\n\n        playerAddressToPlayerObjectID[address(0x0)] = 0;\n\n    }\n\n\n\n    \n\n\n\n    \n\n\n\n    function getToken(uint256 _tokenId, bool isBasic) public view returns(\n\n        address token_owner,\n\n        bytes32  name,\n\n        uint256 orig_value,\n\n        uint256 current_value,\n\n        uint256 empire_score,\n\n        int256[] plots_lat,\n\n        int256[] plots_lng\n\n        ) {\n\n        token_owner = ownerOf(_tokenId);\n\n        plotDetail memory _plotDetail = plotDetails[tokenIDplotdetailsIndexId[_tokenId]];\n\n        name = _plotDetail.name;\n\n        empire_score = _plotDetail.empire_score;\n\n        orig_value = _plotDetail.orig_value;\n\n        current_value = _plotDetail.current_value;\n\n        if(!isBasic){\n\n            plots_lat = _plotDetail.plots_lat;\n\n            plots_lng = _plotDetail.plots_lng;\n\n        } else {\n\n        }\n\n    }\n\n    \n\n    \n\n\n\n    function taxEarningsAvailable() public view returns(uint256) {\n\n        return playersFundsOwed[msg.sender];\n\n    }\n\n\n\n    function withdrawTaxEarning() public {\n\n        uint256 taxEarnings = playersFundsOwed[msg.sender];\n\n        playersFundsOwed[msg.sender] = 0;\n\n        tax_fund = tax_fund.sub(taxEarnings);\n\n        \n\n        if(!msg.sender.send(taxEarnings)) {\n\n            playersFundsOwed[msg.sender] = playersFundsOwed[msg.sender] + taxEarnings;\n\n            tax_fund = tax_fund.add(taxEarnings);\n\n        }\n\n    }\n\n\n\n    function buyLandWithTokens(bytes32 _name, int256[] _plots_lat, int256[] _plots_lng)\n\n     validateTokenPurchase(_plots_lat, _plots_lng) validateLand(_plots_lat, _plots_lng) updateUsersLastAccess() public {\n\n        require(_name.length > 4);\n\n        \n\n\n\n        processPurchase(_name, _plots_lat, _plots_lng); \n\n    }\n\n    \n\n\n\n    \n\n    function buyLand(bytes32 _name, \n\n            int256[] _plots_lat, int256[] _plots_lng,\n\n            address _referrer\n\n            )\n\n                validatePurchase(_plots_lat, _plots_lng) \n\n                validateLand(_plots_lat, _plots_lng) \n\n                updateUsersLastAccess()\n\n                public payable {\n\n       require(_name.length > 4);\n\n       \n\n        // split payment\n\n        uint256 _runningTotal = msg.value;\n\n        uint256 _referrerAmnt = 0;\n\n        if(_referrer != msg.sender && _referrer != address(0)) {\n\n            _referrerAmnt = m_refPercent.mul(msg.value);\n\n            if(_referrer.send(_referrerAmnt)) {\n\n                emit referralPaid(_referrer, _referrer, _referrerAmnt, now);\n\n                _runningTotal = _runningTotal.sub(_referrerAmnt);\n\n            }\n\n        }\n\n        \n\n        tax_fund = tax_fund.add(m_newPlot_taxPercent.mul(_runningTotal));\n\n        \n\n        \n\n        \n\n        if(!devBankAddress.send(m_newPlot_devPercent.mul(_runningTotal))){\n\n            devHoldings = devHoldings.add(m_newPlot_devPercent.mul(_runningTotal));\n\n        }\n\n        \n\n        \n\n        \n\n\n\n        processPurchase(_name, _plots_lat, _plots_lng);\n\n        \n\n        calcPlayerDivs(m_newPlot_taxPercent.mul(_runningTotal));\n\n        \n\n        if(_plots_lat.length >= min_plots_purchase_for_token_reward\n\n            && tokens_rewards_available > 0) {\n\n                \n\n            uint256 _token_rewards = _plots_lat.length / plots_token_reward_divisor;\n\n            if(_token_rewards > tokens_rewards_available)\n\n                _token_rewards = tokens_rewards_available;\n\n                \n\n                \n\n            planetCryptoCoin_interface.transfer(msg.sender, _token_rewards);\n\n                \n\n            emit issueCoinTokens(msg.sender, msg.sender, _token_rewards, now);\n\n            tokens_rewards_allocated = tokens_rewards_allocated + _token_rewards;\n\n            tokens_rewards_available = tokens_rewards_available - _token_rewards;\n\n        }\n\n    \n\n    }\n\n    \n\n    \n\n\n\n    function buyCard(uint256 _token_id, address _referrer) validateResale(_token_id) updateUsersLastAccess() public payable {\n\n        \n\n        \n\n        // split payment\n\n        uint256 _runningTotal = msg.value;\n\n        uint256 _referrerAmnt = 0;\n\n        if(_referrer != msg.sender && _referrer != address(0)) {\n\n            _referrerAmnt = m_refPercent.mul(msg.value);\n\n            if(_referrer.send(_referrerAmnt)) {\n\n                emit referralPaid(_referrer, _referrer, _referrerAmnt, now);\n\n                _runningTotal = _runningTotal.sub(_referrerAmnt);\n\n            }\n\n        }\n\n        \n\n        \n\n        tax_fund = tax_fund.add(m_resalePlot_taxPercent.mul(_runningTotal));\n\n        \n\n        \n\n        \n\n        if(!devBankAddress.send(m_resalePlot_devPercent.mul(_runningTotal))){\n\n            devHoldings = devHoldings.add(m_resalePlot_devPercent.mul(_runningTotal));\n\n        }\n\n        \n\n        \n\n\n\n        address from = ownerOf(_token_id);\n\n        \n\n        if(!from.send(m_resalePlot_ownerPercent.mul(_runningTotal))) {\n\n            playersFundsOwed[from] = playersFundsOwed[from].add(m_resalePlot_ownerPercent.mul(_runningTotal));\n\n        }\n\n        \n\n        \n\n\n\n        our_transferFrom(from, msg.sender, _token_id);\n\n        \n\n\n\n        plotDetail memory _plotDetail = plotDetails[tokenIDplotdetailsIndexId[_token_id]];\n\n        uint256 _empireScore = _plotDetail.empire_score;\n\n        uint256 _newEmpireScore = m_empireScoreMultiplier.mul(_empireScore);\n\n        uint256 _origValue = _plotDetail.current_value;\n\n        \n\n        uint256 _playerObject_idx = playerAddressToPlayerObjectID[msg.sender];\n\n        \n\n\n\n        all_playerObjects[_playerObject_idx].totalEmpireScore\n\n            = all_playerObjects[_playerObject_idx].totalEmpireScore + (_newEmpireScore - _empireScore);\n\n        \n\n        \n\n        plotDetails[tokenIDplotdetailsIndexId[_token_id]].empire_score = _newEmpireScore;\n\n\n\n        total_empire_score = total_empire_score + (_newEmpireScore - _empireScore);\n\n        \n\n        plotDetails[tokenIDplotdetailsIndexId[_token_id]].current_value = \n\n            m_resaleMultipler.mul(plotDetails[tokenIDplotdetailsIndexId[_token_id]].current_value);\n\n        \n\n        total_trades = total_trades + 1;\n\n        \n\n        \n\n        calcPlayerDivs(m_resalePlot_taxPercent.mul(_runningTotal));\n\n        \n\n        \n\n        // emit event\n\n        emit cardBought(_token_id, from, msg.sender,\n\n                    _token_id, from, msg.sender, \n\n                    _plotDetail.name,\n\n                    _origValue, \n\n                    msg.value,\n\n                    _empireScore, _newEmpireScore, now);\n\n    }\n\n    \n\n    function processPurchase(bytes32 _name, \n\n            int256[] _plots_lat, int256[] _plots_lng) internal {\n\n    \n\n        uint256 _token_id = totalSupply().add(1);\n\n        _mint(msg.sender, _token_id);\n\n        \n\n\n\n        \n\n\n\n        uint256 _empireScore =\n\n                    current_plot_empire_score * _plots_lng.length;\n\n            \n\n            \n\n        plotDetails.push(plotDetail(\n\n            _name,\n\n            current_plot_price * _plots_lat.length,\n\n            current_plot_price * _plots_lat.length,\n\n            _empireScore,\n\n            _plots_lat, _plots_lng\n\n        ));\n\n        \n\n        tokenIDplotdetailsIndexId[_token_id] = plotDetails.length-1;\n\n        \n\n        \n\n        setupPlotOwnership(_token_id, _plots_lat, _plots_lng);\n\n        \n\n        \n\n        \n\n        uint256 _playerObject_idx = playerAddressToPlayerObjectID[msg.sender];\n\n        all_playerObjects[_playerObject_idx].totalEmpireScore\n\n            = all_playerObjects[_playerObject_idx].totalEmpireScore + _empireScore;\n\n            \n\n        total_empire_score = total_empire_score + _empireScore;\n\n            \n\n        all_playerObjects[_playerObject_idx].totalLand\n\n            = all_playerObjects[_playerObject_idx].totalLand + _plots_lat.length;\n\n            \n\n        \n\n        emit landPurchased(\n\n                _token_id, msg.sender,\n\n                _token_id, msg.sender, _name, _plots_lat[0], _plots_lng[0], _plots_lat.length, current_plot_price, _empireScore, now);\n\n\n\n\n\n        current_plot_price = current_plot_price + (price_update_amount * _plots_lat.length);\n\n        total_land_sold = total_land_sold + _plots_lat.length;\n\n        \n\n    }\n\n\n\n\n\n\n\n\n\n    uint256 internal tax_carried_forward = 0;\n\n    \n\n    function calcPlayerDivs(uint256 _value) internal {\n\n        // total up amount split so we can emit it\n\n        if(totalSupply() > 1) {\n\n            uint256 _totalDivs = 0;\n\n            uint256 _totalPlayers = 0;\n\n            \n\n            uint256 _taxToDivide = _value + tax_carried_forward;\n\n            \n\n            // ignore player 0\n\n            for(uint256 c=1; c< all_playerObjects.length; c++) {\n\n                \n\n                // allow for 0.0001 % =  * 10000\n\n                \n\n                uint256 _playersPercent \n\n                    = (all_playerObjects[c].totalEmpireScore*10000000 / total_empire_score * 10000000) / 10000000;\n\n                uint256 _playerShare = _taxToDivide / 10000000 * _playersPercent;\n\n                \n\n                //uint256 _playerShare =  _taxToDivide * (all_playerObjects[c].totalEmpireScore / total_empire_score);\n\n                //_playerShare = _playerShare / 10000;\n\n                \n\n                if(_playerShare > 0) {\n\n                    \n\n                    incPlayerOwed(all_playerObjects[c].playerAddress,_playerShare);\n\n                    _totalDivs = _totalDivs + _playerShare;\n\n                    _totalPlayers = _totalPlayers + 1;\n\n                \n\n                }\n\n            }\n\n\n\n            tax_carried_forward = 0;\n\n            emit taxDistributed(_totalDivs, _totalPlayers, now);\n\n\n\n        } else {\n\n            // first land purchase - no divs this time, carried forward\n\n            tax_carried_forward = tax_carried_forward + _value;\n\n        }\n\n    }\n\n    \n\n    \n\n    function incPlayerOwed(address _playerAddr, uint256 _amnt) internal {\n\n        playersFundsOwed[_playerAddr] = playersFundsOwed[_playerAddr].add(_amnt);\n\n        tax_distributed = tax_distributed.add(_amnt);\n\n    }\n\n    \n\n    \n\n    function setupPlotOwnership(uint256 _token_id, int256[] _plots_lat, int256[] _plots_lng) internal {\n\n\n\n       for(uint256 c=0;c< _plots_lat.length;c++) {\n\n         \n\n            //mapping(int256 => mapping(int256 => uint256)) internal latlngTokenID_grids;\n\n            latlngTokenID_grids[_plots_lat[c]]\n\n                [_plots_lng[c]] = _token_id;\n\n                \n\n            //mapping(uint256 => plotBasic[]) internal tokenIDlatlngLookup;\n\n            tokenIDlatlngLookup[_token_id].push(plotBasic(\n\n                _plots_lat[c], _plots_lng[c]\n\n            ));\n\n            \n\n        }\n\n       \n\n        \n\n        int256 _latInt = _plots_lat[0];\n\n        int256 _lngInt = _plots_lng[0];\n\n\n\n\n\n\n\n        setupZoomLvl(1,_latInt, _lngInt, _token_id); // correct rounding / 10 on way out\n\n        setupZoomLvl(2,_latInt, _lngInt, _token_id); // correct rounding / 100\n\n        setupZoomLvl(3,_latInt, _lngInt, _token_id); // correct rounding / 1000\n\n        setupZoomLvl(4,_latInt, _lngInt, _token_id); // correct rounding / 10000\n\n      \n\n    }\n\n\n\n    function setupZoomLvl(uint8 zoom, int256 lat, int256 lng, uint256 _token_id) internal  {\n\n        \n\n        lat = roundLatLng(zoom, lat);\n\n        lng  = roundLatLng(zoom, lng); \n\n        \n\n        \n\n        uint256 _remover = 5;\n\n        if(zoom == 1)\n\n            _remover = 5;\n\n        if(zoom == 2)\n\n            _remover = 4;\n\n        if(zoom == 3)\n\n            _remover = 3;\n\n        if(zoom == 4)\n\n            _remover = 2;\n\n        \n\n        string memory _latStr;  // = int2str(lat);\n\n        string memory _lngStr; // = int2str(lng);\n\n\n\n        \n\n        \n\n        bool _tIsNegative = false;\n\n        \n\n        if(lat < 0) {\n\n            _tIsNegative = true;   \n\n            lat = lat * -1;\n\n        }\n\n        _latStr = planetCryptoUtils_interface.int2str(lat);\n\n        _latStr = planetCryptoUtils_interface.substring(_latStr,0,planetCryptoUtils_interface.utfStringLength(_latStr)-_remover); //_lat_len-_remover);\n\n        lat = int256(planetCryptoUtils_interface.parseInt(_latStr,0));\n\n        if(_tIsNegative)\n\n            lat = lat * -1;\n\n        \n\n        \n\n        //emit debugInt(\"ZOOM LNG1\", lng); // 1.1579208923731619542...\n\n        \n\n        if(lng < 0) {\n\n            _tIsNegative = true;\n\n            lng = lng * -1;\n\n        } else {\n\n            _tIsNegative = false;\n\n        }\n\n            \n\n        //emit debugInt(\"ZOOM LNG2\", lng); // 100000\n\n            \n\n        _lngStr = planetCryptoUtils_interface.int2str(lng);\n\n        \n\n        _lngStr = planetCryptoUtils_interface.substring(_lngStr,0,planetCryptoUtils_interface.utfStringLength(_lngStr)-_remover);\n\n        \n\n        lng = int256(planetCryptoUtils_interface.parseInt(_lngStr,0));\n\n        \n\n        if(_tIsNegative)\n\n            lng = lng * -1;\n\n    \n\n        \n\n        latlngTokenID_zoomAll[zoom][lat][lng] = _token_id;\n\n        tokenIDlatlngLookup_zoomAll[zoom][_token_id].push(plotBasic(lat,lng));\n\n        \n\n      \n\n   \n\n        \n\n        \n\n    }\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n    function getAllPlayerObjectLen() public view returns(uint256){\n\n        return all_playerObjects.length;\n\n    }\n\n    \n\n\n\n    function queryMap(uint8 zoom, int256[] lat_rows, int256[] lng_columns) public view returns(string _outStr) {\n\n        \n\n        \n\n        for(uint256 y=0; y< lat_rows.length; y++) {\n\n\n\n            for(uint256 x=0; x< lng_columns.length; x++) {\n\n                \n\n                \n\n                \n\n                if(zoom == 0){\n\n                    if(latlngTokenID_grids[lat_rows[y]][lng_columns[x]] > 0){\n\n                        \n\n                        \n\n                      _outStr = planetCryptoUtils_interface.strConcat(\n\n                            _outStr, '[', planetCryptoUtils_interface.int2str(lat_rows[y]) , ':', planetCryptoUtils_interface.int2str(lng_columns[x]) );\n\n                      _outStr = planetCryptoUtils_interface.strConcat(_outStr, ':', \n\n                                    planetCryptoUtils_interface.uint2str(latlngTokenID_grids[lat_rows[y]][lng_columns[x]]), ']');\n\n                    }\n\n                    \n\n                } else {\n\n                    //_out[c] = latlngTokenID_zoomAll[zoom][lat_rows[y]][lng_columns[x]];\n\n                    if(latlngTokenID_zoomAll[zoom][lat_rows[y]][lng_columns[x]] > 0){\n\n                      _outStr = planetCryptoUtils_interface.strConcat(_outStr, '[', planetCryptoUtils_interface.int2str(lat_rows[y]) , ':', planetCryptoUtils_interface.int2str(lng_columns[x]) );\n\n                      _outStr = planetCryptoUtils_interface.strConcat(_outStr, ':', \n\n                                    planetCryptoUtils_interface.uint2str(latlngTokenID_zoomAll[zoom][lat_rows[y]][lng_columns[x]]), ']');\n\n                    }\n\n                    \n\n                }\n\n                //c = c+1;\n\n                \n\n            }\n\n        }\n\n        \n\n        //return _out;\n\n    }\n\n\n\n    function queryPlotExists(uint8 zoom, int256[] lat_rows, int256[] lng_columns) public view returns(bool) {\n\n        \n\n        \n\n        for(uint256 y=0; y< lat_rows.length; y++) {\n\n\n\n            for(uint256 x=0; x< lng_columns.length; x++) {\n\n                \n\n                if(zoom == 0){\n\n                    if(latlngTokenID_grids[lat_rows[y]][lng_columns[x]] > 0){\n\n                        return true;\n\n                    } \n\n                } else {\n\n                    if(latlngTokenID_zoomAll[zoom][lat_rows[y]][lng_columns[x]] > 0){\n\n\n\n                        return true;\n\n                        \n\n                    }                     \n\n                }\n\n           \n\n                \n\n            }\n\n        }\n\n        \n\n        return false;\n\n    }\n\n\n\n    \n\n    function roundLatLng(uint8 _zoomLvl, int256 _in) internal view returns(int256) {\n\n        int256 multipler = 100000;\n\n        if(_zoomLvl == 1)\n\n            multipler = 100000;\n\n        if(_zoomLvl == 2)\n\n            multipler = 10000;\n\n        if(_zoomLvl == 3)\n\n            multipler = 1000;\n\n        if(_zoomLvl == 4)\n\n            multipler = 100;\n\n        if(_zoomLvl == 5)\n\n            multipler = 10;\n\n        \n\n        if(_in > 0){\n\n            // round it\n\n            _in = planetCryptoUtils_interface.ceil1(_in, multipler);\n\n        } else {\n\n            _in = _in * -1;\n\n            _in = planetCryptoUtils_interface.ceil1(_in, multipler);\n\n            _in = _in * -1;\n\n        }\n\n        \n\n        return (_in);\n\n        \n\n    }\n\n    \n\n\n\n   \n\n\n\n\n\n\n\n\n\n    // ERC721 overrides\n\n    \n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n\n        safeTransferFrom(from, to, tokenId, \"\");\n\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data) public {\n\n        transferFrom(from, to, tokenId);\n\n        // solium-disable-next-line arg-overflow\n\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n\n    }\n\n    \n\n    function our_transferFrom(address from, address to, uint256 tokenId) internal {\n\n        // permissions already checked on buycard\n\n        process_swap(from,to,tokenId);\n\n        \n\n        internal_transferFrom(from, to, tokenId);\n\n    }\n\nfunction debug_transfer(address from, address to, uint256 tokenId) public {\n\n    super.internal_transferFrom(from, to, tokenId);\n\n}\n\n\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n\n        // check permission on the from address first\n\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        require(to != address(0));\n\n        \n\n        process_swap(from,to,tokenId);\n\n        \n\n        super.transferFrom(from, to, tokenId);\n\n\n\n    }\n\n    \n\n    function process_swap(address from, address to, uint256 tokenId) internal {\n\n\n\n        \n\n        // remove the empire score & total land owned...\n\n        uint256 _empireScore;\n\n        uint256 _size;\n\n        \n\n        plotDetail memory _plotDetail = plotDetails[tokenIDplotdetailsIndexId[tokenId]];\n\n        _empireScore = _plotDetail.empire_score;\n\n        _size = _plotDetail.plots_lat.length;\n\n        \n\n        uint256 _playerObject_idx = playerAddressToPlayerObjectID[from];\n\n        \n\n        all_playerObjects[_playerObject_idx].totalEmpireScore\n\n            = all_playerObjects[_playerObject_idx].totalEmpireScore - _empireScore;\n\n            \n\n        all_playerObjects[_playerObject_idx].totalLand\n\n            = all_playerObjects[_playerObject_idx].totalLand - _size;\n\n            \n\n        // and increment on the other side...\n\n        \n\n        _playerObject_idx = playerAddressToPlayerObjectID[to];\n\n        \n\n        all_playerObjects[_playerObject_idx].totalEmpireScore\n\n            = all_playerObjects[_playerObject_idx].totalEmpireScore + _empireScore;\n\n            \n\n        all_playerObjects[_playerObject_idx].totalLand\n\n            = all_playerObjects[_playerObject_idx].totalLand + _size;\n\n    }\n\n\n\n\n\n    function burnToken(uint256 _tokenId) external onlyOwner {\n\n        address _token_owner = ownerOf(_tokenId);\n\n        _burn(_token_owner, _tokenId);\n\n        \n\n        \n\n        // remove the empire score & total land owned...\n\n        uint256 _empireScore;\n\n        uint256 _size;\n\n        \n\n        plotDetail memory _plotDetail = plotDetails[tokenIDplotdetailsIndexId[_tokenId]];\n\n        _empireScore = _plotDetail.empire_score;\n\n        _size = _plotDetail.plots_lat.length;\n\n        \n\n        uint256 _playerObject_idx = playerAddressToPlayerObjectID[_token_owner];\n\n        \n\n        all_playerObjects[_playerObject_idx].totalEmpireScore\n\n            = all_playerObjects[_playerObject_idx].totalEmpireScore - _empireScore;\n\n            \n\n        all_playerObjects[_playerObject_idx].totalLand\n\n            = all_playerObjects[_playerObject_idx].totalLand - _size;\n\n            \n\n       \n\n        \n\n        for(uint256 c=0;c < tokenIDlatlngLookup[_tokenId].length; c++) {\n\n            latlngTokenID_grids[\n\n                    tokenIDlatlngLookup[_tokenId][c].lat\n\n                ][tokenIDlatlngLookup[_tokenId][c].lng] = 0;\n\n        }\n\n        delete tokenIDlatlngLookup[_tokenId];\n\n        \n\n        \n\n        \n\n        //Same for tokenIDplotdetailsIndexId        \n\n        // clear from plotDetails array... (Holds the detail of the card)\n\n        uint256 oldIndex = tokenIDplotdetailsIndexId[_tokenId];\n\n        if(oldIndex != plotDetails.length-1) {\n\n            plotDetails[oldIndex] = plotDetails[plotDetails.length-1];\n\n        }\n\n        plotDetails.length--;\n\n        \n\n\n\n        delete tokenIDplotdetailsIndexId[_tokenId];\n\n\n\n\n\n\n\n        for(uint8 zoom=1; zoom < 5; zoom++) {\n\n            plotBasic[] storage _plotBasicList = tokenIDlatlngLookup_zoomAll[zoom][_tokenId];\n\n            for(uint256 _plotsC=0; c< _plotBasicList.length; _plotsC++) {\n\n                delete latlngTokenID_zoomAll[zoom][\n\n                    _plotBasicList[_plotsC].lat\n\n                    ][\n\n                        _plotBasicList[_plotsC].lng\n\n                        ];\n\n                        \n\n                delete _plotBasicList[_plotsC];\n\n            }\n\n            \n\n        }\n\n    \n\n    \n\n\n\n\n\n\n\n    }    \n\n\n\n\n\n\n\n    // PRIVATE METHODS\n\n    function p_update_action(uint256 _type, address _address) public onlyOwner {\n\n        if(_type == 0){\n\n            owner = _address;    \n\n        }\n\n        if(_type == 1){\n\n            tokenBankAddress = _address;    \n\n        }\n\n        if(_type == 2) {\n\n            devBankAddress = _address;\n\n        }\n\n    }\n\n\n\n\n\n    function p_update_priceUpdateAmount(uint256 _price_update_amount) public onlyOwner {\n\n        price_update_amount = _price_update_amount;\n\n    }\n\n    function p_update_currentPlotEmpireScore(uint256 _current_plot_empire_score) public onlyOwner {\n\n        current_plot_empire_score = _current_plot_empire_score;\n\n    }\n\n    function p_update_planetCryptoCoinAddress(address _planetCryptoCoinAddress) public onlyOwner {\n\n        planetCryptoCoinAddress = _planetCryptoCoinAddress;\n\n        if(address(planetCryptoCoinAddress) != address(0)){ \n\n            planetCryptoCoin_interface = PlanetCryptoCoin_I(planetCryptoCoinAddress);\n\n        }\n\n    }\n\n    function p_update_planetCryptoUtilsAddress(address _planetCryptoUtilsAddress) public onlyOwner {\n\n        planetCryptoUtilsAddress = _planetCryptoUtilsAddress;\n\n        if(address(planetCryptoUtilsAddress) != address(0)){ \n\n            planetCryptoUtils_interface = PlanetCryptoUtils_I(planetCryptoUtilsAddress);\n\n        }\n\n    }\n\n    function p_update_mNewPlotDevPercent(uint256 _newPercent) onlyOwner public {\n\n        m_newPlot_devPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mNewPlotTaxPercent(uint256 _newPercent) onlyOwner public {\n\n        m_newPlot_taxPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mResalePlotDevPercent(uint256 _newPercent) onlyOwner public {\n\n        m_resalePlot_devPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mResalePlotTaxPercent(uint256 _newPercent) onlyOwner public {\n\n        m_resalePlot_taxPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mResalePlotOwnerPercent(uint256 _newPercent) onlyOwner public {\n\n        m_resalePlot_ownerPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mRefPercent(uint256 _newPercent) onlyOwner public {\n\n        m_refPercent = Percent.percent(_newPercent,100);\n\n    }\n\n    function p_update_mEmpireScoreMultiplier(uint256 _newPercent) onlyOwner public {\n\n        m_empireScoreMultiplier = Percent.percent(_newPercent, 100);\n\n    }\n\n    function p_update_mResaleMultipler(uint256 _newPercent) onlyOwner public {\n\n        m_resaleMultipler = Percent.percent(_newPercent, 100);\n\n    }\n\n    function p_update_tokensRewardsAvailable(uint256 _tokens_rewards_available) onlyOwner public {\n\n        tokens_rewards_available = _tokens_rewards_available;\n\n    }\n\n    function p_update_tokensRewardsAllocated(uint256 _tokens_rewards_allocated) onlyOwner public {\n\n        tokens_rewards_allocated = _tokens_rewards_allocated;\n\n    }\n\n    function p_withdrawDevHoldings() public {\n\n        require(msg.sender == devBankAddress);\n\n        uint256 _t = devHoldings;\n\n        devHoldings = 0;\n\n        if(!devBankAddress.send(devHoldings)){\n\n            devHoldings = _t;\n\n        }\n\n    }\n\n\n\n\n\n    function stringToBytes32(string memory source) internal returns (bytes32 result) {\n\n        bytes memory tempEmptyStringTest = bytes(source);\n\n        if (tempEmptyStringTest.length == 0) {\n\n            return 0x0;\n\n        }\n\n    \n\n        assembly {\n\n            result := mload(add(source, 32))\n\n        }\n\n    }\n\n\n\n    function m() public {\n\n        \n\n    }\n\n    \n\n}"
  },
  {
    "id": 35,
    "addr4sss": "0x003f79d7be15dc1ad90ce00e6ea68f335e2b789b",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.13;\n\n\n\ncontract ERC20 {\n\n     function totalSupply() constant returns (uint256 totalSupply);\n\n     function balanceOf(address _owner) constant returns (uint256 balance);\n\n     function transfer(address _to, uint256 _value) returns (bool success);\n\n     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n     function approve(address _spender, uint256 _value) returns (bool success);\n\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n }\n\n  \n\n  contract TzTToken is ERC20 {\n\n     string public constant symbol = \"TZT\";\n\n     string public constant name = \"TZT\";\n\n     uint8 public constant decimals = 8;\n\n     uint256 _totalSupply = 1000000000 * 10**8;\n\n     \n\n\n\n     address public owner;\n\n  \n\n     mapping(address => uint256) balances;\n\n  \n\n     mapping(address => mapping (address => uint256)) allowed;\n\n     \n\n  \n\n     function TzTToken() {\n\n         owner = msg.sender;\n\n         balances[owner] = 1000000000 * 10**8;\n\n     }\n\n     \n\n     modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n     \n\n     \n\n     function distributeToken(address[] addresses, uint256 _value) onlyOwner {\n\n     for (uint i = 0; i < addresses.length; i++) {\n\n         balances[owner] -= _value * 10**8;\n\n         balances[addresses[i]] += _value * 10**8;\n\n         Transfer(owner, addresses[i], _value * 10**8);\n\n     }\n\n}\n\n     \n\n\n\n     \n\n  \n\n     function totalSupply() constant returns (uint256 totalSupply) {\n\n         totalSupply = _totalSupply;\n\n     }\n\n  \n\n\n\n     function balanceOf(address _owner) constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n     }\n\n \n\n     function transfer(address _to, uint256 _amount) returns (bool success) {\n\n         if (balances[msg.sender] >= _amount \n\n            && _amount > 0\n\n             && balances[_to] + _amount > balances[_to]) {\n\n             balances[msg.sender] -= _amount;\n\n             balances[_to] += _amount;\n\n             Transfer(msg.sender, _to, _amount);\n\n            return true;\n\n         } else {\n\n             return false;\n\n         }\n\n     }\n\n     \n\n     \n\n     function transferFrom(\n\n         address _from,\n\n         address _to,\n\n         uint256 _amount\n\n     ) returns (bool success) {\n\n         if (balances[_from] >= _amount\n\n             && allowed[_from][msg.sender] >= _amount\n\n             && _amount > 0\n\n             && balances[_to] + _amount > balances[_to]) {\n\n             balances[_from] -= _amount;\n\n             allowed[_from][msg.sender] -= _amount;\n\n             balances[_to] += _amount;\n\n             Transfer(_from, _to, _amount);\n\n             return true;\n\n         } else {\n\n            return false;\n\n         }\n\n     }\n\n \n\n     function approve(address _spender, uint256 _amount) returns (bool success) {\n\n         allowed[msg.sender][_spender] = _amount;\n\n        Approval(msg.sender, _spender, _amount);\n\n         return true;\n\n     }\n\n  \n\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n         return allowed[_owner][_spender];\n\n    }\n\n}"
  },
  {
    "id": 36,
    "addr4sss": "0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ncontract owned {\n\n    address public owner;\n\n    address public manager;\n\n\n\n    constructor() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    modifier onlyManager {\n\n        require(msg.sender == manager);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        owner = newOwner;\n\n    }\n\n\n\n    function setManager(address newManager) onlyOwner public {\n\n        manager = newManager;\n\n    }\n\n}\n\n\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\n\n\ncontract TokenERC20 {\n\n    string public name = \"Robot Trading Token\";\n\n    string public detail = \"Robot Trading token ERC20\";\n\n    string public symbol =\"RTD\";\n\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply = 0;\n\n    address public owner;\n\n    address[] public owners;\n\n\n\n    mapping (address => bool) ownerAppended;\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping (address => bool) public frozenAccount;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Burn(address indexed from, uint256 value);\n\n    event FrozenFunds(address target, bool frozen);\n\n    event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount);\n\n    event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount);\n\n\n\n    constructor() public {}\n\n\n\n    function totalSupply() public view returns (uint256) {\n\n        return totalSupply;\n\n    }\n\n\n\n    function getOwner(uint index) public view returns (address, uint256) {\n\n        return (owners[index], balanceOf[owners[index]]);\n\n    }\n\n\n\n    function getOwnerCount() public view returns (uint) {\n\n        return owners.length;\n\n    }\n\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        require(!frozenAccount[_from]);\n\n        require(!frozenAccount[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n\n        if(!ownerAppended[_to]) {\n\n            ownerAppended[_to] = true;\n\n            owners.push(_to);\n\n        }\n\n\n\n        emit Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n        _transfer(msg.sender, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public\n\n        returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n\n        public\n\n        returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);\n\n        balanceOf[msg.sender] -= _value;\n\n        totalSupply -= _value;\n\n        emit Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\n        require(balanceOf[_from] >= _value);\n\n        require(_value <= allowance[_from][msg.sender]);\n\n        balanceOf[_from] -= _value;\n\n        allowance[_from][msg.sender] -= _value;\n\n        totalSupply -= _value;\n\n        emit Burn(_from, _value);\n\n        return true;\n\n    }\n\n}\n\n\n\ncontract Coin{\n\n  function transfer(address to, uint value) public returns (bool);\n\n}\n\n\n\ncontract Token is owned, TokenERC20 {\n\n    address public ico_address;\n\n    address public old_address;\n\n    address public app_address;\n\n\n\n    constructor() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    function setDetail(string tokenDetail) onlyOwner public {\n\n        detail = tokenDetail;\n\n    }\n\n\n\n    function() payable public {}\n\n\n\n    function setApp(address _app_address) onlyOwner public {\n\n        app_address = _app_address;\n\n    }\n\n\n\n    function importFromOld(address _ico_address, address _old_address, address[] _to, uint256[] _value) onlyOwner public {\n\n        ico_address = _ico_address;\n\n        old_address = _old_address;\n\n        for (uint256 i = 0; i < _to.length; i++) {\n\n            balanceOf[_to[i]] += _value[i] * 10 ** uint256(12);\n\n            totalSupply += _value[i] * 10 ** uint256(12);\n\n            if(!ownerAppended[_to[i]]) {\n\n                ownerAppended[_to[i]] = true;\n\n                owners.push(_to[i]);\n\n            }\n\n            emit Transfer(old_address, _to[i], _value[i] * 10 ** uint256(12));\n\n        }\n\n    }\n\n\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n\n        balanceOf[target] += mintedAmount;\n\n        totalSupply += mintedAmount;\n\n\n\n        if(!ownerAppended[target]) {\n\n            ownerAppended[target] = true;\n\n            owners.push(target);\n\n        }\n\n\n\n        emit Transfer(0, this, mintedAmount);\n\n        emit Transfer(this, target, mintedAmount);\n\n    }\n\n\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n\n        frozenAccount[target] = freeze;\n\n        emit FrozenFunds(target, freeze);\n\n    }\n\n\n\n    function withdrawEther() onlyOwner public {\n\n        manager.transfer(address(this).balance);\n\n    }\n\n\n\n    function withdrawToken(address _tokenAddr,uint256 _value) onlyOwner public {\n\n        assert(Coin(_tokenAddr).transfer(owner, _value) == true);\n\n    }\n\n\n\n    function airDropCoin(uint256 _value)  onlyOwner public {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n            address(owners[i]).transfer(balanceOf[owners[i]]/_value);\n\n            emit AirDropCoin(address(owners[i]), balanceOf[owners[i]], _value, (balanceOf[owners[i]]/_value));\n\n        }\n\n    }\n\n\n\n    function airDropToken(address _tokenAddr,uint256 _value)  onlyOwner public {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n             assert((Coin(_tokenAddr).transfer(address(owners[i]), balanceOf[owners[i]] / _value)) == true);\n\n             emit AirDropToken(address(_tokenAddr), address(owners[i]), balanceOf[owners[i]], _value, (balanceOf[owners[i]]/_value));\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 37,
    "addr4sss": "0x00416b9d728069edb0ceb04bc2b203fa7336d1f1",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "/*\n\n\n\n  Copyright 2017 Cofound.it.\n\n\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n\n  you may not use this file except in compliance with the License.\n\n  You may obtain a copy of the License at\n\n\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n\n\n  Unless required by applicable law or agreed to in writing, software\n\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n  See the License for the specific language governing permissions and\n\n  limitations under the License.\n\n\n\n*/\n\n\n\npragma solidity ^0.4.13;\n\n\n\ncontract ReentrancyHandlingContract {\n\n\n\n    bool locked;\n\n\n\n    modifier noReentrancy() {\n\n        require(!locked);\n\n        locked = true;\n\n        _;\n\n        locked = false;\n\n    }\n\n}\n\ncontract Owned {\n\n    address public owner;\n\n    address public newOwner;\n\n\n\n    function Owned() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        assert(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n\n        require(_newOwner != owner);\n\n        newOwner = _newOwner;\n\n    }\n\n\n\n    function acceptOwnership() public {\n\n        require(msg.sender == newOwner);\n\n        OwnerUpdate(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = 0x0;\n\n    }\n\n\n\n    event OwnerUpdate(address _prevOwner, address _newOwner);\n\n}\n\ncontract PriorityPassInterface {\n\n    function getAccountLimit(address _accountAddress) public constant returns (uint);\n\n    function getAccountActivity(address _accountAddress) public constant returns (bool);\n\n}\n\ncontract ERC20TokenInterface {\n\n  function totalSupply() public constant returns (uint256 _totalSupply);\n\n  function balanceOf(address _owner) public constant returns (uint256 balance);\n\n  function transfer(address _to, uint256 _value) public returns (bool success);\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n  function approve(address _spender, uint256 _value) public returns (bool success);\n\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\n\ncontract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned {\n\n\n\n  struct ContributorData {\n\n    uint contributionAmount;\n\n  }\n\n\n\n  mapping(address => ContributorData) public contributorList;\n\n  uint public nextContributorIndex;\n\n  mapping(uint => address) public contributorIndexes;\n\n\n\n  state public crowdsaleState = state.pendingStart;\n\n  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsaleEnded }\n\n\n\n  uint public presaleStartTime;\n\n  uint public presaleUnlimitedStartTime;\n\n  uint public crowdsaleEndedTime;\n\n\n\n  event PresaleStarted(uint blocktime);\n\n  event PresaleUnlimitedStarted(uint blocktime);\n\n  event CrowdsaleEnded(uint blocktime);\n\n  event ErrorSendingETH(address to, uint amount);\n\n  event MinCapReached(uint blocktime);\n\n  event MaxCapReached(uint blocktime);\n\n  event ContributionMade(address indexed contributor, uint amount);\n\n\n\n  PriorityPassInterface priorityPassContract = PriorityPassInterface(0x0);\n\n\n\n  uint public minCap;\n\n  uint public maxP1Cap;\n\n  uint public maxCap;\n\n  uint public ethRaised;\n\n\n\n  address public multisigAddress;\n\n\n\n  uint nextContributorToClaim;\n\n  mapping(address => bool) hasClaimedEthWhenFail;\n\n\n\n  //\n\n  // Unnamed function that runs when eth is sent to the contract\n\n  // @payable\n\n  //\n\n  function() noReentrancy payable public {\n\n    require(msg.value != 0);                                                    // Throw if value is 0\n\n    require(crowdsaleState != state.crowdsaleEnded);                            // Check if crowdsale has ended\n\n\n\n    bool stateChanged = checkCrowdsaleState();                                  // Check blocks time and calibrate crowdsale state\n\n\n\n    if (crowdsaleState == state.priorityPass) {\n\n      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\n\n        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\n\n      } else {\n\n        refundTransaction(stateChanged);                                        // Set state and return funds or throw\n\n      }\n\n    } else if (crowdsaleState == state.openedPriorityPass) {\n\n      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\n\n        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\n\n      } else {\n\n        refundTransaction(stateChanged);                                        // Set state and return funds or throw\n\n      }\n\n    } else {\n\n      refundTransaction(stateChanged);                                          // Set state and return funds or throw\n\n    }\n\n  }\n\n\n\n  //\n\n  // @internal checks crowdsale state and emits events it\n\n  // @returns boolean\n\n  //\n\n  function checkCrowdsaleState() internal returns (bool) {\n\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {        // Check if max cap is reached\n\n      crowdsaleState = state.crowdsaleEnded;\n\n      MaxCapReached(block.timestamp);                                           // Close the crowdsale\n\n      CrowdsaleEnded(block.timestamp);                                          // Raise event\n\n      return true;\n\n    }\n\n\n\n    if (block.timestamp > presaleStartTime && block.timestamp <= presaleUnlimitedStartTime) { // Check if we are in presale phase\n\n      if (crowdsaleState != state.priorityPass) {                               // Check if state needs to be changed\n\n        crowdsaleState = state.priorityPass;                                    // Set new state\n\n        PresaleStarted(block.timestamp);                                        // Raise event\n\n        return true;\n\n      }\n\n    } else if (block.timestamp > presaleUnlimitedStartTime && block.timestamp <= crowdsaleEndedTime) {  // Check if we are in presale unlimited phase\n\n      if (crowdsaleState != state.openedPriorityPass) {                         // Check if state needs to be changed\n\n        crowdsaleState = state.openedPriorityPass;                              // Set new state\n\n        PresaleUnlimitedStarted(block.timestamp);                               // Raise event\n\n        return true;\n\n      }\n\n    } else {\n\n      if (crowdsaleState != state.crowdsaleEnded && block.timestamp > crowdsaleEndedTime) {// Check if crowdsale is over\n\n        crowdsaleState = state.crowdsaleEnded;                                  // Set new state\n\n        CrowdsaleEnded(block.timestamp);                                        // Raise event\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n\n  }\n\n\n\n  //\n\n  // @internal determines if return eth or throw according to changing state\n\n  // @param _stateChanged boolean message about state change\n\n  //\n\n  function refundTransaction(bool _stateChanged) internal {\n\n    if (_stateChanged) {\n\n      msg.sender.transfer(msg.value);\n\n    } else {\n\n      revert();\n\n    }\n\n  }\n\n\n\n  //\n\n  // Getter to calculate how much user can contribute\n\n  // @param _contributor address of the contributor\n\n  //\n\n  function calculateMaxContribution(address _contributor) constant public returns (uint maxContribution) {\n\n    uint maxContrib;\n\n\n\n    if (crowdsaleState == state.priorityPass) {                                 // Check if we are in priority pass\n\n      maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount;\n\n\n\n\t    if (maxContrib > (maxP1Cap - ethRaised)) {                                // Check if max contribution is more that max cap\n\n        maxContrib = maxP1Cap - ethRaised;                                      // Alter max cap\n\n      }\n\n\n\n    } else {\n\n      maxContrib = maxCap - ethRaised;                                          // Alter max cap\n\n    }\n\n    return maxContrib;\n\n  }\n\n\n\n  //\n\n  // Return if there is overflow of contributed eth\n\n  // @internal processes transactions\n\n  // @param _contributor address of an contributor\n\n  // @param _amount contributed amount\n\n  //\n\n  function processTransaction(address _contributor, uint _amount) internal {\n\n    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n\n    uint contributionAmount = _amount;\n\n    uint returnAmount = 0;\n\n\n\n\t  if (maxContribution < _amount) {                                            // Check if max contribution is lower than _amount sent\n\n      contributionAmount = maxContribution;                                     // Set that user contributes his maximum alowed contribution\n\n      returnAmount = _amount - maxContribution;                                 // Calculate how much he must get back\n\n    }\n\n\n\n    if (ethRaised + contributionAmount >= minCap && minCap > ethRaised) {\n\n      MinCapReached(block.timestamp);\n\n    } \n\n\n\n    if (contributorList[_contributor].contributionAmount == 0) {                // Check if contributor has already contributed\n\n      contributorList[_contributor].contributionAmount = contributionAmount;    // Set their contribution\n\n      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n\n      nextContributorIndex++;\n\n    } else {\n\n      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n\n    }\n\n    ethRaised += contributionAmount;                                            // Add to eth raised\n\n\n\n    ContributionMade(msg.sender, contributionAmount);                           // Raise event about contribution\n\n\n\n\t  if (returnAmount != 0) {\n\n      _contributor.transfer(returnAmount);                                      // Return overflow of ether\n\n    } \n\n  }\n\n\n\n  //\n\n  // Recovers ERC20 tokens other than eth that are send to this address\n\n  // @owner refunds the erc20 tokens\n\n  // @param _tokenAddress address of the erc20 token\n\n  // @param _to address to where tokens should be send to\n\n  // @param _amount amount of tokens to refund\n\n  //\n\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n\n  }\n\n\n\n  //\n\n  // withdrawEth when minimum cap is reached\n\n  // @owner sets contributions to withdraw\n\n  //\n\n  function withdrawEth() onlyOwner public {\n\n    require(this.balance != 0);\n\n    require(ethRaised >= minCap);\n\n\n\n    pendingEthWithdrawal = this.balance;\n\n  }\n\n\n\n\n\n  uint public pendingEthWithdrawal;\n\n  //\n\n  // pulls the funds that were set to send with calling of\n\n  // withdrawEth when minimum cap is reached\n\n  // @multisig pulls the contributions to self\n\n  //\n\n  function pullBalance() public {\n\n    require(msg.sender == multisigAddress);\n\n    require(pendingEthWithdrawal > 0);\n\n\n\n    multisigAddress.transfer(pendingEthWithdrawal);\n\n    pendingEthWithdrawal = 0;\n\n  }\n\n\n\n  //\n\n  // Owner can batch return contributors contributions(eth)\n\n  // @owner returns contributions\n\n  // @param _numberOfReturns number of returns to do in one transaction\n\n  //\n\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n\n    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);        // Check if crowdsale has failed\n\n\n\n    address currentParticipantAddress;\n\n    uint contribution;\n\n\n\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];   // Get next unclaimed participant\n\n\n\n      if (currentParticipantAddress == 0x0) {\n\n         return;                                                                // Check if all the participants were compensated\n\n      }\n\n\n\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                  // Check if participant has already claimed\n\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                // Set that he has claimed\n\n\n\n        if (!currentParticipantAddress.send(contribution)) {                    // Refund eth\n\n          ErrorSendingETH(currentParticipantAddress, contribution);             // If there is an issue raise event for manual recovery\n\n        }\n\n      }\n\n      nextContributorToClaim += 1;                                              // Repeat\n\n    }\n\n  }\n\n\n\n  //\n\n  // If there were any issue with refund owner can withdraw eth at the end for manual recovery\n\n  // @owner withdraws remaining funds\n\n  //\n\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n\n    require(this.balance != 0);                                                 // Check if there are any eth to claim\n\n    require(block.timestamp > crowdsaleEndedTime);                              // Check if crowdsale is over\n\n    require(contributorIndexes[nextContributorToClaim] == 0x0);                 // Check if all the users were refunded\n\n    multisigAddress.transfer(this.balance);                                     // Withdraw to multisig for manual processing\n\n  }\n\n\n\n  //\n\n  // Owner can set multisig address for crowdsale\n\n  // @owner sets an address where funds will go\n\n  // @param _newAddress\n\n  //\n\n  function setMultisigAddress(address _newAddress) onlyOwner public {\n\n    multisigAddress = _newAddress;\n\n  }\n\n\n\n  //\n\n  // Setter for the whitelist contract\n\n  // @owner sets address of whitelist contract\n\n  // @param address\n\n  //\n\n  function setPriorityPassContract(address _newAddress) onlyOwner public {\n\n    priorityPassContract = PriorityPassInterface(_newAddress);\n\n  }\n\n\n\n  //\n\n  // Getter for the whitelist contract\n\n  // @returns white list contract address\n\n  //\n\n  function priorityPassContractAddress() constant public returns (address) {\n\n    return address(priorityPassContract);\n\n  }\n\n\n\n  //\n\n  // Before crowdsale starts owner can calibrate time of crowdsale stages\n\n  // @owner sends new times for the sale\n\n  // @param _presaleStartTime timestamp for sale limited start\n\n  // @param _presaleUnlimitedStartTime timestamp for sale unlimited\n\n  // @param _crowdsaleEndedTime timestamp for ending sale\n\n  //\n\n  function setCrowdsaleTimes(uint _presaleStartTime, uint _presaleUnlimitedStartTime, uint _crowdsaleEndedTime) onlyOwner public {\n\n    require(crowdsaleState == state.pendingStart);                              // Check if crowdsale has started\n\n    require(_presaleStartTime != 0);                                            // Check if any value is 0\n\n    require(_presaleStartTime < _presaleUnlimitedStartTime);                    // Check if presaleUnlimitedStartTime is set properly\n\n    require(_presaleUnlimitedStartTime != 0);                                   // Check if any value is 0\n\n    require(_presaleUnlimitedStartTime < _crowdsaleEndedTime);                  // Check if crowdsaleEndedTime is set properly\n\n    require(_crowdsaleEndedTime != 0);                                          // Check if any value is 0\n\n    presaleStartTime = _presaleStartTime;\n\n    presaleUnlimitedStartTime = _presaleUnlimitedStartTime;\n\n    crowdsaleEndedTime = _crowdsaleEndedTime;\n\n  }\n\n\n\n}\n\n\n\ncontract AversafeSeedCrowdsale is SeedCrowdsaleContract {\n\n  \n\n  function AversafeSeedCrowdsale() {\n\n\n\n    presaleStartTime = 1512032400;\n\n    presaleUnlimitedStartTime = 1512063000;\n\n    crowdsaleEndedTime = 1512140400;\n\n\n\n    minCap = 451 ether;\n\n    maxP1Cap = 802 ether;\n\n    maxCap = 891 ether;\n\n  }\n\n}"
  },
  {
    "id": 38,
    "addr4sss": "0x0042d589023cfd5a979388f5be6e4abf532ab9af",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.0;\n\n/**\n\n * Overflow aware uint math functions.\n\n *\n\n * Inspired by https://github.com/MakerDAO/maker-otc/blob/master/contracts/simple_market.sol\n\n */\n\n \n\n contract SafeMath {\n\n  //internals\n\n\n\n  function safeMul(uint a, uint b) internal returns (uint) {\n\n    uint c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n\n    uint c = a + b;\n\n    assert(c>=a && c>=b);\n\n    return c;\n\n  }\n\n\n\n  function assert(bool assertion) internal {\n\n    if (!assertion) throw;\n\n  }\n\n}\n\n\n\n/**\n\n * ERC 20 token\n\n *\n\n * https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract Token {\n\n\n\n    /// @return total amount of tokens\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of wei to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n\n}\n\n\n\n/**\n\n * ERC 20 token\n\n *\n\n * https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract StandardToken is Token {\n\n\n\n    /**\n\n     * Reviewed:\n\n     * - Interger overflow = OK, checked\n\n     */\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n\n        //Replace the if with this one instead.\n\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        //if (balances[msg.sender] >= _value && _value > 0) {\n\n            balances[msg.sender] -= _value;\n\n            balances[_to] += _value;\n\n            Transfer(msg.sender, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n\n            balances[_to] += _value;\n\n            balances[_from] -= _value;\n\n            allowed[_from][msg.sender] -= _value;\n\n            Transfer(_from, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n\t\n\n\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n      return allowed[_owner][_spender];\n\n    }\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n\n\n    //uint256 public totalSupply;\n\n\n\n}\n\n\n\n\n\n/**\n\n * Service Chain contract.\n\n *\n\n *\n\n */\n\n\n\n contract ServiceChainToken is StandardToken, SafeMath {\n\n\t \n\n    string public constant symbol =\"SER\";\n\n    string public constant name = \"Service Chain Token\";\n\n    uint256 public constant decimals = 18;\n\n\t\t\n\n\tuint256 public constant _totalSupply = 200000000 * 10**18;\n\n\t\n\n\t   \n\n\tfunction ServiceChainToken(){\n\n        balances[msg.sender] = _totalSupply;\n\n    }\n\n\t\n\n\tfunction totalSupply() constant returns (uint256 supply) {\n\n\t\treturn _totalSupply;\n\n\t}\n\n }"
  },
  {
    "id": 39,
    "addr4sss": "0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\ncontract owned {\n\n    address public owner;\n\n\n\n    function owned() {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner {\n\n        owner = newOwner;\n\n    }\n\n}\n\ncontract MyToken is owned {\n\n    // Public variables of the token\n\n    string public name = \"Empyrean Mark\";\n\n    string public symbol = \"MARK\";\n\n    uint8 public decimals;\n\n    uint256 public totalSupply;\n\n\n\n    // This creates an array with all balances\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    // This generates a public event on the blockchain that will notify clients\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    // This notifies clients about the amount burnt\n\n    event Burn(address indexed from, uint256 value);\n\n\n\n    /**\n\n     * Constructor function\n\n     *\n\n     * Initializes contract with initial supply tokens to the creator of the contract\n\n     */\n\n    function MyToken(\n\n        uint256 initialSupply,\n\n        string tokenName,\n\n        uint8 decimalUnits,\n\n        string tokenSymbol\n\n    ) {\n\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n\n        totalSupply = initialSupply;                        // Update total supply\n\n        name = tokenName;                                   // Set the name for display purposes\n\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\n\n    }\n\n\n\n    /**\n\n     * Internal transfer, only can be called by this contract\n\n     */\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n\n        require(balanceOf[_from] >= _value);                // Check if the sender has enough\n\n        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n\n        Transfer(_from, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens\n\n     *\n\n     * Send `_value` tokens to `_to` from your account\n\n     *\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transfer(address _to, uint256 _value) {\n\n        _transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * Transfer tokens from other address\n\n     *\n\n     * Send `_value` tokens to `_to` in behalf of `_from`\n\n     *\n\n     * @param _from The address of the sender\n\n     * @param _to The address of the recipient\n\n     * @param _value the amount to send\n\n     */\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     */\n\n    function approve(address _spender, uint256 _value)\n\n        returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Set allowance for other address and notify\n\n     *\n\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n\n     *\n\n     * @param _spender The address authorized to spend\n\n     * @param _value the max amount they can spend\n\n     * @param _extraData some extra information to send to the approved contract\n\n     */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n\n        returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly\n\n     *\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burn(uint256 _value) returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n\n        totalSupply -= _value;                      // Updates totalSupply\n\n        Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * Destroy tokens from other ccount\n\n     *\n\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n\n     *\n\n     * @param _from the address of the sender\n\n     * @param _value the amount of money to burn\n\n     */\n\n    function burnFrom(address _from, uint256 _value) returns (bool success) {\n\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n\n        totalSupply -= _value;                              // Update totalSupply\n\n        Burn(_from, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * New tokens can be minted\n\n     *\n\n     * Allows owner account to mint new tokens, or remove tokens from supply as needed\n\n     *\n\n     */\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n\n        balanceOf[target] += mintedAmount;\n\n        totalSupply += mintedAmount;\n\n        Transfer(0, owner, mintedAmount);\n\n        Transfer(owner, target, mintedAmount);\n\n    }\n\n}"
  },
  {
    "id": 40,
    "addr4sss": "0x004460229a42542772f21ee82b8772cc6f2a502b",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "contract InfraCoin {\n\n    /* Public variables of the token */\n\n    string public standard = 'Token 0.1';\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    uint256 public initialSupply;\n\n    uint256 public totalSupply;\n\n\n\n    /* This creates an array with all balances */\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n  \n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n\n    function InfraCoin() {\n\n\n\n         initialSupply = 240000000;\n\n         name =\"InfraCoin\";\n\n        decimals = 8;\n\n         symbol = \"IRB\";\n\n        \n\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n\n        totalSupply = initialSupply;                        // Update total supply\n\n                                   \n\n    }\n\n\n\n    /* Send coins */\n\n    function transfer(address _to, uint256 _value) {\n\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n\n      \n\n    }\n\n\n\n   \n\n\n\n    \n\n\n\n   \n\n\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n\n    function () {\n\n        throw;     // Prevents accidental sending of ether\n\n    }\n\n}"
  },
  {
    "id": 41,
    "addr4sss": "0x0045684552109f8551cc5c8aa7b1f52085adff47",
    "ARTHM": 1,
    "DOS": 1,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 1,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "DOS",
        "SWC-ID": "SWC-113, SWC-128",
        "Description": "Denial of Service"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      },
      {
        "vulnerability": "UE",
        "SWC-ID": "SWC-104",
        "Description": "Unhandled Exception (Unchecked Call Return Value)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n/**\n\n * @title Module\n\n * @dev Interface for a module. \n\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n\n * can never end up in a \"frozen\" state.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ninterface Module {\n\n\n\n    /**\n\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n\n     * @param _wallet The wallet.\n\n     */\n\n    function init(BaseWallet _wallet) external;\n\n\n\n    /**\n\n     * @dev Adds a module to a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _module The modules to authorise.\n\n     */\n\n    function addModule(BaseWallet _wallet, Module _module) external;\n\n\n\n    /**\n\n    * @dev Utility method to recover any ERC20 token that was sent to the\n\n    * module by mistake. \n\n    * @param _token The token to recover.\n\n    */\n\n    function recoverToken(address _token) external;\n\n}\n\n\n\n/**\n\n * @title Upgrader\n\n * @dev Interface for a contract that can upgrade wallets by enabling/disabling modules. \n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ninterface Upgrader {\n\n\n\n    /**\n\n     * @dev Upgrades a wallet by enabling/disabling modules.\n\n     * @param _wallet The owner.\n\n     */\n\n    function upgrade(address _wallet, address[] _toDisable, address[] _toEnable) external;\n\n\n\n    function toDisable() external view returns (address[]);\n\n\n\n    function toEnable() external view returns (address[]);\n\n}\n\n\n\n/**\n\n * ERC20 contract interface.\n\n */\n\ncontract ERC20 {\n\n    function totalSupply() public view returns (uint);\n\n    function decimals() public view returns (uint);\n\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n\n    function transfer(address to, uint tokens) public returns (bool success);\n\n    function approve(address spender, uint tokens) public returns (bool success);\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n}\n\n\n\n/**\n\n * @title Owned\n\n * @dev Basic contract to define an owner.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract Owned {\n\n\n\n    // The owner\n\n    address public owner;\n\n\n\n    event OwnerChanged(address indexed _newOwner);\n\n\n\n    /**\n\n     * @dev Throws if the sender is not the owner.\n\n     */\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner, \"Must be owner\");\n\n        _;\n\n    }\n\n\n\n    constructor() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    /**\n\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\n\n     * @param _newOwner The new owner.\n\n     */\n\n    function changeOwner(address _newOwner) external onlyOwner {\n\n        require(_newOwner != address(0), \"Address must not be null\");\n\n        owner = _newOwner;\n\n        emit OwnerChanged(_newOwner);\n\n    }\n\n}\n\n\n\n/**\n\n * @title BaseWallet\n\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\n\n * Based on https://gist.github.com/Arachnid/a619d31f6d32757a4328a428286da186 by \n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract BaseWallet {\n\n\n\n    // The implementation of the proxy\n\n    address public implementation;\n\n    // The owner \n\n    address public owner;\n\n    // The authorised modules\n\n    mapping (address => bool) public authorised;\n\n    // The enabled static calls\n\n    mapping (bytes4 => address) public enabled;\n\n    // The number of modules\n\n    uint public modules;\n\n    \n\n    event AuthorisedModule(address indexed module, bool value);\n\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    event OwnerChanged(address owner);\n\n    \n\n    /**\n\n     * @dev Throws if the sender is not an authorised module.\n\n     */\n\n    modifier moduleOnly {\n\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\n\n     * @param _owner The owner.\n\n     * @param _modules The modules to authorise.\n\n     */\n\n    function init(address _owner, address[] _modules) external {\n\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n\n        owner = _owner;\n\n        modules = _modules.length;\n\n        for(uint256 i = 0; i < _modules.length; i++) {\n\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n\n            authorised[_modules[i]] = true;\n\n            Module(_modules[i]).init(this);\n\n            emit AuthorisedModule(_modules[i], true);\n\n        }\n\n    }\n\n    \n\n    /**\n\n     * @dev Enables/Disables a module.\n\n     * @param _module The target module.\n\n     * @param _value Set to true to authorise the module.\n\n     */\n\n    function authoriseModule(address _module, bool _value) external moduleOnly {\n\n        if (authorised[_module] != _value) {\n\n            if(_value == true) {\n\n                modules += 1;\n\n                authorised[_module] = true;\n\n                Module(_module).init(this);\n\n            }\n\n            else {\n\n                modules -= 1;\n\n                require(modules > 0, \"BW: wallet must have at least one module\");\n\n                delete authorised[_module];\n\n            }\n\n            emit AuthorisedModule(_module, _value);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Enables a static method by specifying the target module to which the call\n\n    * must be delegated.\n\n    * @param _module The target module.\n\n    * @param _method The static method signature.\n\n    */\n\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\n\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n\n        enabled[_method] = _module;\n\n        emit EnabledStaticCall(_module, _method);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets a new owner for the wallet.\n\n     * @param _newOwner The new owner.\n\n     */\n\n    function setOwner(address _newOwner) external moduleOnly {\n\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n\n        owner = _newOwner;\n\n        emit OwnerChanged(_newOwner);\n\n    }\n\n    \n\n    /**\n\n     * @dev Performs a generic transaction.\n\n     * @param _target The address for the transaction.\n\n     * @param _value The value of the transaction.\n\n     * @param _data The data of the transaction.\n\n     */\n\n    function invoke(address _target, uint _value, bytes _data) external moduleOnly {\n\n        // solium-disable-next-line security/no-call-value\n\n        require(_target.call.value(_value)(_data), \"BW: call to target failed\");\n\n        emit Invoked(msg.sender, _target, _value, _data);\n\n    }\n\n\n\n    /**\n\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\n\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds \n\n     * to an enabled method, or logs the call otherwise.\n\n     */\n\n    function() public payable {\n\n        if(msg.data.length > 0) { \n\n            address module = enabled[msg.sig];\n\n            if(module == address(0)) {\n\n                emit Received(msg.value, msg.sender, msg.data);\n\n            } \n\n            else {\n\n                require(authorised[module], \"BW: must be an authorised module for static call\");\n\n                // solium-disable-next-line security/no-inline-assembly\n\n                assembly {\n\n                    calldatacopy(0, 0, calldatasize())\n\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\n\n                    returndatacopy(0, 0, returndatasize())\n\n                    switch result \n\n                    case 0 {revert(0, returndatasize())} \n\n                    default {return (0, returndatasize())}\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\n\n\n/**\n\n * @title ModuleRegistry\n\n * @dev Registry of authorised modules. \n\n * Modules must be registered before they can be authorised on a wallet.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract ModuleRegistry is Owned {\n\n\n\n    mapping (address => Info) internal modules;\n\n    mapping (address => Info) internal upgraders;\n\n\n\n    event ModuleRegistered(address indexed module, bytes32 name);\n\n    event ModuleDeRegistered(address module);\n\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\n\n    event UpgraderDeRegistered(address upgrader);\n\n\n\n    struct Info {\n\n        bool exists;\n\n        bytes32 name;\n\n    }\n\n\n\n    /**\n\n     * @dev Registers a module.\n\n     * @param _module The module.\n\n     * @param _name The unique name of the module.\n\n     */\n\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\n\n        require(!modules[_module].exists, \"MR: module already exists\");\n\n        modules[_module] = Info({exists: true, name: _name});\n\n        emit ModuleRegistered(_module, _name);\n\n    }\n\n\n\n    /**\n\n     * @dev Deregisters a module.\n\n     * @param _module The module.\n\n     */\n\n    function deregisterModule(address _module) external onlyOwner {\n\n        require(modules[_module].exists, \"MR: module does not exists\");\n\n        delete modules[_module];\n\n        emit ModuleDeRegistered(_module);\n\n    }\n\n\n\n        /**\n\n     * @dev Registers an upgrader.\n\n     * @param _upgrader The upgrader.\n\n     * @param _name The unique name of the upgrader.\n\n     */\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\n\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\n\n        upgraders[_upgrader] = Info({exists: true, name: _name});\n\n        emit UpgraderRegistered(_upgrader, _name);\n\n    }\n\n\n\n    /**\n\n     * @dev Deregisters an upgrader.\n\n     * @param _upgrader The _upgrader.\n\n     */\n\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\n\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exists\");\n\n        delete upgraders[_upgrader];\n\n        emit UpgraderDeRegistered(_upgrader);\n\n    }\n\n\n\n    /**\n\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\n\n    * registry.\n\n    * @param _token The token to recover.\n\n    */\n\n    function recoverToken(address _token) external onlyOwner {\n\n        uint total = ERC20(_token).balanceOf(address(this));\n\n        ERC20(_token).transfer(msg.sender, total);\n\n    } \n\n\n\n    /**\n\n     * @dev Gets the name of a module from its address.\n\n     * @param _module The module address.\n\n     * @return the name.\n\n     */\n\n    function moduleInfo(address _module) external view returns (bytes32) {\n\n        return modules[_module].name;\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the name of an upgrader from its address.\n\n     * @param _upgrader The upgrader address.\n\n     * @return the name.\n\n     */\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\n\n        return upgraders[_upgrader].name;\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if a module is registered.\n\n     * @param _module The module address.\n\n     * @return true if the module is registered.\n\n     */\n\n    function isRegisteredModule(address _module) external view returns (bool) {\n\n        return modules[_module].exists;\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if a list of modules are registered.\n\n     * @param _modules The list of modules address.\n\n     * @return true if all the modules are registered.\n\n     */\n\n    function isRegisteredModule(address[] _modules) external view returns (bool) {\n\n        for(uint i = 0; i < _modules.length; i++) {\n\n            if (!modules[_modules[i]].exists) {\n\n                return false;\n\n            }\n\n        }\n\n        return true;\n\n    }  \n\n\n\n    /**\n\n     * @dev Checks if an upgrader is registered.\n\n     * @param _upgrader The upgrader address.\n\n     * @return true if the upgrader is registered.\n\n     */\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\n\n        return upgraders[_upgrader].exists;\n\n    } \n\n}\n\n\n\n/**\n\n * @title BaseModule\n\n * @dev Basic module that contains some methods common to all modules.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract BaseModule is Module {\n\n\n\n    // The adddress of the module registry.\n\n    ModuleRegistry internal registry;\n\n\n\n    event ModuleCreated(bytes32 name);\n\n    event ModuleInitialised(address wallet);\n\n\n\n    constructor(ModuleRegistry _registry, bytes32 _name) public {\n\n        registry = _registry;\n\n        emit ModuleCreated(_name);\n\n    }\n\n\n\n    /**\n\n     * @dev Throws if the sender is not the target wallet of the call.\n\n     */\n\n    modifier onlyWallet(BaseWallet _wallet) {\n\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\n\n     */\n\n    modifier onlyOwner(BaseWallet _wallet) {\n\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be an owner for the wallet\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Throws if the sender is not the owner of the target wallet.\n\n     */\n\n    modifier strictOnlyOwner(BaseWallet _wallet) {\n\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Inits the module for a wallet by logging an event.\n\n     * The method can only be called by the wallet itself.\n\n     * @param _wallet The wallet.\n\n     */\n\n    function init(BaseWallet _wallet) external onlyWallet(_wallet) {\n\n        emit ModuleInitialised(_wallet);\n\n    }\n\n\n\n    /**\n\n     * @dev Adds a module to a wallet. First checks that the module is registered.\n\n     * @param _wallet The target wallet.\n\n     * @param _module The modules to authorise.\n\n     */\n\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyOwner(_wallet) {\n\n        require(registry.isRegisteredModule(_module), \"BM: module is not registered\");\n\n        _wallet.authoriseModule(_module, true);\n\n    }\n\n\n\n    /**\n\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\n\n    * module by mistake and transfer them to the Module Registry. \n\n    * @param _token The token to recover.\n\n    */\n\n    function recoverToken(address _token) external {\n\n        uint total = ERC20(_token).balanceOf(address(this));\n\n        ERC20(_token).transfer(address(registry), total);\n\n    }\n\n\n\n    /**\n\n     * @dev Helper method to check if an address is the owner of a target wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _addr The address.\n\n     */\n\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n\n        return _wallet.owner() == _addr;\n\n    }\n\n}\n\n\n\n/**\n\n * @title RelayerModule\n\n * @dev Base module containing logic to execute transactions signed by eth-less accounts and sent by a relayer. \n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract RelayerModule is Module {\n\n\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n\n\n    mapping (address => RelayerConfig) public relayer; \n\n\n\n    struct RelayerConfig {\n\n        uint256 nonce;\n\n        mapping (bytes32 => bool) executedTx;\n\n    }\n\n\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes32 signedHash);\n\n\n\n    /**\n\n     * @dev Throws if the call did not go through the execute() method.\n\n     */\n\n    modifier onlyExecute {\n\n        require(msg.sender == address(this), \"RM: must be called via execute()\");\n\n        _;\n\n    }\n\n\n\n    /* ***************** Abstract method ************************* */\n\n\n\n    /**\n\n    * @dev Gets the number of valid signatures that must be provided to execute a\n\n    * specific relayed transaction.\n\n    * @param _wallet The target wallet.\n\n    * @param _data The data of the relayed transaction.\n\n    * @return The number of required signatures.\n\n    */\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256);\n\n\n\n    /**\n\n    * @dev Validates the signatures provided with a relayed transaction.\n\n    * The method MUST throw if one or more signatures are not valid.\n\n    * @param _wallet The target wallet.\n\n    * @param _data The data of the relayed transaction.\n\n    * @param _signHash The signed hash representing the relayed transaction.\n\n    * @param _signatures The signatures as a concatenated byte array.\n\n    */\n\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool);\n\n\n\n    /* ************************************************************ */\n\n\n\n    /**\n\n    * @dev Executes a relayed transaction.\n\n    * @param _wallet The target wallet.\n\n    * @param _data The data for the relayed transaction\n\n    * @param _nonce The nonce used to prevent replay attacks.\n\n    * @param _signatures The signatures as a concatenated byte array.\n\n    * @param _gasPrice The gas price to use for the gas refund.\n\n    * @param _gasLimit The gas limit to use for the gas refund.\n\n    */\n\n    function execute(\n\n        BaseWallet _wallet,\n\n        bytes _data, \n\n        uint256 _nonce, \n\n        bytes _signatures, \n\n        uint256 _gasPrice,\n\n        uint256 _gasLimit\n\n    )\n\n        external\n\n        returns (bool success)\n\n    {\n\n        uint startGas = gasleft();\n\n        bytes32 signHash = getSignHash(address(this), _wallet, 0, _data, _nonce, _gasPrice, _gasLimit);\n\n        require(checkAndUpdateUniqueness(_wallet, _nonce, signHash), \"RM: Duplicate request\");\n\n        require(verifyData(address(_wallet), _data), \"RM: the wallet authorized is different then the target of the relayed data\");\n\n        uint256 requiredSignatures = getRequiredSignatures(_wallet, _data);\n\n        if((requiredSignatures * 65) == _signatures.length) {\n\n            if(verifyRefund(_wallet, _gasLimit, _gasPrice, requiredSignatures)) {\n\n                if(requiredSignatures == 0 || validateSignatures(_wallet, _data, signHash, _signatures)) {\n\n                    // solium-disable-next-line security/no-call-value\n\n                    success = address(this).call(_data);\n\n                    refund(_wallet, startGas - gasleft(), _gasPrice, _gasLimit, requiredSignatures, msg.sender);\n\n                }\n\n            }\n\n        }\n\n        emit TransactionExecuted(_wallet, success, signHash); \n\n    }\n\n\n\n    /**\n\n    * @dev Gets the current nonce for a wallet.\n\n    * @param _wallet The target wallet.\n\n    */\n\n    function getNonce(BaseWallet _wallet) external view returns (uint256 nonce) {\n\n        return relayer[_wallet].nonce;\n\n    }\n\n\n\n    /**\n\n    * @dev Generates the signed hash of a relayed transaction according to ERC 1077.\n\n    * @param _from The starting address for the relayed transaction (should be the module)\n\n    * @param _to The destination address for the relayed transaction (should be the wallet)\n\n    * @param _value The value for the relayed transaction\n\n    * @param _data The data for the relayed transaction\n\n    * @param _nonce The nonce used to prevent replay attacks.\n\n    * @param _gasPrice The gas price to use for the gas refund.\n\n    * @param _gasLimit The gas limit to use for the gas refund.\n\n    */\n\n    function getSignHash(\n\n        address _from,\n\n        address _to, \n\n        uint256 _value, \n\n        bytes _data, \n\n        uint256 _nonce,\n\n        uint256 _gasPrice,\n\n        uint256 _gasLimit\n\n    ) \n\n        internal \n\n        pure\n\n        returns (bytes32) \n\n    {\n\n        return keccak256(\n\n            abi.encodePacked(\n\n                \"\\x19Ethereum Signed Message:\\n32\",\n\n                keccak256(abi.encodePacked(byte(0x19), byte(0), _from, _to, _value, _data, _nonce, _gasPrice, _gasLimit))\n\n        ));\n\n    }\n\n\n\n    /**\n\n    * @dev Checks if the relayed transaction is unique.\n\n    * @param _wallet The target wallet.\n\n    * @param _nonce The nonce\n\n    * @param _signHash The signed hash of the transaction\n\n    */\n\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n\n        if(relayer[_wallet].executedTx[_signHash] == true) {\n\n            return false;\n\n        }\n\n        relayer[_wallet].executedTx[_signHash] = true;\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Checks that a nonce has the correct format and is valid. \n\n    * It must be constructed as nonce = {block number}{timestamp} where each component is 16 bytes.\n\n    * @param _wallet The target wallet.\n\n    * @param _nonce The nonce\n\n    */\n\n    function checkAndUpdateNonce(BaseWallet _wallet, uint256 _nonce) internal returns (bool) {\n\n        if(_nonce <= relayer[_wallet].nonce) {\n\n            return false;\n\n        }   \n\n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n\n        if(nonceBlock > block.number + BLOCKBOUND) {\n\n            return false;\n\n        }\n\n        relayer[_wallet].nonce = _nonce;\n\n        return true;    \n\n    }\n\n\n\n    /**\n\n    * @dev Recovers the signer at a given position from a list of concatenated signatures.\n\n    * @param _signedHash The signed hash\n\n    * @param _signatures The concatenated signatures.\n\n    * @param _index The index of the signature to recover.\n\n    */\n\n    function recoverSigner(bytes32 _signedHash, bytes _signatures, uint _index) internal pure returns (address) {\n\n        uint8 v;\n\n        bytes32 r;\n\n        bytes32 s;\n\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n\n        // we jump 65 (0x41) per signature\n\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n\n        }\n\n        require(v == 27 || v == 28); \n\n        return ecrecover(_signedHash, v, r, s);\n\n    }\n\n\n\n    /**\n\n    * @dev Refunds the gas used to the Relayer. \n\n    * For security reasons the default behavior is to not refund calls with 0 or 1 signatures. \n\n    * @param _wallet The target wallet.\n\n    * @param _gasUsed The gas used.\n\n    * @param _gasPrice The gas price for the refund.\n\n    * @param _gasLimit The gas limit for the refund.\n\n    * @param _signatures The number of signatures used in the call.\n\n    * @param _relayer The address of the Relayer.\n\n    */\n\n    function refund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _gasLimit, uint _signatures, address _relayer) internal {\n\n        uint256 amount = 29292 + _gasUsed; // 21000 (transaction) + 7620 (execution of refund) + 672 to log the event + _gasUsed\n\n        // only refund if gas price not null, more than 1 signatures, gas less than gasLimit\n\n        if(_gasPrice > 0 && _signatures > 1 && amount <= _gasLimit) {\n\n            if(_gasPrice > tx.gasprice) {\n\n                amount = amount * tx.gasprice;\n\n            }\n\n            else {\n\n                amount = amount * _gasPrice;\n\n            }\n\n            _wallet.invoke(_relayer, amount, \"\");\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Returns false if the refund is expected to fail.\n\n    * @param _wallet The target wallet.\n\n    * @param _gasUsed The expected gas used.\n\n    * @param _gasPrice The expected gas price for the refund.\n\n    */\n\n    function verifyRefund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _signatures) internal view returns (bool) {\n\n        if(_gasPrice > 0 \n\n            && _signatures > 1 \n\n            && (address(_wallet).balance < _gasUsed * _gasPrice || _wallet.authorised(this) == false)) {\n\n            return false;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Checks that the wallet address provided as the first parameter of the relayed data is the same\n\n    * as the wallet passed as the input of the execute() method. \n\n    @return false if the addresses are different.\n\n    */\n\n    function verifyData(address _wallet, bytes _data) private pure returns (bool) {\n\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n\n        address dataWallet;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            //_data = {length:32}{sig:4}{_wallet:32}{...}\n\n            dataWallet := mload(add(_data, 0x24))\n\n        }\n\n        return dataWallet == _wallet;\n\n    }\n\n\n\n    /**\n\n    * @dev Parses the data to extract the method signature. \n\n    */\n\n    function functionPrefix(bytes _data) internal pure returns (bytes4 prefix) {\n\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            prefix := mload(add(_data, 0x20))\n\n        }\n\n    }\n\n}\n\n\n\n/**\n\n * @title Storage\n\n * @dev Base contract for the storage of a wallet.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract Storage {\n\n\n\n    /**\n\n     * @dev Throws if the caller is not an authorised module.\n\n     */\n\n    modifier onlyModule(BaseWallet _wallet) {\n\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\n\n        _;\n\n    }\n\n}\n\n\n\n/**\n\n * @title GuardianStorage\n\n * @dev Contract storing the state of wallets related to guardians and lock.\n\n * The contract only defines basic setters and getters with no logic. Only modules authorised\n\n * for a wallet can modify its state.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n\n */\n\ncontract GuardianStorage is Storage {\n\n\n\n    struct GuardianStorageConfig {\n\n        // the list of guardians\n\n        address[] guardians;\n\n        // the info about guardians\n\n        mapping (address => GuardianInfo) info;\n\n        // the lock's release timestamp\n\n        uint256 lock; \n\n        // the module that set the last lock\n\n        address locker;\n\n    }\n\n\n\n    struct GuardianInfo {\n\n        bool exists;\n\n        uint128 index;\n\n    }\n\n\n\n    // wallet specific storage\n\n    mapping (address => GuardianStorageConfig) internal configs;\n\n\n\n    // *************** External Functions ********************* //\n\n\n\n    /**\n\n     * @dev Lets an authorised module add a guardian to a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _guardian The guardian to add.\n\n     */\n\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n\n        GuardianStorageConfig storage config = configs[_wallet];\n\n        config.info[_guardian].exists = true;\n\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\n\n    }\n\n\n\n    /**\n\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _guardian The guardian to revoke.\n\n     */\n\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n\n        GuardianStorageConfig storage config = configs[_wallet];\n\n        address lastGuardian = config.guardians[config.guardians.length - 1];\n\n        if (_guardian != lastGuardian) {\n\n            uint128 targetIndex = config.info[_guardian].index;\n\n            config.guardians[targetIndex] = lastGuardian;\n\n            config.info[lastGuardian].index = targetIndex;\n\n        }\n\n        config.guardians.length--;\n\n        delete config.info[_guardian];\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of guardians for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @return the number of guardians.\n\n     */\n\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\n\n        return configs[_wallet].guardians.length;\n\n    }\n\n    \n\n    /**\n\n     * @dev Gets the list of guaridans for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @return the list of guardians.\n\n     */\n\n    function getGuardians(BaseWallet _wallet) external view returns (address[]) {\n\n        GuardianStorageConfig storage config = configs[_wallet];\n\n        address[] memory guardians = new address[](config.guardians.length);\n\n        for (uint256 i = 0; i < config.guardians.length; i++) {\n\n            guardians[i] = config.guardians[i];\n\n        }\n\n        return guardians;\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if an account is a guardian for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _guardian The account.\n\n     * @return true if the account is a guardian for a wallet.\n\n     */\n\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\n\n        return configs[_wallet].info[_guardian].exists;\n\n    }\n\n\n\n    /**\n\n     * @dev Lets an authorised module set the lock for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\n\n     */\n\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\n\n        configs[_wallet].lock = _releaseAfter;\n\n        if(_releaseAfter != 0 && msg.sender != configs[_wallet].locker) {\n\n            configs[_wallet].locker = msg.sender;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if the lock is set for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @return true if the lock is set for the wallet.\n\n     */\n\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\n\n        return configs[_wallet].lock > now;\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the time at which the lock of a wallet will release.\n\n     * @param _wallet The target wallet.\n\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\n\n     */\n\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\n\n        return configs[_wallet].lock;\n\n    }\n\n\n\n    /**\n\n     * @dev Gets the address of the last module that modified the lock for a wallet.\n\n     * @param _wallet The target wallet.\n\n     * @return the address of the last module that modified the lock for a wallet.\n\n     */\n\n    function getLocker(BaseWallet _wallet) external view returns (address) {\n\n        return configs[_wallet].locker;\n\n    }\n\n}\n\n\n\nlibrary GuardianUtils {\n\n\n\n    /**\n\n    * @dev Checks if an address is an account guardian or an account authorised to sign on behalf of a smart-contract guardian\n\n    * given a list of guardians.\n\n    * @param _guardians the list of guardians\n\n    * @param _guardian the address to test\n\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n\n    */\n\n    function isGuardian(address[] _guardians, address _guardian) internal view returns (bool, address[]) {\n\n        if(_guardians.length == 0 || _guardian == address(0)) {\n\n            return (false, _guardians);\n\n        }\n\n        bool isFound = false;\n\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < _guardians.length; i++) {\n\n            if(!isFound) {\n\n                // check if _guardian is an account guardian\n\n                if(_guardian == _guardians[i]) {\n\n                    isFound = true;\n\n                    continue;\n\n                }\n\n                // check if _guardian is the owner of a smart contract guardian\n\n                if(isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n\n                    isFound = true;\n\n                    continue;\n\n                }\n\n            }\n\n            if(index < updatedGuardians.length) {\n\n                updatedGuardians[index] = _guardians[i];\n\n                index++;\n\n            }\n\n        }\n\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n\n    }\n\n\n\n   /**\n\n    * @dev Checks if an address is a contract.\n\n    * @param _addr The address.\n\n    */\n\n    function isContract(address _addr) internal view returns (bool) {\n\n        uint32 size;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            size := extcodesize(_addr)\n\n        }\n\n        return (size > 0);\n\n    }\n\n\n\n    /**\n\n    * @dev Checks if an address is the owner of a guardian contract. \n\n    * The method does not revert if the call to the owner() method consumes more then 5000 gas. \n\n    * @param _guardian The guardian contract\n\n    * @param _owner The owner to verify.\n\n    */\n\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n\n        address owner = address(0);\n\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(ptr,sig)\n\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\n\n            if eq(result, 1) {\n\n                owner := mload(ptr)\n\n            }\n\n        }\n\n        return owner == _owner;\n\n    }\n\n        \n\n}\n\n\n\n/* The MIT License (MIT)\n\n\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining\n\na copy of this software and associated documentation files (the\n\n\"Software\"), to deal in the Software without restriction, including\n\nwithout limitation the rights to use, copy, modify, merge, publish,\n\ndistribute, sublicense, and/or sell copies of the Software, and to\n\npermit persons to whom the Software is furnished to do so, subject to\n\nthe following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included\n\nin all copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, reverts on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b <= a);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, reverts on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n\n    * reverts when dividing by zero.\n\n    */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b != 0);\n\n        return a % b;\n\n    }\n\n\n\n    /**\n\n    * @dev Returns ceil(a / b).\n\n    */\n\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a / b;\n\n        if(a % b == 0) {\n\n            return c;\n\n        }\n\n        else {\n\n            return c + 1;\n\n        }\n\n    }\n\n}\n\n\n\n/**\n\n * @title ApprovedTransfer\n\n * @dev Module to transfer tokens (ETH or ERC20) with the approval of guardians.\n\n * @author Julien Niset - <julien@argent.xyz>\n\n */\n\ncontract ApprovedTransfer is BaseModule, RelayerModule {\n\n\n\n    bytes32 constant NAME = \"ApprovedTransfer\";\n\n\n\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\n\n    // The Guardian storage \n\n    GuardianStorage internal guardianStorage;\n\n    event Address(address _addr);\n\n    event Transfer(address indexed wallet, address indexed token, uint256 indexed amount, address to, bytes data);    \n\n\n\n    /**\n\n     * @dev Throws if the wallet is locked.\n\n     */\n\n    modifier onlyWhenUnlocked(BaseWallet _wallet) {\n\n        // solium-disable-next-line security/no-block-members\n\n        require(!guardianStorage.isLocked(_wallet), \"AT: wallet must be unlocked\");\n\n        _;\n\n    }\n\n\n\n    constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage) BaseModule(_registry, NAME) public {\n\n        guardianStorage = _guardianStorage;\n\n    }\n\n\n\n    /**\n\n    * @dev transfers tokens (ETH or ERC20) from a wallet.\n\n    * @param _wallet The target wallet.\n\n    * @param _token The address of the token to transfer.\n\n    * @param _to The destination address\n\n    * @param _amount The amoutnof token to transfer\n\n    * @param _data  The data for the transaction (only for ETH transfers)\n\n    */\n\n    function transferToken(\n\n        BaseWallet _wallet, \n\n        address _token, \n\n        address _to, \n\n        uint256 _amount, \n\n        bytes _data\n\n    ) \n\n        external \n\n        onlyExecute \n\n        onlyWhenUnlocked(_wallet) \n\n    {\n\n        // eth transfer to whitelist\n\n        if(_token == ETH_TOKEN) {\n\n            _wallet.invoke(_to, _amount, _data);\n\n            emit Transfer(_wallet, ETH_TOKEN, _amount, _to, _data);\n\n        }\n\n        // erc20 transfer to whitelist\n\n        else {\n\n            bytes memory methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _amount);\n\n            _wallet.invoke(_token, 0, methodData);\n\n            emit Transfer(_wallet, _token, _amount, _to, _data);\n\n        }\n\n    }\n\n\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n\n\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool) {\n\n        address lastSigner = address(0);\n\n        address[] memory guardians = guardianStorage.getGuardians(_wallet);\n\n        bool isGuardian = false;\n\n        for (uint8 i = 0; i < _signatures.length / 65; i++) {\n\n            address signer = recoverSigner(_signHash, _signatures, i);\n\n            if(i == 0) {\n\n                // AT: first signer must be owner\n\n                if(!isOwner(_wallet, signer)) { \n\n                    return false;\n\n                }\n\n            }\n\n            else {\n\n                // \"AT: signers must be different\"\n\n                if(signer <= lastSigner) { \n\n                    return false;\n\n                }\n\n                lastSigner = signer;\n\n                (isGuardian, guardians) = GuardianUtils.isGuardian(guardians, signer);\n\n                // \"AT: signatures not valid\"\n\n                if(!isGuardian) { \n\n                    return false;\n\n                }\n\n            }\n\n        }\n\n        return true;\n\n    }\n\n\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256) {\n\n        // owner  + [n/2] guardians\n\n        return  1 + SafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n\n    }\n\n}"
  },
  {
    "id": 42,
    "addr4sss": "0x00499c8444cff1c09566a1d5c8b6ea801af9688f",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 1,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n \n\ncontract Token {\n\n    string public symbol = \"\";\n\n    string public name = \"\";\n\n    uint8 public constant decimals = 18;\n\n\tstring public constant ICOFactoryVersion = \"1.0\";\n\n    uint256 _totalSupply = 0;\n\n\tuint256 _oneEtherEqualsInWei = 0;\t\n\n\tuint256 _maxICOpublicSupply = 0;\n\n\tuint256 _ownerICOsupply = 0;\n\n\tuint256 _currentICOpublicSupply = 0;\n\n\tuint256 _blockICOdatetime = 0;\n\n\taddress _ICOfundsReceiverAddress = 0;\n\n\taddress _remainingTokensReceiverAddress = 0;\n\n    address owner = 0;\t\n\n    bool setupDone = false;\n\n\tbool isICOrunning = false;\n\n\tbool ICOstarted = false;\n\n\tuint256 ICOoverTimestamp = 0;\n\n   \n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\tevent Burn(address indexed _owner, uint256 _value);\n\n \n\n    mapping(address => uint256) balances;\n\n \n\n    mapping(address => mapping (address => uint256)) allowed;\n\n \n\n    function Token(address adr) public {\n\n        owner = adr;        \n\n    }\n\n\t\n\n\tfunction() public payable\n\n\t{\n\n\t\tif ((isICOrunning && _blockICOdatetime == 0) || (isICOrunning && _blockICOdatetime > 0 && now <= _blockICOdatetime))\n\n\t\t{\n\n\t\t\tuint256 _amount = ((msg.value * _oneEtherEqualsInWei) / 1000000000000000000);\n\n\t\t\t\n\n\t\t\tif (((_currentICOpublicSupply + _amount) > _maxICOpublicSupply) && _maxICOpublicSupply > 0) revert();\n\n\t\t\t\n\n\t\t\tif(!_ICOfundsReceiverAddress.send(msg.value)) revert();\t\t\t\t\t\n\n\t\t\t\n\n\t\t\t_currentICOpublicSupply += _amount;\n\n\t\t\t\n\n\t\t\tbalances[msg.sender] += _amount;\n\n\t\t\t\n\n\t\t\t_totalSupply += _amount;\t\t\t\n\n\t\t\t\n\n\t\t\tTransfer(this, msg.sender, _amount);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert();\n\n\t\t}\n\n\t}\n\n   \n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 oneEtherEqualsInWei, uint256 maxICOpublicSupply, uint256 ownerICOsupply, address remainingTokensReceiverAddress, address ICOfundsReceiverAddress, uint256 blockICOdatetime) public\n\n    {\n\n        if (msg.sender == owner && !setupDone)\n\n        {\n\n            symbol = tokenSymbol;\n\n            name = tokenName;\n\n\t\t\t_oneEtherEqualsInWei = oneEtherEqualsInWei;\n\n\t\t\t_maxICOpublicSupply = maxICOpublicSupply * 1000000000000000000;\t\t\t\t\t\t\t\t\t\n\n\t\t\tif (ownerICOsupply > 0)\n\n\t\t\t{\n\n\t\t\t\t_ownerICOsupply = ownerICOsupply * 1000000000000000000;\n\n\t\t\t\t_totalSupply = _ownerICOsupply;\n\n\t\t\t\tbalances[owner] = _totalSupply;\n\n\t\t\t\tTransfer(this, owner, _totalSupply);\n\n\t\t\t}\t\t\t\n\n\t\t\t_ICOfundsReceiverAddress = ICOfundsReceiverAddress;\n\n\t\t\tif (_ICOfundsReceiverAddress == 0) _ICOfundsReceiverAddress = owner;\n\n\t\t\t_remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n\t\t\t_blockICOdatetime = blockICOdatetime;\t\t\t\n\n            setupDone = true;\n\n        }\n\n    }\n\n\t\n\n\tfunction StartICO() public returns (bool success)\n\n    {\n\n        if (msg.sender == owner && !ICOstarted && setupDone)\n\n        {\n\n            ICOstarted = true;\t\t\t\n\n\t\t\tisICOrunning = true;\t\t\t\n\n        }\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert();\n\n\t\t}\n\n\t\treturn true;\n\n    }\n\n\t\n\n\tfunction StopICO() public returns (bool success)\n\n    {\n\n        if (msg.sender == owner && isICOrunning)\n\n        {            \n\n\t\t\tif (_remainingTokensReceiverAddress != 0 && _maxICOpublicSupply > 0)\n\n\t\t\t{\n\n\t\t\t\tuint256 _remainingAmount = _maxICOpublicSupply - _currentICOpublicSupply;\n\n\t\t\t\tif (_remainingAmount > 0)\n\n\t\t\t\t{\n\n\t\t\t\t\tbalances[_remainingTokensReceiverAddress] += _remainingAmount;\n\n\t\t\t\t\t_totalSupply += _remainingAmount;\n\n\t\t\t\t\tTransfer(this, _remainingTokensReceiverAddress, _remainingAmount);\t\n\n\t\t\t\t}\n\n\t\t\t}\t\t\t\t\n\n\t\t\tisICOrunning = false;\t\n\n\t\t\tICOoverTimestamp = now;\n\n        }\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert();\n\n\t\t}\n\n\t\treturn true;\n\n    }\n\n\t\n\n\tfunction BurnTokens(uint256 amountInWei) public returns (bool success)\n\n    {\n\n\t\tif (balances[msg.sender] >= amountInWei)\n\n\t\t{\n\n\t\t\tbalances[msg.sender] -= amountInWei;\n\n\t\t\t_totalSupply -= amountInWei;\n\n\t\t\tBurn(msg.sender, amountInWei);\n\n\t\t\tTransfer(msg.sender, 0, amountInWei);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\trevert();\n\n\t\t}\n\n\t\treturn true;\n\n    }\n\n \n\n    function totalSupply() public constant returns (uint256 totalSupplyValue) {        \n\n        return _totalSupply;\n\n    }\n\n\t\n\n\tfunction OneEtherEqualsInWei() public constant returns (uint256 oneEtherEqualsInWei) {        \n\n        return _oneEtherEqualsInWei;\n\n    }\n\n\t\n\n\tfunction MaxICOpublicSupply() public constant returns (uint256 maxICOpublicSupply) {        \n\n        return _maxICOpublicSupply;\n\n    }\n\n\t\n\n\tfunction OwnerICOsupply() public constant returns (uint256 ownerICOsupply) {        \n\n        return _ownerICOsupply;\n\n    }\n\n\t\n\n\tfunction CurrentICOpublicSupply() public constant returns (uint256 currentICOpublicSupply) {        \n\n        return _currentICOpublicSupply;\n\n    }\n\n\t\n\n\tfunction RemainingTokensReceiverAddress() public constant returns (address remainingTokensReceiverAddress) {        \n\n        return _remainingTokensReceiverAddress;\n\n    }\n\n\t\n\n\tfunction ICOfundsReceiverAddress() public constant returns (address ICOfundsReceiver) {        \n\n        return _ICOfundsReceiverAddress;\n\n    }\n\n\t\n\n\tfunction Owner() public constant returns (address ownerAddress) {        \n\n        return owner;\n\n    }\n\n\t\n\n\tfunction SetupDone() public constant returns (bool setupDoneFlag) {        \n\n        return setupDone;\n\n    }\n\n    \n\n\tfunction IsICOrunning() public constant returns (bool isICOrunningFalg) {        \n\n        return isICOrunning;\n\n    }\n\n\t\n\n\tfunction IsICOstarted() public constant returns (bool isICOstartedFlag) {        \n\n        return ICOstarted;\n\n    }\n\n\t\n\n\tfunction ICOoverTimeStamp() public constant returns (uint256 ICOoverTimestampCheck) {        \n\n        return ICOoverTimestamp;\n\n    }\n\n\t\n\n\tfunction BlockICOdatetime() public constant returns (uint256 blockStopICOdate) {        \n\n        return _blockICOdatetime;\n\n    }\n\n\t\n\n\tfunction TimeNow() public constant returns (uint256 timenow) {        \n\n        return now;\n\n    }\n\n\t \n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n \n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n\n        if (balances[msg.sender] >= _amount\n\n            && _amount > 0\n\n            && balances[_to] + _amount > balances[_to]) {\n\n            balances[msg.sender] -= _amount;\n\n            balances[_to] += _amount;\n\n            Transfer(msg.sender, _to, _amount);\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n \n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _amount\n\n    ) public returns (bool success) {\n\n        if (balances[_from] >= _amount\n\n            && allowed[_from][msg.sender] >= _amount\n\n            && _amount > 0\n\n            && balances[_to] + _amount > balances[_to]) {\n\n            balances[_from] -= _amount;\n\n            allowed[_from][msg.sender] -= _amount;\n\n            balances[_to] += _amount;\n\n            Transfer(_from, _to, _amount);\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n \n\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n\n        allowed[msg.sender][_spender] = _amount;\n\n        Approval(msg.sender, _spender, _amount);\n\n        return true;\n\n    }\n\n \n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n}"
  },
  {
    "id": 43,
    "addr4sss": "0x004a0ea16df8e38e9107461dffe34d6a7f9caab1",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 1,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      },
      {
        "vulnerability": "TimeM",
        "SWC-ID": "SWC-116",
        "Description": "Time Manipulation (Block values as a proxy for time)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\ncontract F3Devents {\n\n    // fired whenever a player registers a name\n\n    event onNewName\n\n    (\n\n        uint256 indexed playerID,\n\n        address indexed playerAddress,\n\n        bytes32 indexed playerName,\n\n        bool isNewPlayer,\n\n        uint256 affiliateID,\n\n        address affiliateAddress,\n\n        bytes32 affiliateName,\n\n        uint256 amountPaid,\n\n        uint256 timeStamp\n\n    );\n\n\n\n    // fired at end of buy or reload\n\n    event onEndTx\n\n    (\n\n        uint256 compressedData,\n\n        uint256 compressedIDs,\n\n        bytes32 playerName,\n\n        address playerAddress,\n\n        uint256 ethIn,\n\n        uint256 keysBought,\n\n        address winnerAddr,\n\n        bytes32 winnerName,\n\n        uint256 amountWon,\n\n        uint256 newPot,\n\n        uint256 P3DAmount,\n\n        uint256 genAmount,\n\n        uint256 potAmount,\n\n        uint256 airDropPot\n\n    );\n\n\n\n\t// fired whenever theres a withdraw\n\n    event onWithdraw\n\n    (\n\n        uint256 indexed playerID,\n\n        address playerAddress,\n\n        bytes32 playerName,\n\n        uint256 ethOut,\n\n        uint256 timeStamp\n\n    );\n\n\n\n    // fired whenever a withdraw forces end round to be ran\n\n    event onWithdrawAndDistribute\n\n    (\n\n        address playerAddress,\n\n        bytes32 playerName,\n\n        uint256 ethOut,\n\n        uint256 compressedData,\n\n        uint256 compressedIDs,\n\n        address winnerAddr,\n\n        bytes32 winnerName,\n\n        uint256 amountWon,\n\n        uint256 newPot,\n\n        uint256 P3DAmount,\n\n        uint256 genAmount\n\n    );\n\n\n\n    // (fomo3d short only) fired whenever a player tries a buy after round timer\n\n    // hit zero, and causes end round to be ran.\n\n    event onBuyAndDistribute\n\n    (\n\n        address playerAddress,\n\n        bytes32 playerName,\n\n        uint256 ethIn,\n\n        uint256 compressedData,\n\n        uint256 compressedIDs,\n\n        address winnerAddr,\n\n        bytes32 winnerName,\n\n        uint256 amountWon,\n\n        uint256 newPot,\n\n        uint256 P3DAmount,\n\n        uint256 genAmount\n\n    );\n\n\n\n    // (fomo3d short only) fired whenever a player tries a reload after round timer\n\n    // hit zero, and causes end round to be ran.\n\n    event onReLoadAndDistribute\n\n    (\n\n        address playerAddress,\n\n        bytes32 playerName,\n\n        uint256 compressedData,\n\n        uint256 compressedIDs,\n\n        address winnerAddr,\n\n        bytes32 winnerName,\n\n        uint256 amountWon,\n\n        uint256 newPot,\n\n        uint256 P3DAmount,\n\n        uint256 genAmount\n\n    );\n\n\n\n    // fired whenever an affiliate is paid\n\n    event onAffiliatePayout\n\n    (\n\n        uint256 indexed affiliateID,\n\n        address affiliateAddress,\n\n        bytes32 affiliateName,\n\n        uint256 indexed roundID,\n\n        uint256 indexed buyerID,\n\n        uint256 amount,\n\n        uint256 timeStamp\n\n    );\n\n\n\n    // received pot swap deposit\n\n    event onPotSwapDeposit\n\n    (\n\n        uint256 roundID,\n\n        uint256 amountAddedToPot\n\n    );\n\n}\n\n\n\n//==============================================================================\n\n//   _ _  _ _|_ _ _  __|_   _ _ _|_    _   .\n\n//  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  .\n\n//====================================|=========================================\n\n\n\ncontract modularShort is F3Devents {}\n\n\n\ncontract FoMo3DLight is modularShort {\n\n    using SafeMath for *;\n\n    using NameFilter for string;\n\n    using F3DKeysCalcShort for uint256;\n\n\n\n    uint256 public pID_ = 4;\n\n\n\n//==============================================================================\n\n//     _ _  _  |`. _     _ _ |_ | _  _  .\n\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\n\n//=================_|===========================================================\n\n    address private admin = msg.sender;\n\n    string constant public name = \"FOMO Light\";\n\n    string constant public symbol = \"F4D\";\n\n    uint256 private rndExtra_ = 1 minutes;     // length of the very first ICO\n\n    uint256 private rndGap_ = 1 minutes;         // length of ICO phase, set to 1 year for EOS.\n\n    uint256 constant private rndInit_ = 10 minutes;                // round timer starts at this\n\n    uint256 constant private rndInc_ = 10 seconds;              // every full key purchased adds this much to the timer\n\n    uint256 constant private rndMax_ = 20 minutes;                // max length a round timer can be\n\n//==============================================================================\n\n//     _| _ _|_ _    _ _ _|_    _   .\n\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\n\n//=============================|================================================\n\n    uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\n\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\n\n    uint256 public rID_;    // round id number / total rounds that have happened\n\n//****************\n\n// PLAYER DATA\n\n//****************\n\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\n\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\n\n    mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data\n\n    mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\n\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own)\n\n//****************\n\n// ROUND DATA\n\n//****************\n\n    mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data\n\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id\n\n//****************\n\n// TEAM FEE DATA\n\n//****************\n\n    mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team\n\n    mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team\n\n//==============================================================================\n\n//     _ _  _  __|_ _    __|_ _  _  .\n\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\n\n//==============================================================================\n\n    constructor()\n\n        public\n\n    {\n\n\t\t// Team allocation structures\n\n        // 0 = whales\n\n        // 1 = bears\n\n        // 2 = sneks\n\n        // 3 = bulls\n\n\n\n\t\t// Team allocation percentages\n\n        // (F3D, P3D) + (Pot , Referrals, Community)\n\n            // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot.\n\n        fees_[0] = F3Ddatasets.TeamFee(49,2);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\n\n        fees_[1] = F3Ddatasets.TeamFee(49,2);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\n\n        fees_[2] = F3Ddatasets.TeamFee(49,2);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\n\n        fees_[3] = F3Ddatasets.TeamFee(49,2);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\n\n\n\n        // how to split up the final pot based on which team was picked\n\n        // (F3D, P3D)\n\n        potSplit_[0] = F3Ddatasets.PotSplit(38,2);  //48% to winner, 10% to next round, 2% to com\n\n        potSplit_[1] = F3Ddatasets.PotSplit(38,2);  //48% to winner, 10% to next round, 2% to com\n\n        potSplit_[2] = F3Ddatasets.PotSplit(38,2);  //48% to winner, 10% to next round, 2% to com\n\n        potSplit_[3] = F3Ddatasets.PotSplit(38,2);  //48% to winner, 10% to next round, 2% to com\n\n\t}\n\n//==============================================================================\n\n//     _ _  _  _|. |`. _  _ _  .\n\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\n\n//==============================================================================\n\n    /**\n\n     * @dev used to make sure no one can interact with contract until it has\n\n     * been activated.\n\n     */\n\n    modifier isActivated() {\n\n        require(activated_ == true, \"its not ready yet.  check ?eta in discord\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev prevents contracts from interacting with fomo3d\n\n     */\n\n    modifier isHuman() {\n\n        address _addr = msg.sender;\n\n        uint256 _codeLength;\n\n\n\n        assembly {_codeLength := extcodesize(_addr)}\n\n        require(_codeLength == 0, \"sorry humans only\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev sets boundaries for incoming tx\n\n     */\n\n    modifier isWithinLimits(uint256 _eth) {\n\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n\n        _;\n\n    }\n\n\n\n//==============================================================================\n\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\n\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\n\n//====|=========================================================================\n\n    /**\n\n     * @dev emergency buy uses last stored affiliate ID and team snek\n\n     */\n\n    function()\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(msg.value)\n\n        public\n\n        payable\n\n    {\n\n        // set up our tx event data and determine if player is new or not\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n\n\n        if (determinePID(msg.sender)) {\n\n            _eventData_.compressedData = _eventData_.compressedData + 1;\n\n        }\n\n        // fetch player id\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // buy core\n\n        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n\n    }\n\n\n\n    function determinePID(address _addr)\n\n        private\n\n        returns (bool)\n\n    {\n\n        if (pIDxAddr_[_addr] == 0)\n\n        {\n\n            pID_++;\n\n            pIDxAddr_[_addr] = pID_;\n\n            plyr_[pID_].addr = _addr;\n\n\n\n            // set the new player bool to true\n\n            return (true);\n\n        } else {\n\n            return (false);\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev converts all incoming ethereum to keys.\n\n     * -functionhash- 0x8f38f309 (using ID for affiliate)\n\n     * -functionhash- 0x98a0871d (using address for affiliate)\n\n     * -functionhash- 0xa65b37a1 (using name for affiliate)\n\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\n\n     * @param _team what team is the player playing for?\n\n     */\n\n    function buyXid(uint256 _affCode, uint256 _team)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(msg.value)\n\n        public\n\n        payable\n\n    {\n\n        // set up our tx event data and determine if player is new or not\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n        if (determinePID(msg.sender)) {\n\n            _eventData_.compressedData = _eventData_.compressedData + 1;\n\n        }\n\n\n\n        // fetch player id\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == 0 || _affCode == _pID)\n\n        {\n\n            // use last stored affiliate code\n\n            _affCode = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given & its not the same as previously stored\n\n        } else if (_affCode != plyr_[_pID].laff) {\n\n            // update last affiliate\n\n            plyr_[_pID].laff = _affCode;\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // buy core\n\n        buyCore(_pID, _affCode, _team, _eventData_);\n\n    }\n\n\n\n    function buyXaddr(address _affCode, uint256 _team)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(msg.value)\n\n        public\n\n        payable\n\n    {\n\n        // set up our tx event data and determine if player is new or not\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n        if (determinePID(msg.sender)) {\n\n            _eventData_.compressedData = _eventData_.compressedData + 1;\n\n        }\n\n\n\n        // fetch player id\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        uint256 _affID;\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == address(0) || _affCode == msg.sender)\n\n        {\n\n            // use last stored affiliate code\n\n            _affID = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given\n\n        } else {\n\n            // get affiliate ID from aff Code\n\n            _affID = pIDxAddr_[_affCode];\n\n\n\n            // if affID is not the same as previously stored\n\n            if (_affID != plyr_[_pID].laff)\n\n            {\n\n                // update last affiliate\n\n                plyr_[_pID].laff = _affID;\n\n            }\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // buy core\n\n        buyCore(_pID, _affID, _team, _eventData_);\n\n    }\n\n\n\n    function buyXname(bytes32 _affCode, uint256 _team)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(msg.value)\n\n        public\n\n        payable\n\n    {\n\n        // set up our tx event data and determine if player is new or not\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n        if (determinePID(msg.sender)) {\n\n            _eventData_.compressedData = _eventData_.compressedData + 1;\n\n        }\n\n\n\n        // fetch player id\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        uint256 _affID;\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n\n        {\n\n            // use last stored affiliate code\n\n            _affID = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given\n\n        } else {\n\n            // get affiliate ID from aff Code\n\n            _affID = pIDxName_[_affCode];\n\n\n\n            // if affID is not the same as previously stored\n\n            if (_affID != plyr_[_pID].laff)\n\n            {\n\n                // update last affiliate\n\n                plyr_[_pID].laff = _affID;\n\n            }\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // buy core\n\n        buyCore(_pID, _affID, _team, _eventData_);\n\n    }\n\n\n\n    /**\n\n     * @dev essentially the same as buy, but instead of you sending ether\n\n     * from your wallet, it uses your unwithdrawn earnings.\n\n     * -functionhash- 0x349cdcac (using ID for affiliate)\n\n     * -functionhash- 0x82bfc739 (using address for affiliate)\n\n     * -functionhash- 0x079ce327 (using name for affiliate)\n\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\n\n     * @param _team what team is the player playing for?\n\n     * @param _eth amount of earnings to use (remainder returned to gen vault)\n\n     */\n\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(_eth)\n\n        public\n\n    {\n\n        // set up our tx event data\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n\n\n        // fetch player ID\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == 0 || _affCode == _pID)\n\n        {\n\n            // use last stored affiliate code\n\n            _affCode = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given & its not the same as previously stored\n\n        } else if (_affCode != plyr_[_pID].laff) {\n\n            // update last affiliate\n\n            plyr_[_pID].laff = _affCode;\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // reload core\n\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n\n    }\n\n\n\n    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(_eth)\n\n        public\n\n    {\n\n        // set up our tx event data\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n\n\n        // fetch player ID\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        uint256 _affID;\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == address(0) || _affCode == msg.sender)\n\n        {\n\n            // use last stored affiliate code\n\n            _affID = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given\n\n        } else {\n\n            // get affiliate ID from aff Code\n\n            _affID = pIDxAddr_[_affCode];\n\n\n\n            // if affID is not the same as previously stored\n\n            if (_affID != plyr_[_pID].laff)\n\n            {\n\n                // update last affiliate\n\n                plyr_[_pID].laff = _affID;\n\n            }\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // reload core\n\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n\n    }\n\n\n\n    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n\n        isActivated()\n\n        isHuman()\n\n        isWithinLimits(_eth)\n\n        public\n\n    {\n\n        // set up our tx event data\n\n        F3Ddatasets.EventReturns memory _eventData_;\n\n\n\n        // fetch player ID\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // manage affiliate residuals\n\n        uint256 _affID;\n\n        // if no affiliate code was given or player tried to use their own, lolz\n\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n\n        {\n\n            // use last stored affiliate code\n\n            _affID = plyr_[_pID].laff;\n\n\n\n        // if affiliate code was given\n\n        } else {\n\n            // get affiliate ID from aff Code\n\n            _affID = pIDxName_[_affCode];\n\n\n\n            // if affID is not the same as previously stored\n\n            if (_affID != plyr_[_pID].laff)\n\n            {\n\n                // update last affiliate\n\n                plyr_[_pID].laff = _affID;\n\n            }\n\n        }\n\n\n\n        // verify a valid team was selected\n\n        _team = verifyTeam(_team);\n\n\n\n        // reload core\n\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n\n    }\n\n\n\n    /**\n\n     * @dev withdraws all of your earnings.\n\n     * -functionhash- 0x3ccfd60b\n\n     */\n\n    function withdraw()\n\n        isActivated()\n\n        isHuman()\n\n        public\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // fetch player ID\n\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n\n\n        // setup temp var for player eth\n\n        uint256 _eth;\n\n\n\n        // check to see if round has ended and no one has run round end yet\n\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n\n        {\n\n            // set up our tx event data\n\n            F3Ddatasets.EventReturns memory _eventData_;\n\n\n\n            // end the round (distributes pot)\n\n\t\t\tround_[_rID].ended = true;\n\n            _eventData_ = endRound(_eventData_);\n\n\n\n\t\t\t// get their earnings\n\n            _eth = withdrawEarnings(_pID);\n\n\n\n            // gib moni\n\n            if (_eth > 0)\n\n                plyr_[_pID].addr.transfer(_eth);\n\n\n\n            // build event data\n\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n\n\n\n            // fire withdraw and distribute event\n\n            emit F3Devents.onWithdrawAndDistribute\n\n            (\n\n                msg.sender,\n\n                plyr_[_pID].name,\n\n                _eth,\n\n                _eventData_.compressedData,\n\n                _eventData_.compressedIDs,\n\n                _eventData_.winnerAddr,\n\n                _eventData_.winnerName,\n\n                _eventData_.amountWon,\n\n                _eventData_.newPot,\n\n                _eventData_.P3DAmount,\n\n                _eventData_.genAmount\n\n            );\n\n\n\n        // in any other situation\n\n        } else {\n\n            // get their earnings\n\n            _eth = withdrawEarnings(_pID);\n\n\n\n            // gib moni\n\n            if (_eth > 0)\n\n                plyr_[_pID].addr.transfer(_eth);\n\n\n\n            // fire withdraw event\n\n            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n\n        }\n\n    }\n\n//==============================================================================\n\n//     _  _ _|__|_ _  _ _  .\n\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\n\n//=====_|=======================================================================\n\n    /**\n\n     * @dev return the price buyer will pay for next 1 individual key.\n\n     * -functionhash- 0x018a25e8\n\n     * @return price for next key bought (in wei format)\n\n     */\n\n    function getBuyPrice()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // are we in a round?\n\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n\n        else // rounds over.  need price for new round\n\n            return ( 75000000000000 ); // init\n\n    }\n\n\n\n    /**\n\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node\n\n     * provider\n\n     * -functionhash- 0xc7e284b8\n\n     * @return time left in seconds\n\n     */\n\n    function getTimeLeft()\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        if (_now < round_[_rID].end)\n\n            if (_now > round_[_rID].strt + rndGap_)\n\n                return( (round_[_rID].end).sub(_now) );\n\n            else\n\n                return( (round_[_rID].strt + rndGap_).sub(_now) );\n\n        else\n\n            return(0);\n\n    }\n\n\n\n    /**\n\n     * @dev returns player earnings per vaults\n\n     * -functionhash- 0x63066434\n\n     * @return winnings vault\n\n     * @return general vault\n\n     * @return affiliate vault\n\n     */\n\n    function getPlayerVaults(uint256 _pID)\n\n        public\n\n        view\n\n        returns(uint256 ,uint256, uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\n\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n\n        {\n\n            // if player is winner\n\n            if (round_[_rID].plyr == _pID)\n\n            {\n\n                return\n\n                (\n\n                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\n\n                    plyr_[_pID].aff\n\n                );\n\n            // if player is not the winner\n\n            } else {\n\n                return\n\n                (\n\n                    plyr_[_pID].win,\n\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\n\n                    plyr_[_pID].aff\n\n                );\n\n            }\n\n\n\n        // if round is still going on, or round has ended and round end has been ran\n\n        } else {\n\n            return\n\n            (\n\n                plyr_[_pID].win,\n\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n\n                plyr_[_pID].aff\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * solidity hates stack limits.  this lets us avoid that hate\n\n     */\n\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n\n        private\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\n\n    }\n\n\n\n    /**\n\n     * @dev returns all current round info needed for front end\n\n     * -functionhash- 0x747dff42\n\n     * @return eth invested during ICO phase\n\n     * @return round id\n\n     * @return total keys for round\n\n     * @return time round ends\n\n     * @return time round started\n\n     * @return current pot\n\n     * @return current team ID & player ID in lead\n\n     * @return current player in leads address\n\n     * @return current player in leads name\n\n     * @return whales eth in for round\n\n     * @return bears eth in for round\n\n     * @return sneks eth in for round\n\n     * @return bulls eth in for round\n\n     * @return airdrop tracker # & airdrop pot\n\n     */\n\n    function getCurrentRoundInfo()\n\n        public\n\n        view\n\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        return\n\n        (\n\n            round_[_rID].ico,               //0\n\n            _rID,                           //1\n\n            round_[_rID].keys,              //2\n\n            round_[_rID].end,               //3\n\n            round_[_rID].strt,              //4\n\n            round_[_rID].pot,               //5\n\n            (round_[_rID].team + (round_[_rID].plyr * 10)),     //6\n\n            plyr_[round_[_rID].plyr].addr,  //7\n\n            plyr_[round_[_rID].plyr].name,  //8\n\n            rndTmEth_[_rID][0],             //9\n\n            rndTmEth_[_rID][1],             //10\n\n            rndTmEth_[_rID][2],             //11\n\n            rndTmEth_[_rID][3],             //12\n\n            airDropTracker_ + (airDropPot_ * 1000)              //13\n\n        );\n\n    }\n\n\n\n    /**\n\n     * @dev returns player info based on address.  if no address is given, it will\n\n     * use msg.sender\n\n     * -functionhash- 0xee0b5d8b\n\n     * @param _addr address of the player you want to lookup\n\n     * @return player ID\n\n     * @return player name\n\n     * @return keys owned (current round)\n\n     * @return winnings vault\n\n     * @return general vault\n\n     * @return affiliate vault\n\n\t * @return player round eth\n\n     */\n\n    function getPlayerInfoByAddress(address _addr)\n\n        public\n\n        view\n\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        if (_addr == address(0))\n\n        {\n\n            _addr == msg.sender;\n\n        }\n\n        uint256 _pID = pIDxAddr_[_addr];\n\n\n\n        return\n\n        (\n\n            _pID,                               //0\n\n            plyr_[_pID].name,                   //1\n\n            plyrRnds_[_pID][_rID].keys,         //2\n\n            plyr_[_pID].win,                    //3\n\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4\n\n            plyr_[_pID].aff,                    //5\n\n            plyrRnds_[_pID][_rID].eth           //6\n\n        );\n\n    }\n\n\n\n//==============================================================================\n\n//     _ _  _ _   | _  _ . _  .\n\n//    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)\n\n//=====================_|=======================================================\n\n    /**\n\n     * @dev logic runs whenever a buy order is executed.  determines how to handle\n\n     * incoming eth depending on if we are in an active round or not\n\n     */\n\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // if round is active\n\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n\n        {\n\n            // call core\n\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n\n\n\n        // if round is not active\n\n        } else {\n\n            // check to see if end round needs to be ran\n\n            if (_now > round_[_rID].end && round_[_rID].ended == false)\n\n            {\n\n                // end the round (distributes pot) & start new round\n\n\t\t\t    round_[_rID].ended = true;\n\n                _eventData_ = endRound(_eventData_);\n\n\n\n                // build event data\n\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n\n\n\n                // fire buy and distribute event\n\n                emit F3Devents.onBuyAndDistribute\n\n                (\n\n                    msg.sender,\n\n                    plyr_[_pID].name,\n\n                    msg.value,\n\n                    _eventData_.compressedData,\n\n                    _eventData_.compressedIDs,\n\n                    _eventData_.winnerAddr,\n\n                    _eventData_.winnerName,\n\n                    _eventData_.amountWon,\n\n                    _eventData_.newPot,\n\n                    _eventData_.P3DAmount,\n\n                    _eventData_.genAmount\n\n                );\n\n            }\n\n\n\n            // put eth in players vault\n\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev logic runs whenever a reload order is executed.  determines how to handle\n\n     * incoming eth depending on if we are in an active round or not\n\n     */\n\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // if round is active\n\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n\n        {\n\n            // get earnings from all vaults and return unused to gen vault\n\n            // because we use a custom safemath library.  this will throw if player\n\n            // tried to spend more eth than they have.\n\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n\n\n\n            // call core\n\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\n\n\n\n        // if round is not active and end round needs to be ran\n\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\n\n            // end the round (distributes pot) & start new round\n\n            round_[_rID].ended = true;\n\n            _eventData_ = endRound(_eventData_);\n\n\n\n            // build event data\n\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n\n\n\n            // fire buy and distribute event\n\n            emit F3Devents.onReLoadAndDistribute\n\n            (\n\n                msg.sender,\n\n                plyr_[_pID].name,\n\n                _eventData_.compressedData,\n\n                _eventData_.compressedIDs,\n\n                _eventData_.winnerAddr,\n\n                _eventData_.winnerName,\n\n                _eventData_.amountWon,\n\n                _eventData_.newPot,\n\n                _eventData_.P3DAmount,\n\n                _eventData_.genAmount\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev this is the core logic for any buy/reload that happens while a round\n\n     * is live.\n\n     */\n\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n    {\n\n        // if player is new to round\n\n        if (plyrRnds_[_pID][_rID].keys == 0)\n\n            _eventData_ = managePlayer(_pID, _eventData_);\n\n\n\n        // early round eth limiter\n\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 2100000000000000000)\n\n        {\n\n            uint256 _availableLimit = (2100000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n\n            uint256 _refund = _eth.sub(_availableLimit);\n\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n\n            _eth = _availableLimit;\n\n        }\n\n\n\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\n\n        if (_eth > 1000000000)\n\n        {\n\n\n\n            // mint the new keys\n\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n\n\n\n            // if they bought at least 1 whole key\n\n            if (_keys >= 1000000000000000000)\n\n            {\n\n            updateTimer(_keys, _rID);\n\n\n\n            // set new leaders\n\n            if (round_[_rID].plyr != _pID)\n\n                round_[_rID].plyr = _pID;\n\n            if (round_[_rID].team != _team)\n\n                round_[_rID].team = _team;\n\n\n\n            // set the new leader bool to true\n\n            _eventData_.compressedData = _eventData_.compressedData + 100;\n\n        }\n\n\n\n            // manage airdrops\n\n            if (_eth >= 100000000000000000)\n\n            {\n\n            airDropTracker_++;\n\n            if (airdrop() == true)\n\n            {\n\n                // gib muni\n\n                uint256 _prize;\n\n                if (_eth >= 10000000000000000000)\n\n                {\n\n                    // calculate prize and give it to winner\n\n                    _prize = ((airDropPot_).mul(75)) / 100;\n\n                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n\n\n\n                    // adjust airDropPot\n\n                    airDropPot_ = (airDropPot_).sub(_prize);\n\n\n\n                    // let event know a tier 3 prize was won\n\n                    _eventData_.compressedData += 300000000000000000000000000000000;\n\n                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n\n                    // calculate prize and give it to winner\n\n                    _prize = ((airDropPot_).mul(50)) / 100;\n\n                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n\n\n\n                    // adjust airDropPot\n\n                    airDropPot_ = (airDropPot_).sub(_prize);\n\n\n\n                    // let event know a tier 2 prize was won\n\n                    _eventData_.compressedData += 200000000000000000000000000000000;\n\n                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n\n                    // calculate prize and give it to winner\n\n                    _prize = ((airDropPot_).mul(25)) / 100;\n\n                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n\n\n\n                    // adjust airDropPot\n\n                    airDropPot_ = (airDropPot_).sub(_prize);\n\n\n\n                    // let event know a tier 3 prize was won\n\n                    _eventData_.compressedData += 300000000000000000000000000000000;\n\n                }\n\n                // set airdrop happened bool to true\n\n                _eventData_.compressedData += 10000000000000000000000000000000;\n\n                // let event know how much was won\n\n                _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n\n\n\n                // reset air drop tracker\n\n                airDropTracker_ = 0;\n\n            }\n\n        }\n\n\n\n            // store the air drop tracker number (number of buys since last airdrop)\n\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n\n\n\n            // update player\n\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n\n\n\n            // update round\n\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\n\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\n\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n\n\n\n            // distribute eth\n\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n\n\n\n            // call end tx function to fire end tx event.\n\n\t\t    endTx(_pID, _team, _eth, _keys, _eventData_);\n\n        }\n\n    }\n\n//==============================================================================\n\n//     _ _ | _   | _ _|_ _  _ _  .\n\n//    (_(_||(_|_||(_| | (_)| _\\  .\n\n//==============================================================================\n\n    /**\n\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\n\n     * @return earnings in wei format\n\n     */\n\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n\n        private\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\n\n    }\n\n\n\n    /**\n\n     * @dev returns the amount of keys you would get given an amount of eth.\n\n     * -functionhash- 0xce89c80c\n\n     * @param _rID round ID you want price for\n\n     * @param _eth amount of eth sent in\n\n     * @return keys received\n\n     */\n\n    function calcKeysReceived(uint256 _rID, uint256 _eth)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // are we in a round?\n\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n\n            return ( (round_[_rID].eth).keysRec(_eth) );\n\n        else // rounds over.  need keys for new round\n\n            return ( (_eth).keys() );\n\n    }\n\n\n\n    /**\n\n     * @dev returns current eth price for X keys.\n\n     * -functionhash- 0xcf808000\n\n     * @param _keys number of keys desired (in 18 decimal format)\n\n     * @return amount of eth needed to send\n\n     */\n\n    function iWantXKeys(uint256 _keys)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // are we in a round?\n\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n\n        else // rounds over.  need price for new round\n\n            return ( (_keys).eth() );\n\n    }\n\n\n\n    /**\n\n     * @dev checks to make sure user picked a valid team.  if not sets team\n\n     * to default (sneks)\n\n     */\n\n    function verifyTeam(uint256 _team)\n\n        private\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (_team < 0 || _team > 3)\n\n            return(2);\n\n        else\n\n            return(_team);\n\n    }\n\n\n\n    /**\n\n     * @dev decides if round end needs to be run & new round started.  and if\n\n     * player unmasked earnings from previously played rounds need to be moved.\n\n     */\n\n    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n        returns (F3Ddatasets.EventReturns)\n\n    {\n\n        // if player has played a previous round, move their unmasked earnings\n\n        // from that round to gen vault.\n\n        if (plyr_[_pID].lrnd != 0)\n\n            updateGenVault(_pID, plyr_[_pID].lrnd);\n\n\n\n        // update player's last round played\n\n        plyr_[_pID].lrnd = rID_;\n\n\n\n        // set the joined round bool to true\n\n        _eventData_.compressedData = _eventData_.compressedData + 10;\n\n\n\n        return(_eventData_);\n\n    }\n\n\n\n    /**\n\n     * @dev ends the round. manages paying out winner/splitting up pot\n\n     */\n\n    function endRound(F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n        returns (F3Ddatasets.EventReturns)\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_;\n\n\n\n        // grab our winning player and team id's\n\n        uint256 _winPID = round_[_rID].plyr;\n\n        uint256 _winTID = round_[_rID].team;\n\n\n\n        // grab our pot amount\n\n        uint256 _pot = round_[_rID].pot;\n\n\n\n        // calculate our winner share, community rewards, gen share,\n\n        // p3d share, and amount reserved for next pot\n\n        uint256 _win = (_pot.mul(48)) / 100; //48%\n\n        uint256 _com = (_pot / 50); //2%\n\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n\n        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n\n\n\n        // calculate ppt for round mask\n\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n\n        if (_dust > 0)\n\n        {\n\n            _gen = _gen.sub(_dust);\n\n            _res = _res.add(_dust);\n\n        }\n\n\n\n        // pay our winner\n\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n\n\n\n        admin.transfer(_com.add(_p3d / 2));\n\n\n\n        round_[_rID].pot = _pot.add(_p3d / 2);\n\n\n\n        // distribute gen portion to key holders\n\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\n\n\n\n        // prepare event data\n\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\n\n        _eventData_.winnerName = plyr_[_winPID].name;\n\n        _eventData_.amountWon = _win;\n\n        _eventData_.genAmount = _gen;\n\n        _eventData_.P3DAmount = _p3d;\n\n        _eventData_.newPot = _res;\n\n\n\n        // start next round\n\n        rID_++;\n\n        _rID++;\n\n        round_[_rID].strt = now;\n\n        round_[_rID].end = now.add(rndInit_).add(rndGap_);\n\n        round_[_rID].pot = _res;\n\n\n\n        return(_eventData_);\n\n    }\n\n\n\n    /**\n\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\n\n     */\n\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\n\n        private\n\n    {\n\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n\n        if (_earnings > 0)\n\n        {\n\n            // put in gen vault\n\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n\n            // zero out their earnings by updating mask\n\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev updates round timer based on number of whole keys bought.\n\n     */\n\n    function updateTimer(uint256 _keys, uint256 _rID)\n\n        private\n\n    {\n\n        // grab time\n\n        uint256 _now = now;\n\n\n\n        // calculate time based on number of keys bought\n\n        uint256 _newTime;\n\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n\n        else\n\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n\n\n\n        // compare to max and set new end time\n\n        if (_newTime < (rndMax_).add(_now))\n\n            round_[_rID].end = _newTime;\n\n        else\n\n            round_[_rID].end = rndMax_.add(_now);\n\n    }\n\n\n\n    /**\n\n     * @dev generates a random number between 0-99 and checks to see if thats\n\n     * resulted in an airdrop win\n\n     * @return do we have a winner?\n\n     */\n\n    function airdrop()\n\n        private\n\n        view\n\n        returns(bool)\n\n    {\n\n        uint256 seed = uint256(keccak256(abi.encodePacked(\n\n\n\n            (block.timestamp).add\n\n            (block.difficulty).add\n\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n\n            (block.gaslimit).add\n\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n\n            (block.number)\n\n\n\n        )));\n\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n\n            return(true);\n\n        else\n\n            return(false);\n\n    }\n\n\n\n    /**\n\n     * @dev distributes eth based on fees to com, aff, and p3d\n\n     */\n\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n        returns(F3Ddatasets.EventReturns)\n\n    {\n\n        // pay 3% out to community rewards\n\n        uint256 _p1 = _eth / 100; //1%\n\n        uint256 _com = _eth / 50;  //2%\n\n        _com = _com.add(_p1); //1 + 2 = 3\n\n\n\n        uint256 _p3d;\n\n        if (!address(admin).call.value(_com)())\n\n        {\n\n            // This ensures Team Just cannot influence the outcome of FoMo3D with\n\n            // bank migrations by breaking outgoing transactions.\n\n            // Something we would never do. But that's not the point.\n\n            // We spent 2000$ in eth re-deploying just to patch this, we hold the\n\n            // highest belief that everything we create should be trustless.\n\n            // Team JUST, The name you shouldn't have to trust.\n\n            _p3d = _com;\n\n            _com = 0;\n\n        }\n\n\n\n\n\n        // distribute share to affiliate\n\n        uint256 _aff = _eth / 10;\n\n\n\n        // decide what to do with affiliate share of fees\n\n        // affiliate must not be self, and must have a name registered\n\n        if (_affID != _pID && plyr_[_affID].name != '') {\n\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n\n            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n\n        } else {\n\n            _p3d = _aff;\n\n        }\n\n\n\n        // pay out p3d\n\n        _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n\n        if (_p3d > 0)\n\n        {\n\n            // deposit to divies contract\n\n            uint256 _potAmount = _p3d / 2;\n\n\n\n            admin.transfer(_p3d.sub(_potAmount));\n\n\n\n            round_[_rID].pot = round_[_rID].pot.add(_potAmount);\n\n\n\n            // set up event data\n\n            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);\n\n        }\n\n\n\n        return(_eventData_);\n\n    }\n\n\n\n    function potSwap()\n\n        external\n\n        payable\n\n    {\n\n        // setup local rID\n\n        uint256 _rID = rID_ + 1;\n\n\n\n        round_[_rID].pot = round_[_rID].pot.add(msg.value);\n\n        emit F3Devents.onPotSwapDeposit(_rID, msg.value);\n\n    }\n\n\n\n    /**\n\n     * @dev distributes eth based on fees to gen and pot\n\n     */\n\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n        returns(F3Ddatasets.EventReturns)\n\n    {\n\n        // calculate gen share\n\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n\n\n\n        // toss 1% into airdrop pot\n\n        uint256 _air = (_eth / 100);\n\n        airDropPot_ = airDropPot_.add(_air);\n\n\n\n        // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share))\n\n        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n\n\n\n        // calculate pot\n\n        uint256 _pot = _eth.sub(_gen);\n\n\n\n        // distribute gen share (thats what updateMasks() does) and adjust\n\n        // balances for dust.\n\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n\n        if (_dust > 0)\n\n            _gen = _gen.sub(_dust);\n\n\n\n        // add eth to pot\n\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n\n\n\n        // set up event data\n\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n\n        _eventData_.potAmount = _pot;\n\n\n\n        return(_eventData_);\n\n    }\n\n\n\n    /**\n\n     * @dev updates masks for round and player when keys are bought\n\n     * @return dust left over\n\n     */\n\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n\n        private\n\n        returns(uint256)\n\n    {\n\n        /* MASKING NOTES\n\n            earnings masks are a tricky thing for people to wrap their minds around.\n\n            the basic thing to understand here.  is were going to have a global\n\n            tracker based on profit per share for each round, that increases in\n\n            relevant proportion to the increase in share supply.\n\n\n\n            the player will have an additional mask that basically says \"based\n\n            on the rounds mask, my shares, and how much i've already withdrawn,\n\n            how much is still owed to me?\"\n\n        */\n\n\n\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\n\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\n\n\n\n        // calculate player earning from their own buy (only based on the keys\n\n        // they just bought).  & update player earnings mask\n\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n\n\n\n        // calculate & return dust\n\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n\n    }\n\n\n\n    /**\n\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\n\n     * @return earnings in wei format\n\n     */\n\n    function withdrawEarnings(uint256 _pID)\n\n        private\n\n        returns(uint256)\n\n    {\n\n        // update gen vault\n\n        updateGenVault(_pID, plyr_[_pID].lrnd);\n\n\n\n        // from vaults\n\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n\n        if (_earnings > 0)\n\n        {\n\n            plyr_[_pID].win = 0;\n\n            plyr_[_pID].gen = 0;\n\n            plyr_[_pID].aff = 0;\n\n        }\n\n\n\n        return(_earnings);\n\n    }\n\n\n\n    /**\n\n     * @dev prepares compression data and fires event for buy or reload tx's\n\n     */\n\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\n\n        private\n\n    {\n\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n\n\n\n        emit F3Devents.onEndTx\n\n        (\n\n            _eventData_.compressedData,\n\n            _eventData_.compressedIDs,\n\n            plyr_[_pID].name,\n\n            msg.sender,\n\n            _eth,\n\n            _keys,\n\n            _eventData_.winnerAddr,\n\n            _eventData_.winnerName,\n\n            _eventData_.amountWon,\n\n            _eventData_.newPot,\n\n            _eventData_.P3DAmount,\n\n            _eventData_.genAmount,\n\n            _eventData_.potAmount,\n\n            airDropPot_\n\n        );\n\n    }\n\n//==============================================================================\n\n//    (~ _  _    _._|_    .\n\n//    _)(/_(_|_|| | | \\/  .\n\n//====================/=========================================================\n\n    /** upon contract deploy, it will be deactivated.  this is a one time\n\n     * use function that will activate the contract.  we do this so devs\n\n     * have time to set things up on the web end                            **/\n\n    bool public activated_ = false;\n\n    function activate()\n\n        public\n\n    {\n\n        // only team just can activate\n\n        require(msg.sender == admin);\n\n\n\n\n\n        // can only be ran once\n\n        require(activated_ == false);\n\n\n\n        // activate the contract\n\n        activated_ = true;\n\n\n\n        // lets start first round\n\n        rID_ = 1;\n\n            round_[1].strt = now + rndExtra_ - rndGap_;\n\n            round_[1].end = now + rndInit_ + rndExtra_;\n\n    }\n\n}\n\n\n\n//==============================================================================\n\n//   __|_ _    __|_ _  .\n\n//  _\\ | | |_|(_ | _\\  .\n\n//==============================================================================\n\nlibrary F3Ddatasets {\n\n    //compressedData key\n\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\n\n        // 0 - new player (bool)\n\n        // 1 - joined round (bool)\n\n        // 2 - new  leader (bool)\n\n        // 3-5 - air drop tracker (uint 0-999)\n\n        // 6-16 - round end time\n\n        // 17 - winnerTeam\n\n        // 18 - 28 timestamp\n\n        // 29 - team\n\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\n\n        // 31 - airdrop happened bool\n\n        // 32 - airdrop tier\n\n        // 33 - airdrop amount won\n\n    //compressedIDs key\n\n    // [77-52][51-26][25-0]\n\n        // 0-25 - pID\n\n        // 26-51 - winPID\n\n        // 52-77 - rID\n\n    struct EventReturns {\n\n        uint256 compressedData;\n\n        uint256 compressedIDs;\n\n        address winnerAddr;         // winner address\n\n        bytes32 winnerName;         // winner name\n\n        uint256 amountWon;          // amount won\n\n        uint256 newPot;             // amount in new pot\n\n        uint256 P3DAmount;          // amount distributed to p3d\n\n        uint256 genAmount;          // amount distributed to gen\n\n        uint256 potAmount;          // amount added to pot\n\n    }\n\n    struct Player {\n\n        address addr;   // player address\n\n        bytes32 name;   // player name\n\n        uint256 win;    // winnings vault\n\n        uint256 gen;    // general vault\n\n        uint256 aff;    // affiliate vault\n\n        uint256 lrnd;   // last round played\n\n        uint256 laff;   // last affiliate id used\n\n    }\n\n    struct PlayerRounds {\n\n        uint256 eth;    // eth player has added to round (used for eth limiter)\n\n        uint256 keys;   // keys\n\n        uint256 mask;   // player mask\n\n        uint256 ico;    // ICO phase investment\n\n    }\n\n    struct Round {\n\n        uint256 plyr;   // pID of player in lead\n\n        uint256 team;   // tID of team in lead\n\n        uint256 end;    // time ends/ended\n\n        bool ended;     // has round end function been ran\n\n        uint256 strt;   // time round started\n\n        uint256 keys;   // keys\n\n        uint256 eth;    // total eth in\n\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\n\n        uint256 mask;   // global mask\n\n        uint256 ico;    // total eth sent in during ICO phase\n\n        uint256 icoGen; // total eth for gen during ICO phase\n\n        uint256 icoAvg; // average key price for ICO phase\n\n    }\n\n    struct TeamFee {\n\n        uint256 gen;    // % of buy in thats paid to key holders of current round\n\n        uint256 p3d;    // % of buy in thats paid to p3d holders\n\n    }\n\n    struct PotSplit {\n\n        uint256 gen;    // % of pot thats paid to key holders of current round\n\n        uint256 p3d;    // % of pot thats paid to p3d holders\n\n    }\n\n}\n\n\n\n//==============================================================================\n\n//  |  _      _ _ | _  .\n\n//  |<(/_\\/  (_(_||(_  .\n\n//=======/======================================================================\n\nlibrary F3DKeysCalcShort {\n\n    using SafeMath for *;\n\n    /**\n\n     * @dev calculates number of keys received given X eth\n\n     * @param _curEth current amount of eth in contract\n\n     * @param _newEth eth being spent\n\n     * @return amount of ticket purchased\n\n     */\n\n    function keysRec(uint256 _curEth, uint256 _newEth)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n\n    }\n\n\n\n    /**\n\n     * @dev calculates amount of eth received if you sold X keys\n\n     * @param _curKeys current amount of keys that exist\n\n     * @param _sellKeys amount of keys you wish to sell\n\n     * @return amount of eth received\n\n     */\n\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n\n    }\n\n\n\n    /**\n\n     * @dev calculates how many keys would exist with given an amount of eth\n\n     * @param _eth eth \"in contract\"\n\n     * @return number of keys that would exist\n\n     */\n\n    function keys(uint256 _eth)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n\n    }\n\n\n\n    /**\n\n     * @dev calculates how much eth would be in contract given a number of keys\n\n     * @param _keys number of keys \"in contract\"\n\n     * @return eth that would exists\n\n     */\n\n    function eth(uint256 _keys)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n\n    }\n\n}\n\n\n\n//==============================================================================\n\n//  . _ _|_ _  _ |` _  _ _  _  .\n\n//  || | | (/_| ~|~(_|(_(/__\\  .\n\n//==============================================================================\n\n\n\ninterface PlayerBookInterface {\n\n    function getPlayerID(address _addr) external returns (uint256);\n\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\n\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\n\n    function getPlayerAddr(uint256 _pID) external view returns (address);\n\n    function getNameFee() external view returns (uint256);\n\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n\n}\n\n\n\n\n\nlibrary NameFilter {\n\n    /**\n\n     * @dev filters name strings\n\n     * -converts uppercase to lower case.\n\n     * -makes sure it does not start/end with a space\n\n     * -makes sure it does not contain multiple spaces in a row\n\n     * -cannot be only numbers\n\n     * -cannot start with 0x\n\n     * -restricts characters to A-Z, a-z, 0-9, and space.\n\n     * @return reprocessed string in bytes32 format\n\n     */\n\n    function nameFilter(string _input)\n\n        internal\n\n        pure\n\n        returns(bytes32)\n\n    {\n\n        bytes memory _temp = bytes(_input);\n\n        uint256 _length = _temp.length;\n\n\n\n        //sorry limited to 32 characters\n\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n\n        // make sure it doesnt start with or end with space\n\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n\n        // make sure first two characters are not 0x\n\n        if (_temp[0] == 0x30)\n\n        {\n\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\n\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\n\n        }\n\n\n\n        // create a bool to track if we have a non number character\n\n        bool _hasNonNumber;\n\n\n\n        // convert & check\n\n        for (uint256 i = 0; i < _length; i++)\n\n        {\n\n            // if its uppercase A-Z\n\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n\n            {\n\n                // convert to lower case a-z\n\n                _temp[i] = byte(uint(_temp[i]) + 32);\n\n\n\n                // we have a non number\n\n                if (_hasNonNumber == false)\n\n                    _hasNonNumber = true;\n\n            } else {\n\n                require\n\n                (\n\n                    // require character is a space\n\n                    _temp[i] == 0x20 ||\n\n                    // OR lowercase a-z\n\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n\n                    // or 0-9\n\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n\n                    \"string contains invalid characters\"\n\n                );\n\n                // make sure theres not 2x spaces in a row\n\n                if (_temp[i] == 0x20)\n\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n\n\n\n                // see if we have a character other than a number\n\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n\n                    _hasNonNumber = true;\n\n            }\n\n        }\n\n\n\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\n\n\n\n        bytes32 _ret;\n\n        assembly {\n\n            _ret := mload(add(_temp, 32))\n\n        }\n\n        return (_ret);\n\n    }\n\n}\n\n\n\n/**\n\n * @title SafeMath v0.1.9\n\n * @dev Math operations with safety checks that throw on error\n\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n\n * - added sqrt\n\n * - added sq\n\n * - added pwr\n\n * - changed asserts to requires with error log outputs\n\n * - removed div, its useless\n\n */\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, throws on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256 c)\n\n    {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        require(c / a == b, \"SafeMath mul failed\");\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        require(b <= a, \"SafeMath sub failed\");\n\n        return a - b;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, throws on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256 c)\n\n    {\n\n        c = a + b;\n\n        require(c >= a, \"SafeMath add failed\");\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev gives square root of given x.\n\n     */\n\n    function sqrt(uint256 x)\n\n        internal\n\n        pure\n\n        returns (uint256 y)\n\n    {\n\n        uint256 z = ((add(x,1)) / 2);\n\n        y = x;\n\n        while (z < y)\n\n        {\n\n            y = z;\n\n            z = ((add((x / z),z)) / 2);\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev gives square. multiplies x by x\n\n     */\n\n    function sq(uint256 x)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return (mul(x,x));\n\n    }\n\n\n\n    /**\n\n     * @dev x to the power of y\n\n     */\n\n    function pwr(uint256 x, uint256 y)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (x==0)\n\n            return (0);\n\n        else if (y==0)\n\n            return (1);\n\n        else\n\n        {\n\n            uint256 z = x;\n\n            for (uint256 i=1; i < y; i++)\n\n                z = mul(z,x);\n\n            return (z);\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 44,
    "addr4sss": "0x004a60e932aeb59ab06996586a64c8cea37c3875",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 1,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "LE",
        "SWC-ID": "-",
        "Description": "Locked Ether"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.11;\n\n\n\ncontract Token {\n\n\n\n    /// @return total amount of tokens\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of wei to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n\n}\n\n\n\ncontract StandardToken is Token {\n\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n\n        //Replace the if with this one instead.\n\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        if (balances[msg.sender] >= _value && _value > 0) {\n\n            balances[msg.sender] -= _value;\n\n            balances[_to] += _value;\n\n            Transfer(msg.sender, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n\n            balances[_to] += _value;\n\n            balances[_from] -= _value;\n\n            allowed[_from][msg.sender] -= _value;\n\n            Transfer(_from, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n      return allowed[_owner][_spender];\n\n    }\n\n\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 public totalSupply;\n\n}\n\n\n\ncontract MinCoin is StandardToken { // CHANGE THIS. Update the contract name.\n\n\n\n    /* Public variables of the token */\n\n\n\n    /*\n\n    NOTE:\n\n    The following variables are OPTIONAL vanities. One does not have to include them.\n\n    They allow one to customise the token contract & in no way influences the core functionality.\n\n    Some wallets/interfaces might not even bother to look at this information.\n\n    */\n\n    string public name;                   // Token Name\n\n    uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18\n\n    string public symbol;                 // An identifier: eg SBX, XPR etc..\n\n    string public version = 'H1.0'; \n\n    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n\n    uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.  \n\n    address public fundsWallet;           // Where should the raised ETH go?\n\n\n\n    // This is a constructor function \n\n    // which means the following function name has to match the contract name declared above\n\n    function MinCoin() {\n\n        balances[msg.sender] = 1000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)\n\n        totalSupply = 1000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)\n\n        name = \"MinCoin\";                                   // Set the name for display purposes (CHANGE THIS)\n\n        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)\n\n        symbol = \"MC\";                                             // Set the symbol for display purposes (CHANGE THIS)\n\n        unitsOneEthCanBuy = 10;                                      // Set the price of your token for the ICO (CHANGE THIS)\n\n        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH\n\n    }\n\n\n\n    function() payable{\n\n        totalEthInWei = totalEthInWei + msg.value;\n\n        uint256 amount = msg.value * unitsOneEthCanBuy;\n\n        require(balances[fundsWallet] >= amount);\n\n\n\n        balances[fundsWallet] = balances[fundsWallet] - amount;\n\n        balances[msg.sender] = balances[msg.sender] + amount;\n\n\n\n        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n\n\n\n        //Transfer ether to fundsWallet\n\n        fundsWallet.transfer(msg.value);                               \n\n    }\n\n\n\n    /* Approves and then calls the receiving contract */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n\n        return true;\n\n    }\n\n}"
  },
  {
    "id": 45,
    "addr4sss": "0x004e702aa7e3850f7da045f65da3218059b09381",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address private _owner;\n\n\n\n  event OwnershipTransferred(\n\n    address indexed previousOwner,\n\n    address indexed newOwner\n\n  );\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  constructor() internal {\n\n    _owner = msg.sender;\n\n    emit OwnershipTransferred(address(0), _owner);\n\n  }\n\n\n\n  /**\n\n   * @return the address of the owner.\n\n   */\n\n  function owner() public view returns(address) {\n\n    return _owner;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(isOwner());\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @return true if `msg.sender` is the owner of the contract.\n\n   */\n\n  function isOwner() public view returns(bool) {\n\n    return msg.sender == _owner;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to relinquish control of the contract.\n\n   * @notice Renouncing to ownership will leave the contract without an owner.\n\n   * It will not be possible to call the functions with the `onlyOwner`\n\n   * modifier anymore.\n\n   */\n\n  function renounceOwnership() public onlyOwner {\n\n    emit OwnershipTransferred(_owner, address(0));\n\n    _owner = address(0);\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    _transferOwnership(newOwner);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfers control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function _transferOwnership(address newOwner) internal {\n\n    require(newOwner != address(0));\n\n    emit OwnershipTransferred(_owner, newOwner);\n\n    _owner = newOwner;\n\n  }\n\n}\n\n\n\n//import \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\n\n\ncontract PixelStorage is Ownable{\n\n\n\n    uint32[] coordinates;\n\n    uint32[] rgba;\n\n    address[] owners;\n\n    uint256[] prices;\n\n\n\n    // simple counter used for indexing\n\n    uint32 public pixelCount;\n\n\n\n    // maps (x | y) to index in the flat arrays\n\n    // Example for first pixel at (5,3)\n\n    // (5|3) =>  (5 << 16 | 3) => (327680 | 3) => 327683  \n\n    // stores 1 as index the first index\n\n    // since 0 is default mapping value\n\n    // coordinatesToIndex[327683] -> 1;\n\n\n\n    mapping(uint32 => uint32) coordinatesToIndex;\n\n\n\n    constructor () public\n\n    {\n\n        pixelCount = 0;\n\n    }\n\n    \n\n    function getBalance() public view returns (uint256) {\n\n        return address(this).balance;\n\n    }\n\n    \n\n    function withdraw() onlyOwner public {\n\n        msg.sender.transfer(address(this).balance);\n\n    }\n\n    \n\n    function buyPixel(uint16 _x, uint16 _y, uint32 _rgba) public payable {\n\n\n\n        require(0 <= _x && _x < 0x200, \"X should be in range 0-511\");\n\n        require(0 <= _y && _y < 0x200, \"Y should be in range 0-511\");\n\n\n\n        uint32 coordinate = uint32(_x) << 16 | _y;\n\n        uint32 index = coordinatesToIndex[coordinate];\n\n        if(index == 0)\n\n        {\n\n            // pixel not owned yet\n\n            // check funds\n\n            require(msg.value >= 1 finney, \"Send atleast one finney!\");\n\n            \n\n            // bump the pixelCount before usage so it starts with 1 and not the default array value 0\n\n            pixelCount += 1;\n\n            // store the index in mapping\n\n            coordinatesToIndex[coordinate] = pixelCount;\n\n            \n\n            // push values to flat-arrays\n\n            coordinates.push(coordinate);\n\n            rgba.push(_rgba);\n\n            prices.push(msg.value);\n\n            owners.push(msg.sender);\n\n        }\n\n        else\n\n        {\n\n            // pixel is already owned\n\n            require(msg.value >= prices[index-1] + 1 finney , \"Insufficient funds send(atleast price + 1 finney)!\");\n\n            prices[index-1] = msg.value;\n\n            owners[index-1] = msg.sender;\n\n            rgba[index-1] = _rgba;\n\n        }\n\n        \n\n    }\n\n    \n\n    \n\n    function getPixels() public view returns (uint32[],  uint32[], address[],uint256[]) {\n\n        return (coordinates,rgba,owners,prices);\n\n    }\n\n    \n\n    function getPixel(uint16 _x, uint16 _y) public view returns (uint32, address, uint256){\n\n        uint32 coordinate = uint32(_x) << 16 | _y;\n\n        uint32 index = coordinatesToIndex[coordinate];\n\n        if(index == 0){\n\n            return (0, address(0x0), 0);\n\n        }else{\n\n            return (\n\n                rgba[index-1], \n\n                owners[index-1],\n\n                prices[index-1]\n\n            );\n\n        }\n\n    }\n\n}"
  },
  {
    "id": 46,
    "addr4sss": "0x0051d363a60bd98d8a10927d10708e5ef853b306",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 1,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "RENT",
        "SWC-ID": "SWC-107",
        "Description": "Reentrancy"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.16;\n\n\n\ncontract Token {\n\n\n\n    /// @return total amount of tokens\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of wei to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    \n\n}\n\n\n\ncontract StandardToken is Token {\n\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n\n        //Replace the if with this one instead.\n\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        if (balances[msg.sender] >= _value && _value > 0) {\n\n            balances[msg.sender] -= _value;\n\n            balances[_to] += _value;\n\n            Transfer(msg.sender, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n\n            balances[_to] += _value;\n\n            balances[_from] -= _value;\n\n            allowed[_from][msg.sender] -= _value;\n\n            Transfer(_from, _to, _value);\n\n            return true;\n\n        } else { return false; }\n\n    }\n\n\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n      return allowed[_owner][_spender];\n\n    }\n\n\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 public totalSupply;\n\n}\n\n\n\n\n\n//name this contract whatever you'd like\n\ncontract SWAPCOINZ is StandardToken {\n\n\n\n    function () {\n\n        //if ether is sent to this address, send it back.\n\n        throw;\n\n    }\n\n\n\n    /* Public variables of the token */\n\n\n\n    /*\n\n    NOTE:\n\n    The following variables are OPTIONAL vanities. One does not have to include them.\n\n    They allow one to customise the token contract & in no way influences the core functionality.\n\n    Some wallets/interfaces might not even bother to look at this information.\n\n    */\n\n    string public name;                   //fancy name: eg Simon Bucks\n\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n\n    string public symbol;                 //An identifier: eg SBX\n\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n\n\n\n\n    function SWAPCOINZ(\n\n        ) {\n\n        balances[msg.sender] = 90000000000000 ;\n\n        totalSupply = 90000000000000;\n\n        name = \"SWAPCOINZ\";                                   // Set the name for display purposes\n\n        decimals = 6;                            // Amount of decimals for display purposes\n\n        symbol = \"SPZ\";                               // Set the symbol for display purposes\n\n    }\n\n\n\n    /* Approves and then calls the receiving contract */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n\n        return true;\n\n    }\n\n}"
  },
  {
    "id": 47,
    "addr4sss": "0x005275450e77bfa6bcbd04d85175d5d0f2dfae43",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.24;\n\n\n\n// ----------------------------------------------------------------------------\n\n// 'Poolin Miner Token' token contract\n\n//\n\n// Symbol      : PIN\n\n// Name        : Poolin Miner Token\n\n// Website     : https://www.poolin.com\n\n// Total supply: 2100000000\n\n// Decimals    : 18\n\n//\n\n// (c) poolin.com, 2018-07\n\n// ----------------------------------------------------------------------------\n\n\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n *\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n */\n\nlibrary SafeMath {\n\n\n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n\n    // benefit is lost if 'b' is also tested.\n\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n\n\n    c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    // uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return a / b;\n\n  }\n\n\n\n  /**\n\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\n    c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title ERC20Basic\n\n * @dev Simpler version of ERC20 interface\n\n * See https://github.com/ethereum/EIPs/issues/179\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\n\n */\n\ncontract ERC20Basic {\n\n  function totalSupply()                          public view returns (uint256);\n\n  function balanceOf  (address who)               public view returns (uint256);\n\n  function transfer   (address to, uint256 value) public returns (bool);\n\n\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\n/**\n\n * @title Basic token\n\n * @dev Basic version of StandardToken, with no allowances.\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BasicToken.sol\n\n */\n\ncontract BasicToken is ERC20Basic {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  uint256 totalSupply_;\n\n\n\n  /**\n\n  * @dev Total number of tokens in existence\n\n  */\n\n  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n\n  }\n\n\n\n  /**\n\n  * @dev Transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    //require(_to    != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to]        = balances[_to].add(_value);\n\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256) {\n\n    return balances[_owner];\n\n  }\n\n}\n\n\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\n\n */\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance   (address owner,  address spender)           public view returns (uint256);\n\n  function transferFrom(address from,   address to, uint256 value) public returns (bool);\n\n  function approve     (address spender, uint256 value)            public returns (bool);\n\n\n\n  event Approval(\n\n    address indexed owner,\n\n    address indexed spender,\n\n    uint256 value\n\n  );\n\n}\n\n\n\n\n\n/**\n\n * @title Standard ERC20 token\n\n *\n\n * @dev Implementation of the basic standard token.\n\n * https://github.com/ethereum/EIPs/issues/20\n\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\n\n */\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(\n\n    address _from,\n\n    address _to,\n\n    uint256 _value\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    //require(_to    != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to]   = balances[_to].add(_value);\n\n\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n\n\n    emit Transfer(_from, _to, _value);\n\n\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(\n\n    address _owner,\n\n    address _spender\n\n   )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n   * approve should be called when allowed[_spender] == 0. To increment\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _addedValue The amount of tokens to increase the allowance by.\n\n   */\n\n  function increaseApproval(\n\n    address _spender,\n\n    uint256 _addedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n   * approve should be called when allowed[_spender] == 0. To decrement\n\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n\n   * the first transaction is mined)\n\n   * From MonolithDAO Token.sol\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n   */\n\n  function decreaseApproval(\n\n    address _spender,\n\n    uint256 _subtractedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    uint256 oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n  event OwnershipTransferred(\n\n    address indexed previousOwner,\n\n    address indexed newOwner\n\n  );\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  constructor() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param _newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n\n    _transferOwnership(_newOwner);\n\n  }\n\n\n\n  /**\n\n   * @dev Transfers control of the contract to a newOwner.\n\n   * @param _newOwner The address to transfer ownership to.\n\n   */\n\n  function _transferOwnership(address _newOwner) internal {\n\n    require(_newOwner != address(0));\n\n    emit OwnershipTransferred(owner, _newOwner);\n\n    owner = _newOwner;\n\n  }\n\n}\n\n\n\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/lifecycle/Pausable.sol\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    emit Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    emit Unpause();\n\n  }\n\n}\n\n\n\n\n\n/**\n\n * @title Pausable token\n\n * @dev StandardToken modified with pausable transfers.\n\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n\n\n  function transfer(\n\n    address _to,\n\n    uint256 _value\n\n  )\n\n    public\n\n    whenNotPaused\n\n    returns (bool)\n\n  {\n\n    return super.transfer(_to, _value);\n\n  }\n\n\n\n  function transferFrom(\n\n    address _from,\n\n    address _to,\n\n    uint256 _value\n\n  )\n\n    public\n\n    whenNotPaused\n\n    returns (bool)\n\n  {\n\n    return super.transferFrom(_from, _to, _value);\n\n  }\n\n\n\n  function approve(\n\n    address _spender,\n\n    uint256 _value\n\n  )\n\n    public\n\n    whenNotPaused\n\n    returns (bool)\n\n  {\n\n    return super.approve(_spender, _value);\n\n  }\n\n\n\n  function increaseApproval(\n\n    address _spender,\n\n    uint _addedValue\n\n  )\n\n    public\n\n    whenNotPaused\n\n    returns (bool success)\n\n  {\n\n    return super.increaseApproval(_spender, _addedValue);\n\n  }\n\n\n\n  function decreaseApproval(\n\n    address _spender,\n\n    uint _subtractedValue\n\n  )\n\n    public\n\n    whenNotPaused\n\n    returns (bool success)\n\n  {\n\n    return super.decreaseApproval(_spender, _subtractedValue);\n\n  }\n\n}\n\n\n\n// ----------------------------------------------------------------------------\n\n\n\ncontract PoolinToken is PausableToken {\n\n  string public constant name     = \"Poolin Miner Token\";\n\n  string public constant symbol   = \"PIN\";\n\n  uint8  public constant decimals = 18;\n\n\n\n  // total supply: 21 * 10^8 * 10^18\n\n  uint256 internal constant K_INITIAL_SUPPLY = 2100000000 * 10 ** uint256(decimals);\n\n\n\n  /**\n\n   * Token Constructor\n\n   *\n\n   */\n\n  constructor() public {\n\n    totalSupply_         = K_INITIAL_SUPPLY;\n\n    balances[msg.sender] = K_INITIAL_SUPPLY;\n\n\n\n    emit Transfer(address(0), msg.sender, K_INITIAL_SUPPLY);\n\n  }\n\n}"
  },
  {
    "id": 48,
    "addr4sss": "0x00539863217abd04b374a422c855e4c71ed1019a",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 1,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      },
      {
        "vulnerability": "TimeO",
        "SWC-ID": "SWC-114",
        "Description": "Timestamp Ordering (Transaction Order Dependence)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\ncontract Storage {\n\n  address public owner;\n\n  uint256 public storedAmount;\n\n\n\n  function Storage() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  modifier onlyOwner{\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  function()\n\n  public\n\n  payable {\n\n    storeEth();\n\n  }\n\n\n\n  function storeEth()\n\n  public\n\n  payable {\n\n    storedAmount += msg.value;\n\n  }\n\n\n\n  function getEth()\n\n  public\n\n  onlyOwner{\n\n    storedAmount = 0;\n\n    owner.transfer(this.balance);\n\n  }\n\n\n\n  function sendEthTo(address to)\n\n  public\n\n  onlyOwner{\n\n    storedAmount = 0;\n\n    to.transfer(this.balance);\n\n  }\n\n}"
  },
  {
    "id": 49,
    "addr4sss": "0x0056a6ac46c0540b9b39bfeecae0c9482f80f809",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n\n\n\n\nlibrary SafeMath {\n\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\nif (a == 0) {\n\nreturn 0;\n\n}\n\nuint256 c = a * b;\n\nassert(c / a == b);\n\nreturn c;\n\n}\n\n\n\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n// assert(b > 0); // Solidity automatically throws when dividing by 0\n\nuint256 c = a / b;\n\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\nreturn c;\n\n}\n\n\n\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\nassert(b <= a);\n\nreturn a - b;\n\n}\n\n\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\nuint256 c = a + b;\n\nassert(c >= a);\n\nreturn c;\n\n}\n\n}\n\ncontract Ownable {\n\naddress public owner;\n\n\n\n\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n/**\n\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n* account.\n\n*/\n\nfunction Ownable() public {\n\nowner = msg.sender;\n\n}\n\n\n\n\n\n/**\n\n* @dev Throws if called by any account other than the owner.\n\n*/\n\nmodifier onlyOwner() {\n\nrequire(msg.sender == owner);\n\n_;\n\n}\n\n\n\n\n\n/**\n\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n* @param newOwner The address to transfer ownership to.\n\n*/\n\nfunction transferOwnership(address newOwner) public onlyOwner {\n\nrequire(newOwner != address(0));\n\nOwnershipTransferred(owner, newOwner);\n\nowner = newOwner;\n\n}\n\n\n\n}\n\n\n\n\n\n/**\n\n* @title ERC20Basic\n\n* @dev Simpler version of ERC20 interface\n\n*/\n\ncontract ERC20Basic {\n\nuint256 public totalSupply;\n\nfunction balanceOf(address who) public view returns (uint256);\n\nfunction transfer(address to, uint256 value) public returns (bool);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\n\n\ncontract ERC20 is ERC20Basic {\n\nfunction allowance(address owner, address spender) public view returns (uint256);\n\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\nfunction approve(address spender, uint256 value) public returns (bool);\n\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract BasicToken is ERC20Basic {\n\nusing SafeMath for uint256;\n\n\n\nmapping(address => uint256) balances;\n\n\n\n/**\n\n* @dev transfer token for a specified address\n\n* @param _to The address to transfer to.\n\n* @param _value The amount to be transferred.\n\n*/\n\nfunction transfer(address _to, uint256 _value) public returns (bool) {\n\nrequire(_to != address(0));\n\nrequire(_value <= balances[msg.sender]);\n\n\n\n// SafeMath.sub will throw if there is not enough balance.\n\nbalances[msg.sender] = balances[msg.sender].sub(_value);\n\nbalances[_to] = balances[_to].add(_value);\n\nTransfer(msg.sender, _to, _value);\n\nreturn true;\n\n}\n\n\n\n/**\n\n* @dev Gets the balance of the specified address.\n\n* @param _owner The address to query the the balance of.\n\n* @return An uint256 representing the amount owned by the passed address.\n\n*/\n\nfunction balanceOf(address _owner) public view returns (uint256 balance) {\n\nreturn balances[_owner];\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n\n\nmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n\n\n\n\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\nrequire(_to != address(0));\n\nrequire(_value <= balances[_from]);\n\nrequire(_value <= allowed[_from][msg.sender]);\n\n\n\nbalances[_from] = balances[_from].sub(_value);\n\nbalances[_to] = balances[_to].add(_value);\n\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\nTransfer(_from, _to, _value);\n\nreturn true;\n\n}\n\n\n\n/**\n\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n*\n\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n* @param _spender The address which will spend the funds.\n\n* @param _value The amount of tokens to be spent.\n\n*/\n\nfunction approve(address _spender, uint256 _value) public returns (bool) {\n\nallowed[msg.sender][_spender] = _value;\n\nApproval(msg.sender, _spender, _value);\n\nreturn true;\n\n}\n\n\n\n/**\n\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n* @param _owner address The address which owns the funds.\n\n* @param _spender address The address which will spend the funds.\n\n* @return A uint256 specifying the amount of tokens still available for the spender.\n\n*/\n\nfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\nreturn allowed[_owner][_spender];\n\n}\n\n\n\n/**\n\n* approve should be called when allowed[_spender] == 0. To increment\n\n* allowed value is better to use this function to avoid 2 calls (and wait until\n\n* the first transaction is mined)\n\n* From MonolithDAO Token.sol\n\n*/\n\nfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\nApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\nreturn true;\n\n}\n\n\n\nfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\nuint oldValue = allowed[msg.sender][_spender];\n\nif (_subtractedValue > oldValue) {\n\nallowed[msg.sender][_spender] = 0;\n\n} else {\n\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n}\n\nApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\nreturn true;\n\n}\n\n\n\n}\n\n/**\n\n* @title SimpleToken\n\n* @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n\n* Note they can later distribute these tokens as they wish using `transfer` and other\n\n* `StandardToken` functions.\n\n*/\n\ncontract IranCoinToken is StandardToken, Ownable {\n\n\n\nstring public constant name = \"Zarig\";\n\nstring public constant symbol = \"ICD\";\n\nuint8 public constant decimals = 18;\n\nuint256 public constant rewards = 8000000 * (10 ** uint256(decimals));\n\nuint256 public constant INITIAL_SUPPLY = 17000000 * (10 ** uint256(decimals));\n\n\n\n/**\n\n* @dev Constructor that gives msg.sender all of existing tokens.\n\n*/\n\nfunction IranCoinToken() public {\n\ntotalSupply == INITIAL_SUPPLY.add(rewards);\n\nbalances[msg.sender] = INITIAL_SUPPLY;\n\n}\n\n}"
  },
  {
    "id": 50,
    "addr4sss": "0x00571808479ced690a6948992e32b1f3e69df557",
    "ARTHM": 1,
    "DOS": 0,
    "LE": 0,
    "RENT": 0,
    "TimeM": 0,
    "TimeO": 0,
    "Tx-Origin": 0,
    "UE": 0,
    "vulnerabilities": [
      {
        "vulnerability": "ARTHM",
        "SWC-ID": "SWC-101",
        "Description": "Arithmetic (Integer Overflow and Underflow)"
      }
    ],
    "SMART_CONTRACT_CODE": "pragma solidity ^0.4.18;\n\n/*\n\n * Math operations with safety checks\n\n */\n\ncontract SafeMath {\n\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n    return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n\n\n\n\ncontract EURC1 is SafeMath {\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    uint256 public totalSupply;\n\n\taddress public owner;\n\n\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    function EURC1(\n\n        uint256 initialSupply,\n\n        string tokenName,\n\n        uint8 decimalUnits,\n\n        string tokenSymbol\n\n        ) public  {\n\n        balanceOf[msg.sender] = initialSupply;              \n\n        totalSupply = initialSupply;                        \n\n        name = tokenName;                                   \n\n        symbol = tokenSymbol;                               \n\n        decimals = decimalUnits;                    \n\n\t\towner = msg.sender;\n\n    }\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public {\n\n        if (_to == 0x0)  revert();                               \n\n\t\tif (_value <= 0)  revert(); \n\n        if (balanceOf[msg.sender] < _value)  revert();           \n\n        if (balanceOf[_to] + _value < balanceOf[_to])  revert(); \n\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                    \n\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                           \n\n        Transfer(msg.sender, _to, _value);                  \n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        if (_to == 0x0)  revert();                                \n\n\t\tif (_value <= 0)  revert(); \n\n        if (balanceOf[_from] < _value)  revert();                 \n\n        if (balanceOf[_to] + _value < balanceOf[_to])  revert();  \n\n        if (_value > allowance[_from][msg.sender])  revert();     \n\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           \n\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                \n\n        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\n\n        Transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n\n\n}"
  }
]